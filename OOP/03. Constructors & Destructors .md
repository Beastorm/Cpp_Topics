### Constructors
A constructor is a special member function that is automatically called when an object is created. It initializes the object's data members.
```
âœ“ Same name as the class
âœ“ No return type (not even void)
âœ“ Called automatically when the object is created
âœ“ Can be overloaded
âœ“ Can have default arguments
```

### Types of Constructors
#### 1. Default Constructor
Constructor with no parameters (or all default parameters).

``` cpp
#include <iostream>
using namespace std;

class Student {
    int roll;
    string name;

public:
    // Default Constructor
    Student() {
        roll = 0;
        name = "Unknown";
        cout << "Default Constructor called" << endl;
    }

    void display() {
        cout << "Roll: " << roll << ", Name: " << name << endl;
    }
};

int main() {
    Student s1;      // Default constructor called
    s1.display();
    
    return 0;
}
```
**Output:**
``` text 
Default Constructor called
Roll: 0, Name: Unknown
```

#### 2. Parameterized Constructor
A constructor that accepts parameters.

``` cpp
#include <iostream>
using namespace std;

class Student {
    int roll;
    string name;

public:
    // Parameterized Constructor
    Student(int r, string n) {
        roll = r;
        name = n;
        cout << "Parameterized Constructor called" << endl;
    }

    void display() {
        cout << "Roll: " << roll << ", Name: " << name << endl;
    }
};

int main() {
    // Different ways to call
    Student s1(101, "Alice");           // Direct initialization
    Student s2 = Student(102, "Bob");   // Explicit call
    
    s1.display();
    s2.display();
    
    return 0;
}
```
**Output:**

``` text
Parameterized Constructor called
Parameterized Constructor called
Roll: 101, Name: Alice
Roll: 102, Name: Bob
```
#### 3. Copy Constructor
Creates a new object as a copy of an existing object.

```  cpp
#include <iostream>
using namespace std;

class Student {
    int roll;
    string name;

public:
    // Parameterized Constructor
    Student(int r, string n) : roll(r), name(n) {
        cout << "Parameterized Constructor" << endl;
    }

    // Copy Constructor
    Student(const Student &s) {
        roll = s.roll;
        name = s.name;
        cout << "Copy Constructor called" << endl;
    }

    void display() {
        cout << "Roll: " << roll << ", Name: " << name << endl;
    }
};

int main() {
    Student s1(101, "Alice");   // Parameterized
    
    Student s2 = s1;            // Copy constructor
    Student s3(s1);             // Copy constructor
    
    s2.display();
    s3.display();
    
    return 0;
}
```
**Output:**

``` text
Parameterized Constructor
Copy Constructor called
Copy Constructor called
Roll: 101, Name: Alice
Roll: 101, Name: Alice
```

#### 4. Move Constructor (C++11)
Transfers resources from a temporary object.

``` cpp
#include <iostream>
using namespace std;

class Data {
    int* ptr;

public:
    // Parameterized Constructor
    Data(int val) {
        ptr = new int(val);
        cout << "Constructor: " << *ptr << endl;
    }

    // Move Constructor
    Data(Data&& other) noexcept {
        ptr = other.ptr;        // Steal the resource
        other.ptr = nullptr;    // Leave source empty
        cout << "Move Constructor" << endl;
    }

    ~Data() {
        delete ptr;
    }

    void display() {
        if(ptr)
            cout << "Value: " << *ptr << endl;
    }
};

int main() {
    Data d1(100);
    Data d2 = move(d1);    // Move constructor
    
    d2.display();
    
    return 0;
}
```
**Output:**

``` text  
Constructor: 100
Move Constructor
Value: 100
```

### Constructor with Initializer List
A more efficient way to initialize members.

``` cpp
#include <iostream>
using namespace std;

class Rectangle {
    int length;
    int width;

public:
    // Using Initializer List
    Rectangle(int l, int w) : length(l), width(w) {
        cout << "Constructor with Initializer List" << endl;
    }

    int area() {
        return length * width;
    }
};

int main() {
    Rectangle rect(10, 5);
    cout << "Area: " << rect.area() << endl;
    
    return 0;
}
```
**Output:**  
```
Constructor with Initializer List
Area: 50
```

### Constructor Overloading
Multiple constructors with different parameters.

``` cpp
#include <iostream>
using namespace std;

class Box {
    int length, width, height;

public:
    // Default Constructor
    Box() : length(1), width(1), height(1) {
        cout << "Default Constructor" << endl;
    }

    // One parameter (Cube)
    Box(int side) : length(side), width(side), height(side) {
        cout << "Cube Constructor" << endl;
    }

    // Three parameters
    Box(int l, int w, int h) : length(l), width(w), height(h) {
        cout << "Box Constructor" << endl;
    }

    int volume() {
        return length * width * height;
    }
};

int main() {
    Box b1;              // Default
    Box b2(5);           // Cube
    Box b3(2, 3, 4);     // Box

    cout << "Volume b1: " << b1.volume() << endl;
    cout << "Volume b2: " << b2.volume() << endl;
    cout << "Volume b3: " << b3.volume() << endl;

    return 0;
}
```
**Output:**   
``` cpp
Default Constructor
Cube Constructor
Box Constructor
Volume b1: 1
Volume b2: 125
Volume b3: 24
```

### Constructor Types - Quick Summary

| Type           | Syntax                        | Purpose                              |
|----------------|-------------------------------|--------------------------------------|
| Default        | `Class() { }`                 | Initialize with default values       |
| Parameterized  | `Class(int a, int b) { }`     | Initialize with custom values        |
| Copy           | `Class(const Class &obj) { }` | Create copy of existing object       |
| Move           | `Class(Class &&obj) { }`      | Transfer resources efficiently       |




### Important Points

``` 
1. If no constructor defined â†’ Compiler provides a default constructor

2. If ANY constructor defined â†’ Compiler does NOT provide a default

3. Copy constructor is called when:
   â€¢ Object initialized from another object
   â€¢ Object passed by value to the function
   â€¢ Object returned by value from a function

4. Use an initializer list for:
   â€¢ const members
   â€¢ Reference members
   â€¢ Base class initialization
   â€¢ Better performance
```

### When to Use Which?

``` 
Default         â†’ When default values are acceptable
Parameterized   â†’ When custom initialization is needed
Copy            â†’ When deep copy is required
Move            â†’ When dealing with dynamic resources
```

---

## C++ Copy Constructors

1. [What is a Copy Constructor?](#what-is-a-copy-constructor)
2. [When is Copy Constructor Called?](#when-is-copy-constructor-called)
3. [Shallow Copy](#shallow-copy)
4. [Deep Copy](#deep-copy)
5. [Complete Comparison Example](#complete-comparison-example)
6. [Visual Representation](#visual-representation)
7. [Real-World Scenarios](#real-world-scenarios)
8. [Best Practices](#best-practices)

---

### 1 What is a Copy Constructor?
 
A _copy constructor_ is a special constructor that creates a new object as a copy of an existing object of the same class.

``` cpp
class ClassName {
public:
    // Copy Constructor
    ClassName(const ClassName& source) {
        // Copy data from source to this object
    }
};
```
**Key Points**  
``` 
âœ“ Takes a reference to an object of the same class
âœ“ Reference MUST be const (to prevent modification of source)
âœ“ Reference is necessary (pass by value would cause infinite recursion)
âœ“ If not defined, the compiler generates a default one
```

### When is the copy constructor called?


``` cpp
#include <iostream>
using namespace std;

class Demo {
public:
    Demo() { 
        cout << "Default Constructor" << endl; 
    }
    
    Demo(const Demo& src) { 
        cout << "Copy Constructor" << endl; 
    }
};

// Function that takes an object by value
void func1(Demo d) {
    cout << "Inside func1" << endl;
}

// Function that returns an object by value
Demo func2() {
    Demo d;
    return d;
}

int main() {
    cout << "=== Case 1: Direct Initialization ===" << endl;
    Demo d1;           // Default Constructor
    Demo d2 = d1;      // Copy Constructor
    
    cout << "\n=== Case 2: Explicit Copy ===" << endl;
    Demo d3(d1);       // Copy Constructor
    
    cout << "\n=== Case 3: Pass by Value ===" << endl;
    func1(d1);         // Copy Constructor (parameter)
    
    cout << "\n=== Case 4: Return by Value ===" << endl;
    Demo d4 = func2(); // May call Copy Constructor (or RVO)
    
    return 0;
}
```
**Output:**  
```
=== Case 1: Direct Initialization ===
Default Constructor
Copy Constructor

=== Case 2: Explicit Copy ===
Copy Constructor

=== Case 3: Pass by Value ===
Copy Constructor
Inside func1

=== Case 4: Return by Value ===
Default Constructor

```
>**Note:** Case 4 may not show copy due to Return Value Optimization (RVO).

---

### 3. Shallow Copy

### What is Shallow Copy?

Shallow copy copies all member values as-is. For pointers, only the address is copied, not the actual data pointed to. Both objects end up pointing to the same memory location.

Default Copy Constructor = Shallow Copy

``` cpp
#include <iostream>
using namespace std;

class Shallow {
    int* data;

public:
    // Constructor
    Shallow(int value) {
        data = new int(value);  // Allocate memory
        cout << "Constructor: Allocated memory at " << data << endl;
    }

    // Compiler-generated copy constructor does this (SHALLOW):
    // Shallow(const Shallow& src) : data(src.data) { }
    // Just copies the pointer address!

    // Destructor
    ~Shallow() {
        cout << "Destructor: Deleting memory at " << data << endl;
        delete data;
    }

    void setValue(int value) { 
        *data = value; 
    }
    
    int getValue() const { 
        return *data; 
    }
    
    void showAddress() const {
        cout << "Data pointer address: " << data << endl;
    }
};

int main() {
    Shallow obj1(100);
    obj1.showAddress();
    
    cout << "\n--- Creating obj2 as copy of obj1 ---\n" << endl;
    
    Shallow obj2 = obj1;  // Shallow copy (default)
    obj2.showAddress();
    
    cout << "\nobj1 value: " << obj1.getValue() << endl;
    cout << "obj2 value: " << obj2.getValue() << endl;
    
    cout << "\n--- Modifying obj2 ---\n" << endl;
    obj2.setValue(999);
    
    // PROBLEM: obj1 is also changed!
    cout << "obj1 value: " << obj1.getValue() << endl;
    cout << "obj2 value: " << obj2.getValue() << endl;
    
    cout << "\n--- Destructors will be called ---\n" << endl;
    
    return 0;
    // CRASH! Double delete - same memory deleted twice
}
```
**Output (with crash):**  

``` 
Constructor: Allocated memory at 0x5555555592a0
Data pointer address: 0x5555555592a0

--- Creating obj2 as copy of obj1 ---

Data pointer address: 0x5555555592a0    â† SAME ADDRESS!

obj1 value: 100
obj2 value: 100

--- Modifying obj2 ---

obj1 value: 999    â† obj1 ALSO CHANGED!
obj2 value: 999

--- Destructors will be called ---

Destructor: Deleting memory at 0x5555555592a0
Destructor: Deleting memory at 0x5555555592a0    â† DOUBLE DELETE!
*** Error: double free detected ***

```
**Problems with Shallow Copy:**

``` 
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                 SHALLOW COPY PROBLEMS                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 1. Dangling Pointer                                     â”‚
â”‚    - When one object deletes memory, other has invalid  â”‚
â”‚      pointer                                            â”‚
â”‚                                                         â”‚
â”‚ 2. Double Free / Memory Corruption                      â”‚
â”‚    - Same memory deleted twice causing crash            â”‚
â”‚                                                         â”‚
â”‚ 3. Unintended Side Effects                              â”‚
â”‚    - Modifying one object affects the other             â”‚
â”‚                                                         â”‚
â”‚ 4. Memory Leak (in some cases)                          â”‚
â”‚    - Original memory may be lost if reassigned          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### Deep Copy

**What is Deep Copy?**  

Deep copy creates a completely independent copy. For pointers, it allocates new memory and copies the actual data. Each object has its own separate memory.

Implementing Deep Copy

``` cpp
#include <iostream>
#include <cstring>
using namespace std;

class Deep {
    int* data;

public:
    // Constructor
    Deep(int value) {
        data = new int(value);
        cout << "Constructor: Allocated memory at " << data << endl;
    }

    // Deep Copy Constructor
    Deep(const Deep& src) {
        // Allocate NEW memory
        data = new int(*src.data);  // Copy the VALUE, not the address
        cout << "Copy Constructor: Allocated NEW memory at " << data << endl;
    }

    // Destructor
    ~Deep() {
        cout << "Destructor: Deleting memory at " << data << endl;
        delete data;
    }

    void setValue(int value) { 
        *data = value; 
    }
    
    int getValue() const { 
        return *data; 
    }
    
    void showAddress() const {
        cout << "Data pointer address: " << data << endl;
    }
};

int main() {
    Deep obj1(100);
    obj1.showAddress();
    
    cout << "\n--- Creating obj2 as copy of obj1 ---\n" << endl;
    
    Deep obj2 = obj1;  // Deep copy
    obj2.showAddress();
    
    cout << "\nobj1 value: " << obj1.getValue() << endl;
    cout << "obj2 value: " << obj2.getValue() << endl;
    
    cout << "\n--- Modifying obj2 ---\n" << endl;
    obj2.setValue(999);
    
    // obj1 is NOT affected!
    cout << "obj1 value: " << obj1.getValue() << endl;
    cout << "obj2 value: " << obj2.getValue() << endl;
    
    cout << "\n--- Destructors will be called ---\n" << endl;
    
    return 0;
    // No crash! Each object deletes its own memory
}
```

**Output (no crash):**
```
Constructor: Allocated memory at 0x5555555592a0
Data pointer address: 0x5555555592a0

--- Creating obj2 as copy of obj1 ---

Copy Constructor: Allocated NEW memory at 0x5555555592c0    â† DIFFERENT ADDRESS!
Data pointer address: 0x5555555592c0

obj1 value: 100
obj2 value: 100

--- Modifying obj2 ---

obj1 value: 100    â† obj1 UNCHANGED!
obj2 value: 999

--- Destructors will be called ---

Destructor: Deleting memory at 0x5555555592c0
Destructor: Deleting memory at 0x5555555592a0    â† Different memory, safe!

```


---

### Complete Comparison Example
String Class with Both Approaches

``` cpp
#include <iostream>
#include <cstring>
using namespace std;

// ============================================
// SHALLOW COPY VERSION (DANGEROUS)
// ============================================
class ShallowString {
    char* str;
    size_t length;

public:
    // Constructor
    ShallowString(const char* s = "") {
        length = strlen(s);
        str = new char[length + 1];
        strcpy(str, s);
        cout << "[Shallow] Created: \"" << str << "\" at " << (void*)str << endl;
    }

    // Default copy constructor (shallow) - COMPILER GENERATED
    // ShallowString(const ShallowString& src) 
    //     : str(src.str), length(src.length) { }

    // Destructor
    ~ShallowString() {
        cout << "[Shallow] Deleting: \"" << str << "\" at " << (void*)str << endl;
        delete[] str;
    }

    void print() const {
        cout << "String: \"" << str << "\" (length: " << length << ")" << endl;
    }

    void setChar(size_t index, char c) {
        if (index < length) str[index] = c;
    }
};

// ============================================
// DEEP COPY VERSION (SAFE)
// ============================================
class DeepString {
    char* str;
    size_t length;

public:
    // Constructor
    DeepString(const char* s = "") {
        length = strlen(s);
        str = new char[length + 1];
        strcpy(str, s);
        cout << "[Deep] Created: \"" << str << "\" at " << (void*)str << endl;
    }

    // Deep Copy Constructor
    DeepString(const DeepString& src) {
        length = src.length;
        str = new char[length + 1];     // Allocate NEW memory
        strcpy(str, src.str);           // Copy the CONTENT
        cout << "[Deep] Copied: \"" << str << "\" to NEW address " << (void*)str << endl;
    }

    // Copy Assignment Operator (also needed for complete deep copy)
    DeepString& operator=(const DeepString& src) {
        cout << "[Deep] Assignment operator called" << endl;
        
        // Self-assignment check
        if (this == &src) {
            return *this;
        }

        // Delete old memory
        delete[] str;

        // Allocate and copy new data
        length = src.length;
        str = new char[length + 1];
        strcpy(str, src.str);

        return *this;
    }

    // Destructor
    ~DeepString() {
        cout << "[Deep] Deleting: \"" << str << "\" at " << (void*)str << endl;
        delete[] str;
    }

    void print() const {
        cout << "String: \"" << str << "\" (length: " << length << ")" << endl;
    }

    void setChar(size_t index, char c) {
        if (index < length) str[index] = c;
    }
};

// ============================================
// DEMONSTRATION
// ============================================
void demonstrateShallow() {
    cout << "\n========== SHALLOW COPY DEMO ==========" << endl;
    cout << "(This will crash or show undefined behavior)\n" << endl;

    {
        ShallowString s1("Hello");
        s1.print();

        cout << "\n--- Creating s2 as copy of s1 ---" << endl;
        ShallowString s2 = s1;
        s2.print();

        cout << "\n--- Modifying s2 ---" << endl;
        s2.setChar(0, 'J');  // Change 'H' to 'J'

        cout << "After modification:" << endl;
        s1.print();  // s1 is ALSO modified!
        s2.print();

        cout << "\n--- Scope ending, destructors called ---" << endl;
    }
    // CRASH HERE: Double delete!
}

void demonstrateDeep() {
    cout << "\n========== DEEP COPY DEMO ==========" << endl;
    cout << "(This works correctly)\n" << endl;

    {
        DeepString s1("Hello");
        s1.print();

        cout << "\n--- Creating s2 as copy of s1 ---" << endl;
        DeepString s2 = s1;
        s2.print();

        cout << "\n--- Modifying s2 ---" << endl;
        s2.setChar(0, 'J');  // Change 'H' to 'J'

        cout << "After modification:" << endl;
        s1.print();  // s1 is NOT modified
        s2.print();  // Only s2 is modified

        cout << "\n--- Testing assignment operator ---" << endl;
        DeepString s3("World");
        s3 = s1;  // Assignment (not construction)
        s3.print();

        cout << "\n--- Scope ending, destructors called ---" << endl;
    }
    // No crash! Each object has its own memory
}

int main() {
    // Comment out demonstrateShallow() to avoid crash
    // demonstrateShallow();
    
    demonstrateDeep();
    
    return 0;
}
```

**Output for Deep Copy Demo:**  
```
========== DEEP COPY DEMO ==========
(This works correctly)

[Deep] Created: "Hello" at 0x5555555592a0
String: "Hello" (length: 5)

--- Creating s2 as copy of s1 ---
[Deep] Copied: "Hello" to NEW address 0x5555555592c0
String: "Hello" (length: 5)

--- Modifying s2 ---
After modification:
String: "Hello" (length: 5)
String: "Jello" (length: 5)

--- Testing assignment operator ---
[Deep] Created: "World" at 0x5555555592e0
[Deep] Assignment operator called
String: "Hello" (length: 5)

--- Scope ending, destructors called ---
[Deep] Deleting: "Hello" at 0x555555559300
[Deep] Deleting: "Jello" at 0x5555555592c0
[Deep] Deleting: "Hello" at 0x5555555592a0
```



---

## Visual Representation

**Shallow Copy Memory Layout:**  

```
BEFORE COPY:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      obj1       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  data: 0x1000  â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚  Value: 100 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                  0x1000

AFTER SHALLOW COPY (obj2 = obj1):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      obj1       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  data: 0x1000  â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚  Value: 100 â”‚  â† SHARED!
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â–²   0x1000
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚
â”‚      obj2       â”‚           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤           â”‚
â”‚  data: 0x1000  â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

PROBLEM: Both point to the same memory!
- Modify one â†’ affects other
- Delete one â†’ other has dangling pointer
- Delete both â†’ CRASH (double free)

```
**Deep Copy Memory Layout:**

``` 
BEFORE COPY:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      obj1       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  data: 0x1000  â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚  Value: 100 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                  0x1000

AFTER DEEP COPY (obj2 = obj1):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      obj1       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  data: 0x1000  â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚  Value: 100 â”‚  â† obj1's memory
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                  0x1000

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      obj2       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  data: 0x2000  â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚  Value: 100 â”‚  â† obj2's OWN memory
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                  0x2000

CORRECT: Each has independent memory!
- Modify one â†’ other unaffected
- Delete one â†’ other still valid
- Delete both â†’ Safe (different addresses)

```

---
## Advance Concept:

### Table of Contents

1. [Constructor Categories & Semantics](#1-constructor-categories--semantics)
2. [Rule of Zero/Three/Five](#2-rule-of-zerothreefive)

---

### 1. Constructor Categories & Semantics

**Compiler-Generated Constructors:**  
``` cpp
class Widget {
    // Compiler may generate these "special member functions":
    // 1. Default constructor          - Widget()
    // 2. Copy constructor              - Widget(const Widget&)
    // 3. Move constructor              - Widget(Widget&&)
    // 4. Copy assignment operator      - Widget& operator=(const Widget&)
    // 5. Move assignment operator      - Widget& operator=(Widget&&)
    // 6. Destructor                    - ~Widget()
};
```
**Enhanced Version with Visual Indicators**  

| If you declare...     | Default<br>Ctor | Copy<br>Ctor | Move<br>Ctor | Copy<br>Assign | Move<br>Assign | Destructor |
|----------------------|:---------------:|:------------:|:------------:|:--------------:|:--------------:|:----------:|
| **Nothing**          | âœ…              | âœ…           | âœ…           | âœ…             | âœ…             | âœ…         |
| **Any constructor**  | âŒ              | âœ…           | âœ…           | âœ…             | âœ…             | âœ…         |
| **Default Ctor**     | ğŸ‘¤              | âœ…           | âœ…           | âœ…             | âœ…             | âœ…         |
| **Copy Ctor**        | âŒ              | ğŸ‘¤           | âŒ           | âš ï¸             | âŒ             | âœ…         |
| **Move Ctor**        | âŒ              | âŒ           | ğŸ‘¤           | âŒ             | âŒ             | âœ…         |
| **Copy Assign**      | âœ…              | âš ï¸           | âŒ           | ğŸ‘¤             | âŒ             | âœ…         |
| **Move Assign**      | âœ…              | âœ…           | âŒ           | âœ…             | ğŸ‘¤             | âœ…         |
| **Destructor**       | âœ…              | âš ï¸           | âŒ           | âš ï¸             | âŒ             | ğŸ‘¤         |

**Legend**
- âœ… = Auto-generated
- âŒ = Not generated
- ğŸ‘¤ = User-defined
- âš ï¸ = Auto-generated but **deprecated** (avoid relying on this!)

---

### 2. Rule of Zero/Three/Five

**Rule of Zero (Preferred):**  

``` 
// Best practice: Let the compiler handle everything
// Use RAII wrappers for resources

class ModernClass {
    std::string name;                    // Handles its own memory
    std::vector<int> data;               // Handles its own memory
    std::unique_ptr<Resource> resource;  // Handles its own lifetime
    
    // NO destructor, copy/move operations needed!
    // Compiler generates correct ones automatically
};
```

**Rule of Three (Pre-C++11):**
``` cpp
// If you define one, define all three
class LegacyResource {
    char* data;
    size_t size;

public:
    // Constructor
    explicit LegacyResource(size_t sz) 
        : data(new char[sz]), size(sz) {}

    // 1. Destructor
    ~LegacyResource() {
        delete[] data;
    }

    // 2. Copy Constructor
    LegacyResource(const LegacyResource& other)
        : data(new char[other.size]), size(other.size) {
        std::memcpy(data, other.data, size);
    }

    // 3. Copy Assignment
    LegacyResource& operator=(const LegacyResource& other) {
        if (this != &other) {
            delete[] data;
            size = other.size;
            data = new char[size];
            std::memcpy(data, other.data, size);
        }
        return *this;
    }
};
```

**Rule of Five (C++11+):**  

``` cpp
class Resource {
    char* data;
    size_t size;

public:
    // Constructor
    explicit Resource(size_t sz) 
        : data(sz ? new char[sz] : nullptr), size(sz) {}

    // 1. Destructor
    ~Resource() {
        delete[] data;
    }

    // 2. Copy Constructor
    Resource(const Resource& other)
        : data(other.size ? new char[other.size] : nullptr)
        , size(other.size) {
        if (data) std::memcpy(data, other.data, size);
    }

    // 3. Move Constructor
    Resource(Resource&& other) noexcept
        : data(std::exchange(other.data, nullptr))
        , size(std::exchange(other.size, 0)) {}

    // 4. Copy Assignment (Copy-and-Swap Idiom)
    Resource& operator=(const Resource& other) {
        Resource temp(other);
        swap(temp);
        return *this;
    }

    // 5. Move Assignment
    Resource& operator=(Resource&& other) noexcept {
        if (this != &other) {
            delete[] data;
            data = std::exchange(other.data, nullptr);
            size = std::exchange(other.size, 0);
        }
        return *this;
    }

    // Helper for copy-and-swap
    void swap(Resource& other) noexcept {
        using std::swap;
        swap(data, other.data);
        swap(size, other.size);
    }
};
```
---

## Move Constructor, Lvalue vs Rvalue & Move Semantics
A comprehensive deep dive into C++11 move semantics, with detailed examples and visual explanations.

## Table of Contents
* Lvalue vs Rvalue
* Lvalue References vs Rvalue References
* Why Move Semantics?
* Move Constructor
* Move Assignment Operator
* std::move Explained
* Complete Implementation Example
* Perfect Forwarding
* Performance Comparison
* Best Practices & Pitfalls

### 1. Lvalue vs Rvalue
#### Basic Definitions

``` 
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    LVALUE vs RVALUE                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  LVALUE (Locator Value)                                         â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                          â”‚
â”‚  â€¢ Has a persistent memory address                              â”‚
â”‚  â€¢ Can appear on LEFT side of assignment                        â”‚
â”‚  â€¢ Has a name/identity                                          â”‚
â”‚  â€¢ Persists beyond a single expression                          â”‚
â”‚  â€¢ Examples: variables, array elements, dereferenced pointers   â”‚
â”‚                                                                 â”‚
â”‚  RVALUE (Read Value)                                            â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                           â”‚
â”‚  â€¢ Temporary value without persistent address                   â”‚
â”‚  â€¢ Can only appear on RIGHT side of assignment                  â”‚
â”‚  â€¢ No name/identity (usually)                                   â”‚
â”‚  â€¢ Exists only within expression                                â”‚
â”‚  â€¢ Examples: literals, temporaries, function return values      â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

Examples

``` cpp
#include <iostream>
#include <string>
using namespace std;

int getValue() { return 10; }
int& getRef(int& x) { return x; }

int main() {
    // ============ LVALUES ============
    int x = 10;              // x is lvalue
    int y = 20;              // y is lvalue
    int* ptr = &x;           // ptr is lvalue, &x is rvalue
    int& ref = x;            // ref is lvalue
    int arr[5];              // arr[0], arr[1]... are lvalues
    
    // Can take address of lvalues
    cout << "Address of x: " << &x << endl;      // OK
    cout << "Address of ref: " << &ref << endl;  // OK
    
    // ============ RVALUES ============
    // Literals
    // 42, 3.14, 'a', "hello" are rvalues
    
    // Temporaries
    x + y;                   // Result is rvalue
    getValue();              // Return value is rvalue
    string("temp");          // Temporary object is rvalue
    
    // Cannot take address of rvalues (usually)
    // &42;                  // ERROR!
    // &(x + y);             // ERROR!
    // &getValue();          // ERROR!
    
    // ============ SPECIAL CASES ============
    getRef(x) = 100;         // getRef returns lvalue reference, so OK
    
    // String concatenation creates temporary (rvalue)
    string s1 = "Hello";
    string s2 = " World";
    string s3 = s1 + s2;     // s1 + s2 is rvalue (temporary)
    
    return 0;
}
```

**Quick Test: Lvalue or Rvalue?**

``` cpp
int x = 10;
int* p = &x;
int& r = x;
int arr[3] = {1, 2, 3};

// Test each expression
x               // lvalue - has name and address
10              // rvalue - literal
x + 1           // rvalue - temporary result
++x             // lvalue - returns reference to x
x++             // rvalue - returns copy of old value
*p              // lvalue - dereferenced pointer
&x              // rvalue - address is a temporary value
arr[0]          // lvalue - array element
r               // lvalue - reference is alias for x
std::move(x)    // rvalue - explicitly cast to rvalue
static_cast<int&&>(x)  // rvalue - cast to rvalue reference

```

**Value Categories (C++11 Extended)**

``` 
                    Expression
                        â”‚
            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            â”‚                       â”‚
         glvalue                  rvalue
      (generalized)                 â”‚
            â”‚               â”Œâ”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”
      â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”         â”‚               â”‚
      â”‚           â”‚       xvalue          prvalue
   lvalue      xvalue   (expiring)     (pure rvalue)
              (shared)

Examples:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
lvalue:   x, *ptr, arr[i], ++x
prvalue:  42, x++, x + y, string("temp")
xvalue:   std::move(x), static_cast<T&&>(x)

```
### 2. Lvalue References vs Rvalue References

``` cpp
int x = 10;

// Lvalue reference (single &)
int& lref = x;           // OK: binds to lvalue
// int& lref2 = 10;      // ERROR: cannot bind to rvalue

// Const lvalue reference (special case)
const int& clref = 10;   // OK: const lref CAN bind to rvalue
const int& clref2 = x;   // OK: also binds to lvalue

// Rvalue reference (double &&)
int&& rref = 10;         // OK: binds to rvalue
int&& rref2 = x + 5;     // OK: binds to temporary
// int&& rref3 = x;      // ERROR: cannot bind to lvalue
int&& rref4 = std::move(x);  // OK: std::move converts to rvalue

```
Visual Representation
``` 
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              REFERENCE BINDING RULES                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚   REFERENCE TYPE          CAN BIND TO                           â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€          â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€            â”‚
â”‚                                                                 â”‚
â”‚   T&  (lvalue ref)        lvalue only                           â”‚
â”‚                           int x; int& r = x; âœ“                  â”‚
â”‚                           int& r = 10;      âœ—                   â”‚
â”‚                                                                 â”‚
â”‚   const T& (const lref)   lvalue OR rvalue                      â”‚
â”‚                           const int& r = x;  âœ“                  â”‚
â”‚                           const int& r = 10; âœ“                  â”‚
â”‚                                                                 â”‚
â”‚   T&& (rvalue ref)        rvalue only                           â”‚
â”‚                           int&& r = 10;     âœ“                   â”‚
â”‚                           int&& r = x;      âœ—                   â”‚
â”‚                           int&& r = move(x); âœ“                  â”‚
â”‚                                                                 â”‚
â”‚   const T&& (const rref)  rvalue only (rarely used)             â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

```

Function Overloading with References

``` cpp
#include <iostream>
using namespace std;

void process(int& x) {
    cout << "Lvalue reference version: " << x << endl;
}

void process(const int& x) {
    cout << "Const lvalue reference version: " << x << endl;
}

void process(int&& x) {
    cout << "Rvalue reference version: " << x << endl;
}

int main() {
    int a = 10;
    const int b = 20;
    
    process(a);           // Calls: Lvalue reference version
    process(b);           // Calls: Const lvalue reference version
    process(30);          // Calls: Rvalue reference version
    process(a + b);       // Calls: Rvalue reference version
    process(std::move(a)); // Calls: Rvalue reference version
    
    return 0;
}
```
Output:
``` text
Lvalue reference version: 10
Const lvalue reference version: 20
Rvalue reference version: 30
Rvalue reference version: 30
Rvalue reference version: 10

````

Important: Rvalue Reference Variable is an Lvalue!

``` cpp
#include <iostream>
using namespace std;

void foo(int& x)  { cout << "lvalue\n"; }
void foo(int&& x) { cout << "rvalue\n"; }

int main() {
    int&& rref = 10;    // rref binds to rvalue
    
    foo(rref);          // Prints "lvalue"! 
                        // Because rref itself is a NAMED variable (lvalue)
    
    foo(std::move(rref)); // Prints "rvalue"
                          // std::move casts it back to rvalue
    
    return 0;
}
```

### 3. Why Move Semantics?
The Problem: Expensive Copies

``` cpp
#include <iostream>
#include <vector>
#include <chrono>
using namespace std;

class HeavyObject {
    int* data;
    size_t size;

public:
    explicit HeavyObject(size_t sz) : size(sz) {
        data = new int[size];
        for (size_t i = 0; i < size; i++) {
            data[i] = i;
        }
        cout << "Constructed: " << size << " elements" << endl;
    }

    // Copy Constructor - EXPENSIVE!
    HeavyObject(const HeavyObject& src) : size(src.size) {
        data = new int[size];                    // Allocate
        for (size_t i = 0; i < size; i++) {      // Copy each element
            data[i] = src.data[i];
        }
        cout << "Copied: " << size << " elements (EXPENSIVE)" << endl;
    }

    ~HeavyObject() {
        delete[] data;
    }
};

HeavyObject createObject() {
    HeavyObject obj(1000000);  // 1 million elements
    return obj;                // Returns by value - COPY!
}

int main() {
    HeavyObject obj = createObject();
    // Without move semantics:
    // 1. Create temporary in function
    // 2. Copy to obj (1 million elements copied!)
    // 3. Destroy temporary
    
    return 0;
}
``` 

The Solution: Move Instead of Copy
``` 
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    COPY vs MOVE                                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  COPY (Deep Copy)                                               â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                               â”‚
â”‚  1. Allocate new memory                                         â”‚
â”‚  2. Copy all data element by element                            â”‚
â”‚  3. Both objects have separate, identical data                  â”‚
â”‚  Time Complexity: O(n)                                          â”‚
â”‚  Memory: Doubles temporarily                                    â”‚
â”‚                                                                 â”‚
â”‚  MOVE (Transfer Ownership)                                      â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                      â”‚
â”‚  1. Copy pointer value (just the address)                       â”‚
â”‚  2. Set source pointer to nullptr                               â”‚
â”‚  3. No data is actually copied                                  â”‚
â”‚  Time Complexity: O(1)                                          â”‚
â”‚  Memory: No additional allocation                               â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

```

Visual: Copy vs Move

```
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                           COPY OPERATION
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

BEFORE:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                    
â”‚   source    â”‚         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤         â”‚ [1][2][3]...[1000]  â”‚
â”‚ data: 0x100â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚    (heap memory)    â”‚
â”‚ size: 1000  â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

AFTER COPY:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                    
â”‚   source    â”‚         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤         â”‚ [1][2][3]...[1000]  â”‚  â† Still exists
â”‚ data: 0x100â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚    (original)       â”‚
â”‚ size: 1000  â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                    
â”‚    dest     â”‚         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤         â”‚ [1][2][3]...[1000]  â”‚  â† NEW allocation
â”‚ data: 0x200â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚    (copy)           â”‚     + copy all data
â”‚ size: 1000  â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                           MOVE OPERATION
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

BEFORE:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                    
â”‚   source    â”‚         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤         â”‚ [1][2][3]...[1000]  â”‚
â”‚ data: 0x100â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚    (heap memory)    â”‚
â”‚ size: 1000  â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

AFTER MOVE:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                    
â”‚   source    â”‚         
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤         
â”‚ data: null  â”‚         (pointer stolen!)
â”‚ size: 0     â”‚         
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚ [1][2][3]...[1000]  â”‚
â”‚    dest     â”‚         â”‚    (SAME memory)    â”‚  â† NO new allocation
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     Just pointer copy!
â”‚ data: 0x100â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â–º        â–²
â”‚ size: 1000  â”‚                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          Ownership transferred

```

### 4. Move Constructor
Syntax
``` cpp
class ClassName {
public:
    // Move Constructor
    ClassName(ClassName&& source) noexcept {
        // Steal resources from source
        // Leave source in valid but empty state
    }
};
```
Implementation
``` cpp
#include <iostream>
#include <utility>  // for std::exchange
using namespace std;

class Buffer {
    int* data;
    size_t size;
    string name;

public:
    // Regular Constructor
    Buffer(size_t sz, const string& n) 
        : data(new int[sz]), size(sz), name(n) {
        cout << "Constructor: " << name << " (" << size << " elements)" << endl;
    }

    // Copy Constructor (Deep Copy)
    Buffer(const Buffer& src) 
        : data(new int[src.size]), size(src.size), name(src.name + "_copy") {
        for (size_t i = 0; i < size; i++) {
            data[i] = src.data[i];
        }
        cout << "Copy Constructor: " << name << " (DEEP COPY)" << endl;
    }

    // Move Constructor (Transfer Ownership)
    Buffer(Buffer&& src) noexcept 
        : data(src.data)           // Steal the pointer
        , size(src.size)           // Copy the size
        , name(std::move(src.name)) // Move the string
    {
        // Leave source in valid but empty state
        src.data = nullptr;
        src.size = 0;
        
        cout << "Move Constructor: " << name << " (MOVED - O(1))" << endl;
    }

    // Destructor
    ~Buffer() {
        cout << "Destructor: " << name << endl;
        delete[] data;
    }

    void info() const {
        cout << name << ": size=" << size 
             << ", data=" << (data ? "valid" : "null") << endl;
    }
};

int main() {
    cout << "=== Creating original ===" << endl;
    Buffer b1(1000000, "Original");
    b1.info();

    cout << "\n=== Copy (expensive) ===" << endl;
    Buffer b2 = b1;  // Copy constructor
    b1.info();
    b2.info();

    cout << "\n=== Move (cheap) ===" << endl;
    Buffer b3 = std::move(b1);  // Move constructor
    b1.info();  // b1 is now empty
    b3.info();

    cout << "\n=== Cleanup ===" << endl;
    return 0;
}
```
Output:

``` text

=== Creating original ===
Constructor: Original (1000000 elements)
Original: size=1000000, data=valid

=== Copy (expensive) ===
Copy Constructor: Original_copy (DEEP COPY)
Original: size=1000000, data=valid
Original_copy: size=1000000, data=valid

=== Move (cheap) ===
Move Constructor: Original (MOVED - O(1))
: size=0, data=null
Original: size=1000000, data=valid

=== Cleanup ===
Destructor: Original
Destructor: Original_copy
Destructor: 
```

Key Points About Move Constructor

``` â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              MOVE CONSTRUCTOR REQUIREMENTS                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  1. PARAMETER: ClassName&&                                      â”‚
â”‚     â€¢ Takes rvalue reference (non-const)                        â”‚
â”‚     â€¢ Allows modification of source                             â”‚
â”‚                                                                 â”‚
â”‚  2. noexcept                                                    â”‚
â”‚     â€¢ CRITICAL for STL container optimization                   â”‚
â”‚     â€¢ std::vector uses move only if noexcept                    â”‚
â”‚     â€¢ Without it, containers fall back to copy                  â”‚
â”‚                                                                 â”‚
â”‚  3. STEAL RESOURCES                                             â”‚
â”‚     â€¢ Copy pointer values (addresses)                           â”‚
â”‚     â€¢ DO NOT allocate new memory                                â”‚
â”‚                                                                 â”‚
â”‚  4. NULLIFY SOURCE                                              â”‚
â”‚     â€¢ Set source pointers to nullptr                            â”‚
â”‚     â€¢ Set source sizes to 0                                     â”‚
â”‚     â€¢ Source must remain destructible                           â”‚
â”‚                                                                 â”‚
â”‚  5. USE std::move FOR MEMBERS                                   â”‚
â”‚     â€¢ For moveable member variables                             â”‚
â”‚     â€¢ e.g., std::move(src.name) for std::string                 â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

```
### 5. Move Assignment Operator
Implementation

``` cpp
#include <iostream>
#include <utility>
using namespace std;

class Resource {
    int* data;
    size_t size;

public:
    // Constructor
    explicit Resource(size_t sz) : data(new int[sz]), size(sz) {
        cout << "Constructor: size=" << size << endl;
    }

    // Move Constructor
    Resource(Resource&& src) noexcept
        : data(std::exchange(src.data, nullptr))
        , size(std::exchange(src.size, 0)) {
        cout << "Move Constructor" << endl;
    }

    // Move Assignment Operator
    Resource& operator=(Resource&& src) noexcept {
        cout << "Move Assignment" << endl;
        
        // Self-assignment check
        if (this != &src) {
            // Release current resources
            delete[] data;
            
            // Steal from source
            data = std::exchange(src.data, nullptr);
            size = std::exchange(src.size, 0);
        }
        
        return *this;
    }

    // Copy operations (deleted for simplicity)
    Resource(const Resource&) = delete;
    Resource& operator=(const Resource&) = delete;

    // Destructor
    ~Resource() {
        cout << "Destructor: size=" << size << endl;
        delete[] data;
    }

    size_t getSize() const { return size; }
};

int main() {
    Resource r1(100);
    Resource r2(200);
    
    cout << "\nBefore move:" << endl;
    cout << "r1.size = " << r1.getSize() << endl;
    cout << "r2.size = " << r2.getSize() << endl;
    
    cout << "\nMoving r1 to r2:" << endl;
    r2 = std::move(r1);  // Move assignment
    
    cout << "\nAfter move:" << endl;
    cout << "r1.size = " << r1.getSize() << endl;  // 0
    cout << "r2.size = " << r2.getSize() << endl;  // 100
    
    cout << "\nCleanup:" << endl;
    return 0;
}
```

Output:

``` text

Constructor: size=100
Constructor: size=200

Before move:
r1.size = 100
r2.size = 200

Moving r1 to r2:
Move Assignment

After move:
r1.size = 0
r2.size = 100

Cleanup:
Destructor: size=100
Destructor: size=0
```

**Copy-and-Swap Idiom for Assignment**
``` cpp
class Buffer {
    int* data;
    size_t size;

public:
    // ... constructors ...

    // Single unified assignment operator (handles both copy and move)
    Buffer& operator=(Buffer src) noexcept {  // Takes by VALUE
        swap(src);
        return *this;
    }
    // When called with lvalue: src is copy-constructed
    // When called with rvalue: src is move-constructed

    void swap(Buffer& other) noexcept {
        using std::swap;
        swap(data, other.data);
        swap(size, other.size);
    }
};
```
### 6. std::move Explained
What std::move Actually Does

``` cpp
// std::move is just a CAST - it doesn't move anything!
// It converts an lvalue to an rvalue reference

// Simplified implementation:
template<typename T>
typename std::remove_reference<T>::type&& move(T&& arg) noexcept {
    return static_cast<typename std::remove_reference<T>::type&&>(arg);
}
```
**std::move in Action**

``` cpp
#include <iostream>
#include <string>
#include <utility>
using namespace std;

int main() {
    string s1 = "Hello, World!";
    
    cout << "Before move:" << endl;
    cout << "s1 = \"" << s1 << "\"" << endl;
    
    // std::move just casts s1 to rvalue reference
    // The actual move happens in string's move constructor
    string s2 = std::move(s1);
    
    cout << "\nAfter move:" << endl;
    cout << "s1 = \"" << s1 << "\"" << endl;  // Empty (moved-from)
    cout << "s2 = \"" << s2 << "\"" << endl;  // Has the content
    
    // s1 is still valid, just empty
    s1 = "New content";  // OK to assign
    cout << "\nAfter reassignment:" << endl;
    cout << "s1 = \"" << s1 << "\"" << endl;
    
    return 0;
}
```

Output:

``` text

Before move:
s1 = "Hello, World!"

After move:
s1 = ""
s2 = "Hello, World!"

After reassignment:
s1 = "New content"

```

**std::move Flow Diagram**

``` text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     std::move FLOW                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

    string s1 = "Hello";
    string s2 = std::move(s1);

Step 1: s1 is an lvalue
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚    s1    â”‚â”€â”€â”€â”€â”€â”€â–º "Hello"
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Step 2: std::move(s1) casts s1 to rvalue reference (string&&)
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚   s1     â”‚â”€â”€â”€â”€â”€â”€â–º "Hello"
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â”‚
             â–¼
        std::move(s1) returns string&&
        (s1 is now treated as "about to expire")

Step 3: string s2's move constructor is called
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚    s1    â”‚â”€â”€â”€â”€â”€â”€â–º nullptr (emptied)
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚    s2    â”‚â”€â”€â”€â”€â”€â”€â–º "Hello" (stolen from s1)
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

KEY INSIGHT: std::move doesn't move anything!
             It just enables the move constructor to be called.

```

**When to Use std::move**

``` cpp
#include <vector>
#include <string>
using namespace std;

class Widget {
    vector<int> data;
    string name;

public:
    // 1. Moving member variables in move constructor
    Widget(Widget&& src) noexcept
        : data(std::move(src.data))    // Move vector
        , name(std::move(src.name))    // Move string
    {}

    // 2. Taking sink parameters (parameters you'll store)
    void setData(vector<int> newData) {
        data = std::move(newData);  // Move into member
    }

    // 3. Returning local variables (usually not needed - RVO)
    vector<int> getData() {
        return data;  // DON'T use std::move here - inhibits RVO
    }

    // 4. Passing to functions that take by value
    void processElsewhere() {
        someFunction(std::move(data));  // Transfer ownership
    }
};

// 5. Moving into containers
void example() {
    vector<string> vec;
    string s = "Hello";
    
    vec.push_back(s);              // Copies s
    vec.push_back(std::move(s));   // Moves s (s is now empty)
    vec.push_back("World");        // Already rvalue, no move needed
}
```

### 7. Complete Implementation Example
Full Resource-Managing Class

``` cpp
#include <iostream>
#include <utility>
#include <cstring>
#include <algorithm>
using namespace std;

class String {
    char* data;
    size_t length;

    void log(const char* msg) const {
        cout << "[" << (data ? data : "null") << "] " << msg << endl;
    }

public:
    // ================== CONSTRUCTORS ==================

    // Default Constructor
    String() : data(nullptr), length(0) {
        log("Default Constructor");
    }

    // Parameterized Constructor
    String(const char* str) {
        length = strlen(str);
        data = new char[length + 1];
        strcpy(data, str);
        log("Parameterized Constructor");
    }

    // Copy Constructor (Deep Copy)
    String(const String& src) {
        length = src.length;
        if (src.data) {
            data = new char[length + 1];
            strcpy(data, src.data);
        } else {
            data = nullptr;
        }
        log("Copy Constructor (DEEP COPY)");
    }

    // Move Constructor (Transfer Ownership)
    String(String&& src) noexcept
        : data(std::exchange(src.data, nullptr))
        , length(std::exchange(src.length, 0)) {
        log("Move Constructor (TRANSFER)");
    }

    // ================== ASSIGNMENT OPERATORS ==================

    // Copy Assignment Operator
    String& operator=(const String& src) {
        log("Copy Assignment");
        
        if (this != &src) {
            // Create new data
            char* newData = nullptr;
            if (src.data) {
                newData = new char[src.length + 1];
                strcpy(newData, src.data);
            }
            
            // Delete old data
            delete[] data;
            
            // Assign
            data = newData;
            length = src.length;
        }
        return *this;
    }

    // Move Assignment Operator
    String& operator=(String&& src) noexcept {
        log("Move Assignment");
        
        if (this != &src) {
            delete[] data;
            
            data = std::exchange(src.data, nullptr);
            length = std::exchange(src.length, 0);
        }
        return *this;
    }

    // ================== DESTRUCTOR ==================

    ~String() {
        log("Destructor");
        delete[] data;
    }

    // ================== UTILITIES ==================

    const char* c_str() const { return data ? data : ""; }
    size_t size() const { return length; }
    bool empty() const { return length == 0; }

    void swap(String& other) noexcept {
        std::swap(data, other.data);
        std::swap(length, other.length);
    }
};

// Factory function (demonstrates RVO and move)
String createString(const char* str) {
    String temp(str);
    return temp;  // NRVO or move
}

int main() {
    cout << "===== 1. Default Construction =====" << endl;
    String s1;

    cout << "\n===== 2. Parameterized Construction =====" << endl;
    String s2("Hello");

    cout << "\n===== 3. Copy Construction =====" << endl;
    String s3 = s2;  // Copy

    cout << "\n===== 4. Move Construction =====" << endl;
    String s4 = std::move(s2);  // Move (s2 is now empty)

    cout << "\n===== 5. Copy Assignment =====" << endl;
    s1 = s3;  // Copy assign

    cout << "\n===== 6. Move Assignment =====" << endl;
    String s5("World");
    s5 = std::move(s3);  // Move assign (s3 is now empty)

    cout << "\n===== 7. Factory Function =====" << endl;
    String s6 = createString("Factory");

    cout << "\n===== 8. Final State =====" << endl;
    cout << "s1: \"" << s1.c_str() << "\"" << endl;
    cout << "s2: \"" << s2.c_str() << "\" (moved-from)" << endl;
    cout << "s3: \"" << s3.c_str() << "\" (moved-from)" << endl;
    cout << "s4: \"" << s4.c_str() << "\"" << endl;
    cout << "s5: \"" << s5.c_str() << "\"" << endl;
    cout << "s6: \"" << s6.c_str() << "\"" << endl;

    cout << "\n===== 9. Destruction =====" << endl;
    return 0;
}

```
Output:

``` text

===== 1. Default Construction =====
[null] Default Constructor

===== 2. Parameterized Construction =====
[Hello] Parameterized Constructor

===== 3. Copy Construction =====
[Hello] Copy Constructor (DEEP COPY)

===== 4. Move Construction =====
[Hello] Move Constructor (TRANSFER)

===== 5. Copy Assignment =====
[null] Copy Assignment

===== 6. Move Assignment =====
[World] Parameterized Constructor
[World] Move Assignment

===== 7. Factory Function =====
[Factory] Parameterized Constructor

===== 8. Final State =====
s1: "Hello"
s2: "" (moved-from)
s3: "" (moved-from)
s4: "Hello"
s5: "Hello"
s6: "Factory"

===== 9. Destruction =====
[Factory] Destructor
[Hello] Destructor
[Hello] Destructor
[null] Destructor
[null] Destructor
[Hello] Destructor
```

### 8. Perfect Forwarding
The Forwarding Problem

``` cpp
#include <iostream>
#include <utility>
using namespace std;

void actualWork(int& x)  { cout << "lvalue: " << x << endl; }
void actualWork(int&& x) { cout << "rvalue: " << x << endl; }

// Problem: How to forward arguments preserving their value category?

// This doesn't work - always calls lvalue version
template<typename T>
void badWrapper(T&& arg) {
    actualWork(arg);  // arg is named, so it's lvalue!
}

// Solution: std::forward
template<typename T>
void goodWrapper(T&& arg) {
    actualWork(std::forward<T>(arg));  // Preserves value category
}

int main() {
    int x = 10;
    
    cout << "=== Bad Wrapper ===" << endl;
    badWrapper(x);    // lvalue - correct
    badWrapper(20);   // Should be rvalue, but calls lvalue!
    
    cout << "\n=== Good Wrapper ===" << endl;
    goodWrapper(x);   // lvalue - correct
    goodWrapper(20);  // rvalue - correct!
    
    return 0;
}
```

Output:

``` text

=== Bad Wrapper ===
lvalue: 10
lvalue: 20

=== Good Wrapper ===
lvalue: 10
rvalue: 20

```

**How std::forward Works**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    PERFECT FORWARDING                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                â”‚
â”‚  template<typename T>                                          â”‚
â”‚  void wrapper(T&& arg) {                                       â”‚
â”‚      target(std::forward<T>(arg));                             â”‚
â”‚  }                                                             â”‚
â”‚                                                                â”‚
â”‚  WHEN CALLED WITH:          T DEDUCED AS:     FORWARD RETURNS: â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€          â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚
â”‚  wrapper(lvalue)            T&                T& (lvalue)      â”‚
â”‚  wrapper(rvalue)            T                 T&& (rvalue)     â”‚
â”‚                                                                â”‚
â”‚  T&& + T& = T& (reference collapsing)                          â”‚
â”‚  T&& + T = T&&                                                 â”‚
â”‚                                                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

```
**Practical Example: Emplace**

``` cpp
#include <iostream>
#include <vector>
#include <utility>
using namespace std;

class Person {
    string name;
    int age;

public:
    Person(const string& n, int a) : name(n), age(a) {
        cout << "Person(const string&, int) - Copy name" << endl;
    }

    Person(string&& n, int a) : name(std::move(n)), age(a) {
        cout << "Person(string&&, int) - Move name" << endl;
    }
};

// Simulating emplace with perfect forwarding
template<typename... Args>
void createPerson(Args&&... args) {
    Person p(std::forward<Args>(args)...);
}

int main() {
    string name = "Alice";
    
    cout << "Passing lvalue:" << endl;
    createPerson(name, 30);  // Copies name
    
    cout << "\nPassing rvalue:" << endl;
    createPerson(string("Bob"), 25);  // Moves name
    
    cout << "\nPassing with std::move:" << endl;
    createPerson(std::move(name), 35);  // Moves name
    
    return 0;
}
```
Output:

``` text

Passing lvalue:
Person(const string&, int) - Copy name

Passing rvalue:
Person(string&&, int) - Move name

Passing with std::move:
Person(string&&, int) - Move name
```

### 9. Performance Comparison
Benchmark: Copy vs Move

``` cpp
#include <iostream>
#include <vector>
#include <chrono>
#include <string>
using namespace std;

class LargeObject {
    vector<int> data;
    
public:
    LargeObject() : data(1000000) {}  // 1 million integers
    
    // Explicitly define to track
    LargeObject(const LargeObject& src) : data(src.data) {
        // cout << "Copy!" << endl;
    }
    
    LargeObject(LargeObject&& src) noexcept : data(std::move(src.data)) {
        // cout << "Move!" << endl;
    }
};

int main() {
    const int iterations = 1000;
    
    // Benchmark COPY
    {
        vector<LargeObject> source(10);
        auto start = chrono::high_resolution_clock::now();
        
        for (int i = 0; i < iterations; i++) {
            vector<LargeObject> dest;
            for (auto& obj : source) {
                dest.push_back(obj);  // COPY
            }
        }
        
        auto end = chrono::high_resolution_clock::now();
        auto duration = chrono::duration_cast<chrono::milliseconds>(end - start);
        cout << "Copy: " << duration.count() << " ms" << endl;
    }
    
    // Benchmark MOVE
    {
        auto start = chrono::high_resolution_clock::now();
        
        for (int i = 0; i < iterations; i++) {
            vector<LargeObject> source(10);
            vector<LargeObject> dest;
            for (auto& obj : source) {
                dest.push_back(std::move(obj));  // MOVE
            }
        }
        
        auto end = chrono::high_resolution_clock::now();
        auto duration = chrono::duration_cast<chrono::milliseconds>(end - start);
        cout << "Move: " << duration.count() << " ms" << endl;
    }
    
    return 0;
}
```

Typical Output:

``` text

Copy: 2847 ms
Move: 42 ms      â† ~68x faster!
```

**Operation Complexity Comparison**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           OPERATION COMPLEXITY COMPARISON                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                â”‚
â”‚  DATA STRUCTURE      COPY COMPLEXITY     MOVE COMPLEXITY       â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€      â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€     â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€       â”‚
â”‚  std::string         O(n)                O(1)                  â”‚
â”‚  std::vector         O(n)                O(1)                  â”‚
â”‚  std::map            O(n log n)          O(1)                  â”‚
â”‚  std::unordered_map  O(n)                O(1)                  â”‚
â”‚  Raw array           O(n)                O(1) *pointer only    â”‚
â”‚                                                                â”‚
â”‚  * Move only transfers pointer ownership                       â”‚
â”‚  * No element-by-element operation needed                      â”‚
â”‚                                                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 10. Best Practices & Pitfalls
Best Practices

``` cpp
// 1. ALWAYS mark move operations noexcept
class Good {
public:
    Good(Good&&) noexcept;              // âœ“
    Good& operator=(Good&&) noexcept;   // âœ“
};

// 2. Use std::exchange for cleaner move implementation
class Clean {
    int* data;
public:
    Clean(Clean&& src) noexcept
        : data(std::exchange(src.data, nullptr)) {}  // âœ“ Clean!
};

// 3. Leave moved-from objects in valid state
class Valid {
    vector<int> data;
public:
    Valid(Valid&& src) noexcept
        : data(std::move(src.data)) {}
    // src.data is empty but valid vector - can be used again
};

// 4. Use = default when possible
class Simple {
    string name;
    vector<int> data;
public:
    Simple(Simple&&) = default;              // âœ“ Compiler generates optimal move
    Simple& operator=(Simple&&) = default;   // âœ“
};

// 5. Follow Rule of Five (or Rule of Zero)
class Complete {
public:
    ~Complete();
    Complete(const Complete&);
    Complete(Complete&&) noexcept;
    Complete& operator=(const Complete&);
    Complete& operator=(Complete&&) noexcept;
};
```

**Common Pitfalls**

``` cpp
// âŒ PITFALL 1: Using std::move on return (inhibits RVO)
vector<int> bad() {
    vector<int> v;
    return std::move(v);  // âŒ Prevents RVO!
}

vector<int> good() {
    vector<int> v;
    return v;  // âœ“ RVO can apply
}

// âŒ PITFALL 2: Using object after std::move
void pitfall2() {
    string s = "Hello";
    string t = std::move(s);
    cout << s.size();  // âš ï¸ s is in valid but unspecified state
    s = "New";         // âœ“ OK to reassign
}

// âŒ PITFALL 3: Forgetting noexcept (containers won't use move!)
class Slow {
public:
    Slow(Slow&&) {}  // âŒ Not noexcept - vector uses copy!
};

class Fast {
public:
    Fast(Fast&&) noexcept {}  // âœ“ noexcept - vector uses move
};

// âŒ PITFALL 4: Moving const objects (actually copies!)
void pitfall4() {
    const string s = "Hello";
    string t = std::move(s);  // âš ï¸ This COPIES! const can't be moved
}

// âŒ PITFALL 5: Self-move assignment
void pitfall5() {
    string s = "Hello";
    s = std::move(s);  // âš ï¸ Undefined behavior in some implementations
}

// âŒ PITFALL 6: Not checking for self-assignment in move assignment
class Dangerous {
    int* data;
public:
    Dangerous& operator=(Dangerous&& src) noexcept {
        delete[] data;          // âŒ If this == &src, we just deleted our data!
        data = src.data;
        src.data = nullptr;
        return *this;
    }
};

class Safe {
    int* data;
public:
    Safe& operator=(Safe&& src) noexcept {
        if (this != &src) {     // âœ“ Check for self-assignment
            delete[] data;
            data = std::exchange(src.data, nullptr);
        }
        return *this;
    }
};
```

### Quick Reference Card

``` 
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                 MOVE SEMANTICS QUICK REFERENCE                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  LVALUE: Has identity, persistent                               â”‚
â”‚  RVALUE: Temporary, can be moved from                           â”‚
â”‚                                                                 â”‚
â”‚  MOVE CONSTRUCTOR:                                              â”‚
â”‚    ClassName(ClassName&& src) noexcept { steal resources; }     â”‚
â”‚                                                                 â”‚
â”‚  MOVE ASSIGNMENT:                                               â”‚
â”‚    ClassName& operator=(ClassName&& src) noexcept { ... }       â”‚
â”‚                                                                 â”‚
â”‚  std::move: Casts lvalue to rvalue reference                    â”‚
â”‚  std::forward: Preserves value category in templates            â”‚
â”‚                                                                 â”‚
â”‚  WHEN TO MOVE:                                                  â”‚
â”‚  âœ“ Temporary objects (automatic)                                â”‚
â”‚  âœ“ Objects you no longer need                                   â”‚
â”‚  âœ“ Passing sink parameters                                      â”‚
â”‚  âœ“ Returning by value (usually automatic via RVO)               â”‚
â”‚                                                                 â”‚
â”‚  WHEN NOT TO MOVE:                                              â”‚
â”‚  âœ— const objects (will copy)                                    â”‚
â”‚  âœ— Return statements (inhibits RVO)                             â”‚
â”‚  âœ— Objects you still need                                       â”‚
â”‚                                                                 â”‚
â”‚  CHECKLIST:                                                     â”‚
â”‚  â–¡ Mark move operations noexcept                                â”‚
â”‚  â–¡ Leave moved-from object in valid state                       â”‚
â”‚  â–¡ Check for self-assignment                                    â”‚
â”‚  â–¡ Use = default when members handle themselves                 â”‚
â”‚  â–¡ Follow Rule of Five or Rule of Zero                          â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

```
