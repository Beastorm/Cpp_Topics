### Constructors
A constructor is a special member function that is automatically called when an object is created. It initializes the object's data members.
```
‚úì Same name as the class
‚úì No return type (not even void)
‚úì Called automatically when the object is created
‚úì Can be overloaded
‚úì Can have default arguments
```

### Types of Constructors
#### 1. Default Constructor
Constructor with no parameters (or all default parameters).

``` cpp
#include <iostream>
using namespace std;

class Student {
    int roll;
    string name;

public:
    // Default Constructor
    Student() {
        roll = 0;
        name = "Unknown";
        cout << "Default Constructor called" << endl;
    }

    void display() {
        cout << "Roll: " << roll << ", Name: " << name << endl;
    }
};

int main() {
    Student s1;      // Default constructor called
    s1.display();
    
    return 0;
}
```
**Output:**
``` text 
Default Constructor called
Roll: 0, Name: Unknown
```

#### 2. Parameterized Constructor
A constructor that accepts parameters.

``` cpp
#include <iostream>
using namespace std;

class Student {
    int roll;
    string name;

public:
    // Parameterized Constructor
    Student(int r, string n) {
        roll = r;
        name = n;
        cout << "Parameterized Constructor called" << endl;
    }

    void display() {
        cout << "Roll: " << roll << ", Name: " << name << endl;
    }
};

int main() {
    // Different ways to call
    Student s1(101, "Alice");           // Direct initialization
    Student s2 = Student(102, "Bob");   // Explicit call
    
    s1.display();
    s2.display();
    
    return 0;
}
```
**Output:**

``` text
Parameterized Constructor called
Parameterized Constructor called
Roll: 101, Name: Alice
Roll: 102, Name: Bob
```
#### 3. Copy Constructor
Creates a new object as a copy of an existing object.

```  cpp
#include <iostream>
using namespace std;

class Student {
    int roll;
    string name;

public:
    // Parameterized Constructor
    Student(int r, string n) : roll(r), name(n) {
        cout << "Parameterized Constructor" << endl;
    }

    // Copy Constructor
    Student(const Student &s) {
        roll = s.roll;
        name = s.name;
        cout << "Copy Constructor called" << endl;
    }

    void display() {
        cout << "Roll: " << roll << ", Name: " << name << endl;
    }
};

int main() {
    Student s1(101, "Alice");   // Parameterized
    
    Student s2 = s1;            // Copy constructor
    Student s3(s1);             // Copy constructor
    
    s2.display();
    s3.display();
    
    return 0;
}
```
**Output:**

``` text
Parameterized Constructor
Copy Constructor called
Copy Constructor called
Roll: 101, Name: Alice
Roll: 101, Name: Alice
```

#### 4. Move Constructor (C++11)
Transfers resources from a temporary object.

``` cpp
#include <iostream>
using namespace std;

class Data {
    int* ptr;

public:
    // Parameterized Constructor
    Data(int val) {
        ptr = new int(val);
        cout << "Constructor: " << *ptr << endl;
    }

    // Move Constructor
    Data(Data&& other) noexcept {
        ptr = other.ptr;        // Steal the resource
        other.ptr = nullptr;    // Leave source empty
        cout << "Move Constructor" << endl;
    }

    ~Data() {
        delete ptr;
    }

    void display() {
        if(ptr)
            cout << "Value: " << *ptr << endl;
    }
};

int main() {
    Data d1(100);
    Data d2 = move(d1);    // Move constructor
    
    d2.display();
    
    return 0;
}
```
**Output:**

``` text  
Constructor: 100
Move Constructor
Value: 100
```

### Constructor with Initializer List
A more efficient way to initialize members.

``` cpp
#include <iostream>
using namespace std;

class Rectangle {
    int length;
    int width;

public:
    // Using Initializer List
    Rectangle(int l, int w) : length(l), width(w) {
        cout << "Constructor with Initializer List" << endl;
    }

    int area() {
        return length * width;
    }
};

int main() {
    Rectangle rect(10, 5);
    cout << "Area: " << rect.area() << endl;
    
    return 0;
}
```
**Output:**  
```
Constructor with Initializer List
Area: 50
```

### Constructor Overloading
Multiple constructors with different parameters.

``` cpp
#include <iostream>
using namespace std;

class Box {
    int length, width, height;

public:
    // Default Constructor
    Box() : length(1), width(1), height(1) {
        cout << "Default Constructor" << endl;
    }

    // One parameter (Cube)
    Box(int side) : length(side), width(side), height(side) {
        cout << "Cube Constructor" << endl;
    }

    // Three parameters
    Box(int l, int w, int h) : length(l), width(w), height(h) {
        cout << "Box Constructor" << endl;
    }

    int volume() {
        return length * width * height;
    }
};

int main() {
    Box b1;              // Default
    Box b2(5);           // Cube
    Box b3(2, 3, 4);     // Box

    cout << "Volume b1: " << b1.volume() << endl;
    cout << "Volume b2: " << b2.volume() << endl;
    cout << "Volume b3: " << b3.volume() << endl;

    return 0;
}
```
**Output:**   
``` cpp
Default Constructor
Cube Constructor
Box Constructor
Volume b1: 1
Volume b2: 125
Volume b3: 24
```

### Constructor Types - Quick Summary

| Type           | Syntax                        | Purpose                              |
|----------------|-------------------------------|--------------------------------------|
| Default        | `Class() { }`                 | Initialize with default values       |
| Parameterized  | `Class(int a, int b) { }`     | Initialize with custom values        |
| Copy           | `Class(const Class &obj) { }` | Create copy of existing object       |
| Move           | `Class(Class &&obj) { }`      | Transfer resources efficiently       |




### Important Points

``` 
1. If no constructor defined ‚Üí Compiler provides a default constructor

2. If ANY constructor defined ‚Üí Compiler does NOT provide a default

3. Copy constructor is called when:
   ‚Ä¢ Object initialized from another object
   ‚Ä¢ Object passed by value to the function
   ‚Ä¢ Object returned by value from a function

4. Use an initializer list for:
   ‚Ä¢ const members
   ‚Ä¢ Reference members
   ‚Ä¢ Base class initialization
   ‚Ä¢ Better performance
```

### When to Use Which?

``` 
Default         ‚Üí When default values are acceptable
Parameterized   ‚Üí When custom initialization is needed
Copy            ‚Üí When deep copy is required
Move            ‚Üí When dealing with dynamic resources
```

---

## C++ Copy Constructors

1. [What is a Copy Constructor?](#what-is-a-copy-constructor)
2. [When is Copy Constructor Called?](#when-is-copy-constructor-called)
3. [Shallow Copy](#shallow-copy)
4. [Deep Copy](#deep-copy)
5. [Complete Comparison Example](#complete-comparison-example)
6. [Visual Representation](#visual-representation)
7. [Real-World Scenarios](#real-world-scenarios)
8. [Best Practices](#best-practices)

---

### 1 What is a Copy Constructor?
 
A _copy constructor_ is a special constructor that creates a new object as a copy of an existing object of the same class.

``` cpp
class ClassName {
public:
    // Copy Constructor
    ClassName(const ClassName& source) {
        // Copy data from source to this object
    }
};
```
**Key Points**  
``` 
‚úì Takes a reference to an object of the same class
‚úì Reference MUST be const (to prevent modification of source)
‚úì Reference is necessary (pass by value would cause infinite recursion)
‚úì If not defined, the compiler generates a default one
```

### When is the copy constructor called?


``` cpp
#include <iostream>
using namespace std;

class Demo {
public:
    Demo() { 
        cout << "Default Constructor" << endl; 
    }
    
    Demo(const Demo& src) { 
        cout << "Copy Constructor" << endl; 
    }
};

// Function that takes an object by value
void func1(Demo d) {
    cout << "Inside func1" << endl;
}

// Function that returns an object by value
Demo func2() {
    Demo d;
    return d;
}

int main() {
    cout << "=== Case 1: Direct Initialization ===" << endl;
    Demo d1;           // Default Constructor
    Demo d2 = d1;      // Copy Constructor
    
    cout << "\n=== Case 2: Explicit Copy ===" << endl;
    Demo d3(d1);       // Copy Constructor
    
    cout << "\n=== Case 3: Pass by Value ===" << endl;
    func1(d1);         // Copy Constructor (parameter)
    
    cout << "\n=== Case 4: Return by Value ===" << endl;
    Demo d4 = func2(); // May call Copy Constructor (or RVO)
    
    return 0;
}
```
**Output:**  
```
=== Case 1: Direct Initialization ===
Default Constructor
Copy Constructor

=== Case 2: Explicit Copy ===
Copy Constructor

=== Case 3: Pass by Value ===
Copy Constructor
Inside func1

=== Case 4: Return by Value ===
Default Constructor

```
>**Note:** Case 4 may not show copy due to Return Value Optimization (RVO).

---

### 3. Shallow Copy

### What is Shallow Copy?

Shallow copy copies all member values as-is. For pointers, only the address is copied, not the actual data pointed to. Both objects end up pointing to the same memory location.

Default Copy Constructor = Shallow Copy

``` cpp
#include <iostream>
using namespace std;

class Shallow {
    int* data;

public:
    // Constructor
    Shallow(int value) {
        data = new int(value);  // Allocate memory
        cout << "Constructor: Allocated memory at " << data << endl;
    }

    // Compiler-generated copy constructor does this (SHALLOW):
    // Shallow(const Shallow& src) : data(src.data) { }
    // Just copies the pointer address!

    // Destructor
    ~Shallow() {
        cout << "Destructor: Deleting memory at " << data << endl;
        delete data;
    }

    void setValue(int value) { 
        *data = value; 
    }
    
    int getValue() const { 
        return *data; 
    }
    
    void showAddress() const {
        cout << "Data pointer address: " << data << endl;
    }
};

int main() {
    Shallow obj1(100);
    obj1.showAddress();
    
    cout << "\n--- Creating obj2 as copy of obj1 ---\n" << endl;
    
    Shallow obj2 = obj1;  // Shallow copy (default)
    obj2.showAddress();
    
    cout << "\nobj1 value: " << obj1.getValue() << endl;
    cout << "obj2 value: " << obj2.getValue() << endl;
    
    cout << "\n--- Modifying obj2 ---\n" << endl;
    obj2.setValue(999);
    
    // PROBLEM: obj1 is also changed!
    cout << "obj1 value: " << obj1.getValue() << endl;
    cout << "obj2 value: " << obj2.getValue() << endl;
    
    cout << "\n--- Destructors will be called ---\n" << endl;
    
    return 0;
    // CRASH! Double delete - same memory deleted twice
}
```
**Output (with crash):**  

``` 
Constructor: Allocated memory at 0x5555555592a0
Data pointer address: 0x5555555592a0

--- Creating obj2 as copy of obj1 ---

Data pointer address: 0x5555555592a0    ‚Üê SAME ADDRESS!

obj1 value: 100
obj2 value: 100

--- Modifying obj2 ---

obj1 value: 999    ‚Üê obj1 ALSO CHANGED!
obj2 value: 999

--- Destructors will be called ---

Destructor: Deleting memory at 0x5555555592a0
Destructor: Deleting memory at 0x5555555592a0    ‚Üê DOUBLE DELETE!
*** Error: double free detected ***

```
**Problems with Shallow Copy:**

``` 
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                 SHALLOW COPY PROBLEMS                   ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ 1. Dangling Pointer                                     ‚îÇ
‚îÇ    - When one object deletes memory, other has invalid  ‚îÇ
‚îÇ      pointer                                            ‚îÇ
‚îÇ                                                         ‚îÇ
‚îÇ 2. Double Free / Memory Corruption                      ‚îÇ
‚îÇ    - Same memory deleted twice causing crash            ‚îÇ
‚îÇ                                                         ‚îÇ
‚îÇ 3. Unintended Side Effects                              ‚îÇ
‚îÇ    - Modifying one object affects the other             ‚îÇ
‚îÇ                                                         ‚îÇ
‚îÇ 4. Memory Leak (in some cases)                          ‚îÇ
‚îÇ    - Original memory may be lost if reassigned          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

### Deep Copy

**What is Deep Copy?**  

Deep copy creates a completely independent copy. For pointers, it allocates new memory and copies the actual data. Each object has its own separate memory.

Implementing Deep Copy

``` cpp
#include <iostream>
#include <cstring>
using namespace std;

class Deep {
    int* data;

public:
    // Constructor
    Deep(int value) {
        data = new int(value);
        cout << "Constructor: Allocated memory at " << data << endl;
    }

    // Deep Copy Constructor
    Deep(const Deep& src) {
        // Allocate NEW memory
        data = new int(*src.data);  // Copy the VALUE, not the address
        cout << "Copy Constructor: Allocated NEW memory at " << data << endl;
    }

    // Destructor
    ~Deep() {
        cout << "Destructor: Deleting memory at " << data << endl;
        delete data;
    }

    void setValue(int value) { 
        *data = value; 
    }
    
    int getValue() const { 
        return *data; 
    }
    
    void showAddress() const {
        cout << "Data pointer address: " << data << endl;
    }
};

int main() {
    Deep obj1(100);
    obj1.showAddress();
    
    cout << "\n--- Creating obj2 as copy of obj1 ---\n" << endl;
    
    Deep obj2 = obj1;  // Deep copy
    obj2.showAddress();
    
    cout << "\nobj1 value: " << obj1.getValue() << endl;
    cout << "obj2 value: " << obj2.getValue() << endl;
    
    cout << "\n--- Modifying obj2 ---\n" << endl;
    obj2.setValue(999);
    
    // obj1 is NOT affected!
    cout << "obj1 value: " << obj1.getValue() << endl;
    cout << "obj2 value: " << obj2.getValue() << endl;
    
    cout << "\n--- Destructors will be called ---\n" << endl;
    
    return 0;
    // No crash! Each object deletes its own memory
}
```

**Output (no crash):**
```
Constructor: Allocated memory at 0x5555555592a0
Data pointer address: 0x5555555592a0

--- Creating obj2 as copy of obj1 ---

Copy Constructor: Allocated NEW memory at 0x5555555592c0    ‚Üê DIFFERENT ADDRESS!
Data pointer address: 0x5555555592c0

obj1 value: 100
obj2 value: 100

--- Modifying obj2 ---

obj1 value: 100    ‚Üê obj1 UNCHANGED!
obj2 value: 999

--- Destructors will be called ---

Destructor: Deleting memory at 0x5555555592c0
Destructor: Deleting memory at 0x5555555592a0    ‚Üê Different memory, safe!

```


---

### Complete Comparison Example
String Class with Both Approaches

``` cpp
#include <iostream>
#include <cstring>
using namespace std;

// ============================================
// SHALLOW COPY VERSION (DANGEROUS)
// ============================================
class ShallowString {
    char* str;
    size_t length;

public:
    // Constructor
    ShallowString(const char* s = "") {
        length = strlen(s);
        str = new char[length + 1];
        strcpy(str, s);
        cout << "[Shallow] Created: \"" << str << "\" at " << (void*)str << endl;
    }

    // Default copy constructor (shallow) - COMPILER GENERATED
    // ShallowString(const ShallowString& src) 
    //     : str(src.str), length(src.length) { }

    // Destructor
    ~ShallowString() {
        cout << "[Shallow] Deleting: \"" << str << "\" at " << (void*)str << endl;
        delete[] str;
    }

    void print() const {
        cout << "String: \"" << str << "\" (length: " << length << ")" << endl;
    }

    void setChar(size_t index, char c) {
        if (index < length) str[index] = c;
    }
};

// ============================================
// DEEP COPY VERSION (SAFE)
// ============================================
class DeepString {
    char* str;
    size_t length;

public:
    // Constructor
    DeepString(const char* s = "") {
        length = strlen(s);
        str = new char[length + 1];
        strcpy(str, s);
        cout << "[Deep] Created: \"" << str << "\" at " << (void*)str << endl;
    }

    // Deep Copy Constructor
    DeepString(const DeepString& src) {
        length = src.length;
        str = new char[length + 1];     // Allocate NEW memory
        strcpy(str, src.str);           // Copy the CONTENT
        cout << "[Deep] Copied: \"" << str << "\" to NEW address " << (void*)str << endl;
    }

    // Copy Assignment Operator (also needed for complete deep copy)
    DeepString& operator=(const DeepString& src) {
        cout << "[Deep] Assignment operator called" << endl;
        
        // Self-assignment check
        if (this == &src) {
            return *this;
        }

        // Delete old memory
        delete[] str;

        // Allocate and copy new data
        length = src.length;
        str = new char[length + 1];
        strcpy(str, src.str);

        return *this;
    }

    // Destructor
    ~DeepString() {
        cout << "[Deep] Deleting: \"" << str << "\" at " << (void*)str << endl;
        delete[] str;
    }

    void print() const {
        cout << "String: \"" << str << "\" (length: " << length << ")" << endl;
    }

    void setChar(size_t index, char c) {
        if (index < length) str[index] = c;
    }
};

// ============================================
// DEMONSTRATION
// ============================================
void demonstrateShallow() {
    cout << "\n========== SHALLOW COPY DEMO ==========" << endl;
    cout << "(This will crash or show undefined behavior)\n" << endl;

    {
        ShallowString s1("Hello");
        s1.print();

        cout << "\n--- Creating s2 as copy of s1 ---" << endl;
        ShallowString s2 = s1;
        s2.print();

        cout << "\n--- Modifying s2 ---" << endl;
        s2.setChar(0, 'J');  // Change 'H' to 'J'

        cout << "After modification:" << endl;
        s1.print();  // s1 is ALSO modified!
        s2.print();

        cout << "\n--- Scope ending, destructors called ---" << endl;
    }
    // CRASH HERE: Double delete!
}

void demonstrateDeep() {
    cout << "\n========== DEEP COPY DEMO ==========" << endl;
    cout << "(This works correctly)\n" << endl;

    {
        DeepString s1("Hello");
        s1.print();

        cout << "\n--- Creating s2 as copy of s1 ---" << endl;
        DeepString s2 = s1;
        s2.print();

        cout << "\n--- Modifying s2 ---" << endl;
        s2.setChar(0, 'J');  // Change 'H' to 'J'

        cout << "After modification:" << endl;
        s1.print();  // s1 is NOT modified
        s2.print();  // Only s2 is modified

        cout << "\n--- Testing assignment operator ---" << endl;
        DeepString s3("World");
        s3 = s1;  // Assignment (not construction)
        s3.print();

        cout << "\n--- Scope ending, destructors called ---" << endl;
    }
    // No crash! Each object has its own memory
}

int main() {
    // Comment out demonstrateShallow() to avoid crash
    // demonstrateShallow();
    
    demonstrateDeep();
    
    return 0;
}
```

**Output for Deep Copy Demo:**  
```
========== DEEP COPY DEMO ==========
(This works correctly)

[Deep] Created: "Hello" at 0x5555555592a0
String: "Hello" (length: 5)

--- Creating s2 as copy of s1 ---
[Deep] Copied: "Hello" to NEW address 0x5555555592c0
String: "Hello" (length: 5)

--- Modifying s2 ---
After modification:
String: "Hello" (length: 5)
String: "Jello" (length: 5)

--- Testing assignment operator ---
[Deep] Created: "World" at 0x5555555592e0
[Deep] Assignment operator called
String: "Hello" (length: 5)

--- Scope ending, destructors called ---
[Deep] Deleting: "Hello" at 0x555555559300
[Deep] Deleting: "Jello" at 0x5555555592c0
[Deep] Deleting: "Hello" at 0x5555555592a0
```



---

## Visual Representation

**Shallow Copy Memory Layout:**  

```
BEFORE COPY:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ      obj1       ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§          ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  data: 0x1000  ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ  Value: 100 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò          ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                  0x1000

AFTER SHALLOW COPY (obj2 = obj1):
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ      obj1       ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§          ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  data: 0x1000  ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ  Value: 100 ‚îÇ  ‚Üê SHARED!
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò          ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                              ‚ñ≤   0x1000
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê           ‚îÇ
‚îÇ      obj2       ‚îÇ           ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§           ‚îÇ
‚îÇ  data: 0x1000  ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

PROBLEM: Both point to the same memory!
- Modify one ‚Üí affects other
- Delete one ‚Üí other has dangling pointer
- Delete both ‚Üí CRASH (double free)

```
**Deep Copy Memory Layout:**

``` 
BEFORE COPY:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ      obj1       ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§          ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  data: 0x1000  ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ  Value: 100 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò          ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                  0x1000

AFTER DEEP COPY (obj2 = obj1):
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ      obj1       ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§          ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  data: 0x1000  ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ  Value: 100 ‚îÇ  ‚Üê obj1's memory
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò          ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                  0x1000

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ      obj2       ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§          ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  data: 0x2000  ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ  Value: 100 ‚îÇ  ‚Üê obj2's OWN memory
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò          ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                  0x2000

CORRECT: Each has independent memory!
- Modify one ‚Üí other unaffected
- Delete one ‚Üí other still valid
- Delete both ‚Üí Safe (different addresses)

```

---
## Advance Concept:

### Table of Contents

1. [Constructor Categories & Semantics](#1-constructor-categories--semantics)
2. [Rule of Zero/Three/Five](#2-rule-of-zerothreefive)

---

### 1. Constructor Categories & Semantics

**Compiler-Generated Constructors:**  
```
class Widget {
    // Compiler may generate these "special member functions":
    // 1. Default constructor          - Widget()
    // 2. Copy constructor              - Widget(const Widget&)
    // 3. Move constructor              - Widget(Widget&&)
    // 4. Copy assignment operator      - Widget& operator=(const Widget&)
    // 5. Move assignment operator      - Widget& operator=(Widget&&)
    // 6. Destructor                    - ~Widget()
};
```
**Enhanced Version with Visual Indicators**  

| If you declare...     | Default<br>Ctor | Copy<br>Ctor | Move<br>Ctor | Copy<br>Assign | Move<br>Assign | Destructor |
|----------------------|:---------------:|:------------:|:------------:|:--------------:|:--------------:|:----------:|
| **Nothing**          | ‚úÖ              | ‚úÖ           | ‚úÖ           | ‚úÖ             | ‚úÖ             | ‚úÖ         |
| **Any constructor**  | ‚ùå              | ‚úÖ           | ‚úÖ           | ‚úÖ             | ‚úÖ             | ‚úÖ         |
| **Default Ctor**     | üë§              | ‚úÖ           | ‚úÖ           | ‚úÖ             | ‚úÖ             | ‚úÖ         |
| **Copy Ctor**        | ‚ùå              | üë§           | ‚ùå           | ‚ö†Ô∏è             | ‚ùå             | ‚úÖ         |
| **Move Ctor**        | ‚ùå              | ‚ùå           | üë§           | ‚ùå             | ‚ùå             | ‚úÖ         |
| **Copy Assign**      | ‚úÖ              | ‚ö†Ô∏è           | ‚ùå           | üë§             | ‚ùå             | ‚úÖ         |
| **Move Assign**      | ‚úÖ              | ‚úÖ           | ‚ùå           | ‚úÖ             | üë§             | ‚úÖ         |
| **Destructor**       | ‚úÖ              | ‚ö†Ô∏è           | ‚ùå           | ‚ö†Ô∏è             | ‚ùå             | üë§         |

**Legend**
- ‚úÖ = Auto-generated
- ‚ùå = Not generated
- üë§ = User-defined
- ‚ö†Ô∏è = Auto-generated but **deprecated** (avoid relying on this!)

---

### 2. Rule of Zero/Three/Five

**Rule of Zero (Preferred):**  

``` 
// Best practice: Let the compiler handle everything
// Use RAII wrappers for resources

class ModernClass {
    std::string name;                    // Handles its own memory
    std::vector<int> data;               // Handles its own memory
    std::unique_ptr<Resource> resource;  // Handles its own lifetime
    
    // NO destructor, copy/move operations needed!
    // Compiler generates correct ones automatically
};
```

**Rule of Three (Pre-C++11):**
``` cpp
// If you define one, define all three
class LegacyResource {
    char* data;
    size_t size;

public:
    // Constructor
    explicit LegacyResource(size_t sz) 
        : data(new char[sz]), size(sz) {}

    // 1. Destructor
    ~LegacyResource() {
        delete[] data;
    }

    // 2. Copy Constructor
    LegacyResource(const LegacyResource& other)
        : data(new char[other.size]), size(other.size) {
        std::memcpy(data, other.data, size);
    }

    // 3. Copy Assignment
    LegacyResource& operator=(const LegacyResource& other) {
        if (this != &other) {
            delete[] data;
            size = other.size;
            data = new char[size];
            std::memcpy(data, other.data, size);
        }
        return *this;
    }
};
```

**Rule of Five (C++11+):**  

``` cpp
class Resource {
    char* data;
    size_t size;

public:
    // Constructor
    explicit Resource(size_t sz) 
        : data(sz ? new char[sz] : nullptr), size(sz) {}

    // 1. Destructor
    ~Resource() {
        delete[] data;
    }

    // 2. Copy Constructor
    Resource(const Resource& other)
        : data(other.size ? new char[other.size] : nullptr)
        , size(other.size) {
        if (data) std::memcpy(data, other.data, size);
    }

    // 3. Move Constructor
    Resource(Resource&& other) noexcept
        : data(std::exchange(other.data, nullptr))
        , size(std::exchange(other.size, 0)) {}

    // 4. Copy Assignment (Copy-and-Swap Idiom)
    Resource& operator=(const Resource& other) {
        Resource temp(other);
        swap(temp);
        return *this;
    }

    // 5. Move Assignment
    Resource& operator=(Resource&& other) noexcept {
        if (this != &other) {
            delete[] data;
            data = std::exchange(other.data, nullptr);
            size = std::exchange(other.size, 0);
        }
        return *this;
    }

    // Helper for copy-and-swap
    void swap(Resource& other) noexcept {
        using std::swap;
        swap(data, other.data);
        swap(size, other.size);
    }
};
```

**Unified Assignment Operator (Advanced):**

``` cpp
class UnifiedResource {
    char* data;
    size_t size;

public:
    // ... constructors and destructor ...

    // Single assignment handles both copy AND move
    UnifiedResource& operator=(UnifiedResource other) noexcept {
        swap(other);  // other will be destroyed with old data
        return *this;
    }

    void swap(UnifiedResource& other) noexcept {
        using std::swap;
        swap(data, other.data);
        swap(size, other.size);
    }
};
```


