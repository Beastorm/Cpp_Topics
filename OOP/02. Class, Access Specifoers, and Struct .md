## Classes and Objects in C++

### 1. Concept

In C++, a **class** is a user-defined data type. It binds data and functions together.

- **Class**: The blueprint or template (e.g., a "Car Blueprint").
- **Object**: The instance created from that blueprint (e.g., a specific "Red Toyota").

### 2. Syntax
A class is defined using the `class` keyword.  
**Note:** You must end the class definition with a semicolon (`;`).

``` cpp
class ClassName {
    // Access Specifier
    public:
        // Data Members (Variables)
        int variable;
        
        // Member Functions (Methods)
        void function() {
            // Logic
        }
}; // <--- Semicolon is mandatory here

```

### 3. Example

Here is a complete, runnable example using a `Student` class.
``` cpp
#include <iostream>
#include <string>
using namespace std;

// 1. Class Definition
class Student {
public: // Access specifier
    // Attributes (Data)
    string name;
    int rollNumber;

    // Method (Function)
    void introduce() {
        cout << "Hi, I am " << name << " and my ID is " << rollNumber << endl;
    }
};

int main() {
    // 2. Object Creation
    Student s1; // Creating an object named 's1'

    // 3. Accessing attributes using the dot (.) operator
    s1.name = "Alice";
    s1.rollNumber = 101;

    // 4. Accessing methods
    s1.introduce();

    // Creating another object
    Student s2;
    s2.name = "Bob";
    s2.rollNumber = 102;
    s2.introduce();

    return 0;
}
```

**Output:**  
```
Hi, I am Alice and my ID is 101
Hi, I am Bob and my ID is 102
```

### 4. Advanced Example: Constructors and Encapsulation

In professional C++, we rarely leave data public. We usually make data `private` and use a **constructor** to initialize it.

- **private**: Data cannot be modified directly from `main()`.
- **Constructor**: A special function that runs automatically when an object is created.

``` cpp
#include <iostream>
#include <string>
using namespace std;

class Car {
private: 
    // Data is hidden (Encapsulation)
    string brand;
    int year;

public:
    // Constructor (Same name as class, no return type)
    Car(string b, int y) {
        brand = b;
        year = y;
    }

    // Method to display data
    void displayInfo() {
        cout << year << " " << brand << endl;
    }
};

int main() {
    // Initialize objects immediately using the Constructor
    Car car1("Toyota", 2022);
    Car car2("Tesla", 2024);

    car1.displayInfo();
    car2.displayInfo();

    return 0;
}
```


### 5. Key Terminology Summary:

| Term | Definition |
| :--- | :--- |
| **Class** | The template/blueprint defining the structure. |
| **Object** | The actual variable created from the class. |
| **Member** | Variables and functions inside the class. |


---

## Access Specifiers
Access Specifiers in C++ define the scope and visibility of class members (variables and functions). They tell the compiler who is allowed to use specific data.

There are three types of access specifiers:

*   `public` (Open to everyone)
*   `private` (Open only to the class itself)
*   `protected` (Open to the class and its children)

### The Real-World Analogy
**Think of a House:**

*   **Public:** The Front Porch. Anyone walking by (the outside world) can see it and stand on it.
*   **Private:** Your Personal Diary. Only you (the class) can read it. Not even your children can read it.
*   **Protected:** The Family TV. You can use it, and your children (derived classes) can use it, but strangers outside cannot come in and watch it.

#### Comprehensive Example
Here is a single piece of code that demonstrates all three specifiers in action, including where they fail.
| **Method** | A function defined inside a class. |
| `public` | Members are accessible from outside the class. |
| `private` | Members are only accessible inside the class. |
| **Constructor** | A method that runs automatically when an object is created to initialize it. |


``` cpp 
#include <iostream>
using namespace std;

class Base {
public:
    int x; // Public: Everyone can access

protected:
    int y; // Protected: Only Derived classes can access

private:
    int z; // Private: Only THIS class can access
    
public:
    // Constructor to initialize values
    Base() {
        x = 10;
        y = 20;
        z = 30;
    }
    
    // A function INSIDE Base can access everything (x, y, and z)
    void showData() {
        cout << "Inside Base: " << x << ", " << y << ", " << z << endl; 
    }
};

// Derived Class (Inheritance)
class Derived : public Base {
public:
    void accessBaseMembers() {
        cout << "Inside Derived Class:" << endl;
        cout << "x is " << x << endl; // OK: x is Public
        cout << "y is " << y << endl; // OK: y is Protected (Inherited)
        
        // cout << "z is " << z << endl; // ERROR: z is Private in Base!
    }
};

int main() {
    Base b;
    Derived d;

    // 1. Accessing Public
    cout << "Inside Main (Public): " << b.x << endl; // OK
    
    // 2. Accessing Protected
    // cout << "Inside Main: " << b.y << endl; // ERROR: Cannot access Protected from main
    d.accessBaseMembers(); // We must ask the Derived class to show us 'y'
    
    // 3. Accessing Private
    // cout << "Inside Main: " << b.z << endl; // ERROR: Cannot access Private from main
    b.showData(); // We must ask the Base class function to show us 'z'

    return 0;
}
```

### Detailed Breakdown

#### 1. Public
*   **Access:** Anywhere in the program (`main()`, other functions, derived classes).
*   **Use case:** Functions meant for the user to interact with (e.g., `printInfo()`, `login()`).

``` cpp
class Sample {
public:
    int num;
};

int main() {
    Sample obj;
    obj.num = 5; // Valid
}
```

#### 2. Private (Default)
*   **Access:** Only inside the class where it is defined.
*   **Note:** If you do not specify an access specifier in a class, it is `private` by default.
*   **Use case:** Storing sensitive data like passwords or internal logic variables. You usually use **Getters** and **Setters** (Public functions) to modify these indirectly.

``` cpp
class Sample {
private:
    int secret;

public:
    void setSecret(int s) {
        secret = s; // Valid: accessed from inside
    }
};

int main() {
    Sample obj;
    // obj.secret = 10; // INVALID: Compilation Error
    obj.setSecret(10); // Valid
}

```

### 3. Protected
*   **Access:** Inside the class AND inside Derived (Child) classes.
*   **Restriction:** It acts like `private` when trying to access it from `main()`.
*   **Use case:** When using Inheritance, and you want the Child class to be able to modify the Parent's variables directly.


The `protected` access specifier is the bridge between **Encapsulation** (hiding data) and **Inheritance** (sharing data).

It is specifically designed for class hierarchies. Without inheritance, `protected` behaves exactly like `private`.


### Real-World Analogy: The Family Recipe
Imagine a Grandfather has a secret cookie recipe.

*   **Public:** He writes it on a billboard. Everyone on the street can read it.
*   **Private:** He keeps it in his brain. Even his son doesn't know it.
*   **Protected:** He tells his Son (Derived class). The Son can use the recipe to bake cookies. However, the Customer (`Main` function) cannot just walk in and demand the recipe written on paper; they can only eat the cookies.

### Detailed Example
Let's look at how a **Child class** interacts with a **Protected member** of the **Parent**.

``` cpp
#include <iostream>
using namespace std;

class BankAccount {
protected: 
    // This variable is hidden from the world, 
    // but available to specific types of accounts (children)
    double balance;

public:
    void setBalance(double b) {
        balance = b;
    }
};

// SavingsAccount IS-A BankAccount
class SavingsAccount : public BankAccount {
public:
    void addInterest() {
        // DIRECT ACCESS: 
        // We can access 'balance' because it is protected in the parent
        // and we are the child.
        double interest = balance * 0.05;
        balance = balance + interest;
        
        cout << "Interest added. New Balance: " << balance << endl;
    }
};

int main() {
    SavingsAccount myAcc;
    
    // 1. Accessing Public method (Allowed)
    myAcc.setBalance(1000); 
    
    // 2. Accessing the Child method, which uses protected data (Allowed)
    myAcc.addInterest(); 
    
    // 3. Direct Access from main (NOT Allowed)
    // myAcc.balance = 5000; // ERROR: 'balance' is protected within this context
    
    return 0;
}
```

### Rules for `protected` Access Specifier
Here are the technical rules you must remember:

#### 1. The "Family Only" Rule
If **Class B** inherits from **Class A**, then **B** can directly use **A**'s `protected` members.
However, an object of **A** created in `main()` cannot access its own `protected` members directly.

#### 2. The Rule of Objects
A derived class can only access `protected` members of the base class on objects of the *derived* class.

*   **Example:** Inside the `Dog` class (derived from `Animal`), you can change `this->age` (`protected` in `Animal`). But if you create a generic `Animal a` inside the `Dog` class, you usually cannot access `a.age`.

#### 3. Friend Function Exception
A `friend` function or `friend` class can access `protected` (and `private`) members, just like they are `public`.

#### 4. Inheritance Mode Rules (Crucial)
How `protected` data behaves in the child depends on **how** the child inherits from the parent.

| Inheritance Mode | How `protected` data appears in the Child Class |
| :--- | :--- |
| `class Child : public Parent` | It remains **Protected** in Child. (Most common) |
| `class Child : protected Parent` | It remains **Protected** in Child. |
| `class Child : private Parent` | It becomes **Private** in Child. (The chain breaks here; Grandchildren cannot see it). |


### Why use `protected` instead of `public`?
*   If you make a variable `public`, anyone can change it to an invalid value (e.g., setting speed to `-500`).
*   If you make it `protected`, you ensure that random users in `main()` can't break your object, but you still allow developers creating extensions (**Derived classes**) to modify the logic.

### Why use `protected` instead of `private`?
*   If you make a variable `private`, the **Derived class** has to use "Getter" and "Setter" functions to access it. This adds overhead and extra code.
*   `protected` gives the **Child** direct, fast access to the **Parent's** data.

### Summary Checklist
*   **Can `main()` access it?** ❌ No.
*   **Can the Class itself access it?** ✅ Yes.
*   **Can a Child Class access it?** ✅ Yes.
*   **Can a Grandchild Class access it?** ✅ Yes (assuming `public`/`protected` inheritance).


---

A **Struct** (short for Structure) in C++ is a user-defined data type that allows you to group variables of different types under a single name.

Think of it like a physical form or record. A "Medical Record" is one folder, but inside it holds a `string` (Patient Name), an `integer` (Age), and a `double` (Weight).

### Basic Syntax

struct StructureName {
    // Member variables
    type member1;
    type member2;
}; // <--- Ends with a semicolon

### Example 1: The Basic "Data Container."
This is the most common use of structs: holding a group of related data.

``` cpp
#include <iostream>
#include <string>
using namespace std;

// Define the structure
struct Student {
    string name;
    int age;
    float gpa;
};

int main() {
    // Create an instance (variable) of the struct
    Student s1;

    // Access members using the dot (.) operator
    // Note: By default, everything in a struct is PUBLIC
    s1.name = "John Doe";
    s1.age = 20;
    s1.gpa = 3.8;

    cout << "Name: " << s1.name << endl;
    cout << "Age: " << s1.age << endl;
    cout << "GPA: " << s1.gpa << endl;

    // Alternative: Brace Initialization (Easier syntax)
    Student s2 = {"Jane Smith", 22, 3.9};
    cout << "\nName: " << s2.name << endl;

    return 0;
}
```

### The Big Question: Struct vs. Class
In C++, `struct` and `class` are almost identical.

The **ONLY** technical difference is the **Default Access Specifier**:

| Feature | Struct | Class |
| :--- | :--- | :--- |
| Default Access | **Public** | **Private** |
| Inheritance Default | **Public** | **Private** |

#### Proof of Difference:
1. Using a Class:

``` cpp
class MyClass {
    int x; // Defaults to PRIVATE
};

int main() {
    MyClass obj;
    // obj.x = 10; // ERROR: Cannot access private member
}
```

2. Using a Struct:

``` cpp
struct MyStruct {
    int x; // Defaults to PUBLIC
};

int main() {
    MyStruct obj;
    obj.x = 10; // WORK: Accessible!
}
```
### Example 2: Structs with Functions (Advanced)
Many people think structs can only hold data (like in the C language). In C++, structs can have **Constructors** and **Functions**, just like classes.

``` cpp
#include <iostream>
using namespace std;

struct Point {
    int x;
    int y;

    // Constructor inside a struct
    Point(int xVal, int yVal) {
        x = xVal;
        y = yVal;
    }

    // Function inside a struct
    void display() {
        cout << "Point coordinates: (" << x << ", " << y << ")" << endl;
    }
};

int main() {
    // Using the constructor
    Point p1(10, 20);
    
    p1.display();

    return 0;
}
```

### When should you use Struct vs Class?
While they can do the same things, C++ programmers follow a **Convention** (Style Guide):

*   **Use `struct` for "Plain Old Data" (POD).**
    If you just want to bundle some variables together (like a Coordinate `x,y` or a Color `r,g,b`) and don't need complex logic or privacy, use a `struct`. It tells other programmers: *"This object is simple and open."*

*   **Use `class` for Objects with Logic.**
    If you need encapsulation (`private` variables), getters/setters, or complex inheritance hierarchies, use a `class`.


---

## Struct vs Class

In C++, the difference between `class` and `struct` is surprisingly small. It is mostly a matter of default settings and programming conventions.

Here is the breakdown of the differences.

### 1. The Technical Difference (The Interview Answer)
There are only two technical differences in how the compiler treats them.

#### A. Default Access Specifier
*   `class`: Members are `private` by default.
*   `struct`: Members are `public` by default.

**Example:**

``` cpp
#include <iostream>
using namespace std;

class MyClass {
    int x; // No specifier? It is PRIVATE.
};

struct MyStruct {
    int x; // No specifier? It is PUBLIC.
};

int main() {
    MyClass c;
    // c.x = 10; // ERROR: 'x' is private
    
    MyStruct s;
    s.x = 10;    // OK: 'x' is public
    
    return 0;
}
```

#### B. Default Inheritance Mode
When inheriting from another class/struct:

*   `class`: Inherits **private**ly by default.
*   `struct`: Inherits **public**ly by default.

**Example:**

``` cpp
class Base { public: int x; };

// Case 1: Class Inheritance
class DerivedClass : Base { 
    // Inherits as PRIVATE by default.
    // 'x' is now private inside DerivedClass.
}; 

// Case 2: Struct Inheritance
struct DerivedStruct : Base {
    // Inherits as PUBLIC by default.
    // 'x' remains public inside DerivedStruct.
};

int main() {
    DerivedClass d1;
    // d1.x = 10; // ERROR: x is private
    
    DerivedStruct d2;
    d2.x = 10; // OK: x is public
}
```

### 2. The Conceptual Difference (When to use which?)
Since you can technically use them interchangeably (by adding `public:` to a `class` or `private:` to a `struct`), the choice comes down to **Convention** (coding style).

#### Use `struct` for: "Plain Old Data" (POD)
Use a `struct` when you just want to group variables together like a container, and you don't have complex logic or security needs.

*   Coordinates (x, y)
*   Database records (Name, ID, Salary)
*   Settings/Configuration options

#### Use `class` for: "Active Objects" (OOP)
Use a `class` when you are building a fully functional object that controls its own state.

*   **Encapsulation is needed** (Private data).
*   **Invariant checking is needed** (e.g., a `Date` class that ensures "Month" is never 13).
*   Complex inheritance hierarchies.

### Summary Table

| Feature | `class` | `struct` |
| :--- | :--- | :--- |
| Default Member Access | **Private** | **Public** |
| Default Inheritance | **Private** | **Public** |
| Can have Functions? | Yes | Yes |
| Can have Constructors? | Yes | Yes |
| Common Usage | Complex Objects with logic | Simple Data Containers |
| Origin | Created for C++ (OOP) | Inherited from C language |

### Key Takeaway
*   If you see `struct` in C++ code, expect to see public data variables (`obj.data`).
*   If you see `class` in C++ code, expect to see private data accessed via functions (`obj.getData()`).
