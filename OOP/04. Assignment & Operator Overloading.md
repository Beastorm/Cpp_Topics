## Assignment & Operator Overloading in C++
A comprehensive guide covering assignment operators and all aspects of operator overloading.

### Table of Contents
* Introduction to Operator Overloading
* Copy Assignment Operator
* Move Assignment Operator
* Arithmetic Operators
* Comparison Operators
* Increment & Decrement Operators
* Subscript Operator
* Function Call Operator
* Stream Operators
* Conversion Operators
* Smart Pointer Operators
* Rules & Best Practices

### 1. Introduction to Operator Overloading
Operator overloading allows you to define custom behavior for operators when applied to user-defined types.

**Basic Concept**
``` cpp
#include <iostream>
using namespace std;

class Point {
    int x, y;

public:
    Point(int x = 0, int y = 0) : x(x), y(y) {}

    // Operator overloading: Define what + means for Point
    Point operator+(const Point& other) const {
        return Point(x + other.x, y + other.y);
    }

    void print() const {
        cout << "(" << x << ", " << y << ")" << endl;
    }
};

int main() {
    Point p1(3, 4);
    Point p2(1, 2);
    
    Point p3 = p1 + p2;  // Uses overloaded operator+
    
    p1.print();  // (3, 4)
    p2.print();  // (1, 2)
    p3.print();  // (4, 6)
    
    return 0;
}
```
**Operators That Can/Cannot Be Overloaded**

``` 
┌─────────────────────────────────────────────────────────────────┐
│                 OPERATOR OVERLOADING RULES                      │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  CAN BE OVERLOADED:                                             │
│  ─────────────────                                              │
│  Arithmetic:    +  -  *  /  %                                   │
│  Comparison:    == != <  >  <= >=  <=> (C++20)                  │
│  Logical:       && || !                                         │
│  Bitwise:       &  |  ^  ~  << >>                               │
│  Assignment:    =  += -= *= /= %= &= |= ^= <<= >>=              │
│  Inc/Dec:       ++ --                                           │
│  Member Access: -> ->*                                          │
│  Subscript:     []                                              │
│  Function Call: ()                                              │
│  Comma:         ,                                               │
│  Memory:        new delete new[] delete[]                       │
│  Dereference:   *                                               │
│  Address-of:    &                                               │
│                                                                 │
│  CANNOT BE OVERLOADED:                                          │
│  ────────────────────                                           │
│  ::    (Scope resolution)                                       │
│  .     (Member access)                                          │
│  .*    (Pointer-to-member access)                               │
│  ?:    (Ternary conditional)                                    │
│  sizeof                                                         │
│  typeid                                                         │
│  alignof                                                        │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘

```
**Member vs Non-Member Overloading**
``` cpp
#include <iostream>
using namespace std;

class Number {
    int value;

public:
    Number(int v = 0) : value(v) {}

    // MEMBER function overload
    // Called as: obj1.operator+(obj2) → obj1 + obj2
    Number operator+(const Number& other) const {
        return Number(value + other.value);
    }

    // Friend declaration for non-member
    friend Number operator-(const Number& a, const Number& b);
    friend ostream& operator<<(ostream& os, const Number& n);

    int getValue() const { return value; }
};

// NON-MEMBER function overload (friend)
// Called as: operator-(a, b) → a - b
Number operator-(const Number& a, const Number& b) {
    return Number(a.value - b.value);
}

// NON-MEMBER: Required for stream operators
ostream& operator<<(ostream& os, const Number& n) {
    os << n.value;
    return os;
}

int main() {
    Number a(10), b(3);
    
    Number sum = a + b;   // Member: a.operator+(b)
    Number diff = a - b;  // Non-member: operator-(a, b)
    
    cout << "Sum: " << sum << endl;   // 13
    cout << "Diff: " << diff << endl; // 7
    
    return 0;
}
```

**When to Use Member vs Non-Member**

``` 
┌─────────────────────────────────────────────────────────────────┐
│           MEMBER vs NON-MEMBER GUIDELINES                       │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  USE MEMBER FUNCTION:                                           │
│  • Assignment operators: = += -= *= etc.                        │
│  • Subscript operator: []                                       │
│  • Function call operator: ()                                   │
│  • Member access operators: -> ->*                              │
│  • Unary operators that modify: ++ --                           │
│  • When left operand must be class object                       │
│                                                                 │
│  USE NON-MEMBER (friend) FUNCTION:                              │
│  • Stream operators: << >>                                      │
│  • Binary operators for symmetry: + - * / == !=                 │
│  • When left operand is not class type (e.g., int + MyClass)    │
│  • To allow implicit conversion on left operand                 │
│                                                                 │
│  REQUIRED AS MEMBER:                                            │
│  • = (assignment)                                               │
│  • [] (subscript)                                               │
│  • () (function call)                                           │
│  • -> (member access)                                           │
│  • type conversion operators                                    │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 2. Copy Assignment Operator
**Basic Syntax**

``` cpp
class ClassName {
public:
    ClassName& operator=(const ClassName& other);  // Declaration
};
```

**Simple Example**
``` cpp
#include <iostream>
#include <cstring>
using namespace std;

class String {
    char* data;
    size_t length;

public:
    // Constructor
    String(const char* str = "") {
        length = strlen(str);
        data = new char[length + 1];
        strcpy(data, str);
        cout << "Constructor: \"" << data << "\"" << endl;
    }

    // Copy Constructor
    String(const String& other) {
        length = other.length;
        data = new char[length + 1];
        strcpy(data, other.data);
        cout << "Copy Constructor: \"" << data << "\"" << endl;
    }

    // Copy Assignment Operator
    String& operator=(const String& other) {
        cout << "Copy Assignment: \"" << other.data << "\" to \"" << data << "\"" << endl;

        // 1. Self-assignment check
        if (this == &other) {
            return *this;
        }

        // 2. Release old resources
        delete[] data;

        // 3. Allocate new resources
        length = other.length;
        data = new char[length + 1];

        // 4. Copy data
        strcpy(data, other.data);

        // 5. Return *this for chaining
        return *this;
    }

    // Destructor
    ~String() {
        cout << "Destructor: \"" << data << "\"" << endl;
        delete[] data;
    }

    void print() const {
        cout << "String: \"" << data << "\" (length: " << length << ")" << endl;
    }
};

int main() {
    cout << "=== Creating strings ===" << endl;
    String s1("Hello");
    String s2("World");
    String s3("Test");

    cout << "\n=== Copy Assignment ===" << endl;
    s2 = s1;  // Copy assignment
    s2.print();

    cout << "\n=== Chained Assignment ===" << endl;
    s3 = s2 = s1;  // Chained assignment
    s3.print();

    cout << "\n=== Self Assignment ===" << endl;
    s1 = s1;  // Self-assignment (should be handled)
    s1.print();

    cout << "\n=== Cleanup ===" << endl;
    return 0;
}
```
**Output:**

```text

=== Creating strings ===
Constructor: "Hello"
Constructor: "World"
Constructor: "Test"

=== Copy Assignment ===
Copy Assignment: "Hello" to "World"
String: "Hello" (length: 5)

=== Chained Assignment ===
Copy Assignment: "Hello" to "Hello"
Copy Assignment: "Hello" to "Test"
String: "Hello" (length: 5)

=== Self Assignment ===
Copy Assignment: "Hello" to "Hello"
String: "Hello" (length: 5)

=== Cleanup ===
Destructor: "Hello"
Destructor: "Hello"
Destructor: "Hello"
```

**Copy-and-Swap Idiom (Exception Safe)**
``` cpp
#include <iostream>
#include <algorithm>
#include <cstring>
using namespace std;

class SafeString {
    char* data;
    size_t length;

public:
    SafeString(const char* str = "") {
        length = strlen(str);
        data = new char[length + 1];
        strcpy(data, str);
    }

    // Copy Constructor
    SafeString(const SafeString& other)
        : length(other.length)
        , data(new char[other.length + 1]) 
    {
        strcpy(data, other.data);
    }

    // Destructor
    ~SafeString() {
        delete[] data;
    }

    // Swap function (noexcept)
    void swap(SafeString& other) noexcept {
        using std::swap;
        swap(data, other.data);
        swap(length, other.length);
    }

    // Copy Assignment using Copy-and-Swap
    SafeString& operator=(SafeString other) {  // Note: pass by VALUE
        // 'other' is already a copy (copy constructor called)
        swap(other);  // Swap with the copy
        return *this;
        // 'other' (with old data) is destroyed here
    }

    void print() const {
        cout << "\"" << data << "\"" << endl;
    }
};

// Non-member swap (for STL compatibility)
void swap(SafeString& a, SafeString& b) noexcept {
    a.swap(b);
}

int main() {
    SafeString s1("Hello");
    SafeString s2("World");

    cout << "Before: ";
    s1.print();
    s2.print();

    s1 = s2;  // Copy-and-swap

    cout << "After: ";
    s1.print();
    s2.print();

    return 0;
}
```

**Visual: Copy-and-Swap**

```
═══════════════════════════════════════════════════════════════════
                    COPY-AND-SWAP IDIOM
═══════════════════════════════════════════════════════════════════

    s1 = s2;    // Assignment

    STEP 1: Parameter 'other' is COPY constructed from s2
    ┌─────────┐     ┌─────────┐     ┌─────────┐
    │   s1    │     │   s2    │     │  other  │
    │ "Hello" │     │ "World" │ ──► │ "World" │  (copy of s2)
    └─────────┘     └─────────┘     └─────────┘

    STEP 2: Swap s1's data with other's data
    ┌─────────┐     ┌─────────┐     ┌─────────┐
    │   s1    │     │   s2    │     │  other  │
    │ "World" │◄───►│ "World" │     │ "Hello" │
    └─────────┘     └─────────┘     └─────────┘
         │                               │
         └───────── SWAPPED ─────────────┘

    STEP 3: 'other' goes out of scope, destructor called
    ┌─────────┐     ┌─────────┐
    │   s1    │     │   s2    │     other destroyed
    │ "World" │     │ "World" │     (releases "Hello")
    └─────────┘     └─────────┘

    BENEFITS:
    ✓ Exception safe (copy happens first)
    ✓ Self-assignment safe (swap is always valid)
    ✓ Clean, simple code
    ✓ Reuses copy constructor logic

═══════════════════════════════════════════════════════════════════
```

### 3. Move Assignment Operator
**Basic Syntax** 

``` cpp
class ClassName {
public:
    ClassName& operator=(ClassName&& other) noexcept;  // Declaration
};
```

**Complete Example**

``` cpp
#include <iostream>
#include <utility>
#include <cstring>
using namespace std;

class Buffer {
    int* data;
    size_t size;
    string name;

public:
    // Constructor
    Buffer(size_t sz, const string& n) 
        : data(new int[sz]), size(sz), name(n) {
        for (size_t i = 0; i < size; i++) data[i] = 0;
        cout << "[" << name << "] Constructor: allocated " << size << " ints" << endl;
    }

    // Copy Constructor
    Buffer(const Buffer& other)
        : data(new int[other.size])
        , size(other.size)
        , name(other.name + "_copy")
    {
        for (size_t i = 0; i < size; i++) data[i] = other.data[i];
        cout << "[" << name << "] Copy Constructor (EXPENSIVE)" << endl;
    }

    // Move Constructor
    Buffer(Buffer&& other) noexcept
        : data(other.data)
        , size(other.size)
        , name(std::move(other.name))
    {
        other.data = nullptr;
        other.size = 0;
        cout << "[" << name << "] Move Constructor (CHEAP)" << endl;
    }

    // Copy Assignment Operator
    Buffer& operator=(const Buffer& other) {
        cout << "[" << name << "] Copy Assignment from [" << other.name << "]" << endl;

        if (this != &other) {
            // Release old resources
            delete[] data;

            // Allocate and copy
            size = other.size;
            data = new int[size];
            for (size_t i = 0; i < size; i++) data[i] = other.data[i];
            name = other.name + "_assigned";
        }
        return *this;
    }

    // Move Assignment Operator
    Buffer& operator=(Buffer&& other) noexcept {
        cout << "[" << name << "] Move Assignment from [" << other.name << "]" << endl;

        if (this != &other) {
            // Release old resources
            delete[] data;

            // Steal resources
            data = other.data;
            size = other.size;
            name = std::move(other.name);

            // Leave other in valid state
            other.data = nullptr;
            other.size = 0;
        }
        return *this;
    }

    // Destructor
    ~Buffer() {
        cout << "[" << (name.empty() ? "moved-from" : name) << "] Destructor" << endl;
        delete[] data;
    }

    void info() const {
        cout << "Buffer \"" << name << "\": size=" << size 
             << ", data=" << (data ? "valid" : "null") << endl;
    }
};

Buffer createBuffer(size_t size) {
    Buffer temp(size, "Temporary");
    return temp;
}

int main() {
    cout << "=== Creating buffers ===" << endl;
    Buffer b1(100, "Buffer1");
    Buffer b2(200, "Buffer2");

    cout << "\n=== Copy Assignment ===" << endl;
    b1 = b2;  // Copy assignment
    b1.info();
    b2.info();

    cout << "\n=== Move Assignment ===" << endl;
    Buffer b3(50, "Buffer3");
    b3 = std::move(b1);  // Move assignment
    b1.info();  // b1 is now empty
    b3.info();

    cout << "\n=== Move from temporary ===" << endl;
    Buffer b4(10, "Buffer4");
    b4 = createBuffer(500);  // Move assignment from temporary

    cout << "\n=== Cleanup ===" << endl;
    return 0;
}
```
**Output:**

``` text

=== Creating buffers ===
[Buffer1] Constructor: allocated 100 ints
[Buffer2] Constructor: allocated 200 ints

=== Copy Assignment ===
[Buffer1] Copy Assignment from [Buffer2]
Buffer "Buffer2_assigned": size=200, data=valid
Buffer "Buffer2": size=200, data=valid

=== Move Assignment ===
[Buffer3] Constructor: allocated 50 ints
[Buffer2_assigned] Move Assignment from [Buffer3]
Buffer "": size=0, data=null
Buffer "Buffer3": size=50, data=valid

=== Move from temporary ===
[Buffer4] Constructor: allocated 10 ints
[Temporary] Constructor: allocated 500 ints
[Buffer4] Move Assignment from [Temporary]
[moved-from] Destructor

=== Cleanup ===
[Temporary] Destructor
[Buffer3] Destructor
[Buffer2] Destructor
[moved-from] Destructor
```

**Unified Assignment Operator (Handles Both)**

``` cpp
#include <iostream>
#include <utility>
using namespace std;

class Unified {
    int* data;
    size_t size;

public:
    Unified(size_t sz = 0) : data(sz ? new int[sz] : nullptr), size(sz) {
        cout << "Constructor: " << size << endl;
    }

    Unified(const Unified& other) : data(new int[other.size]), size(other.size) {
        for (size_t i = 0; i < size; i++) data[i] = other.data[i];
        cout << "Copy Constructor" << endl;
    }

    Unified(Unified&& other) noexcept : data(other.data), size(other.size) {
        other.data = nullptr;
        other.size = 0;
        cout << "Move Constructor" << endl;
    }

    ~Unified() {
        delete[] data;
    }

    // Single unified assignment operator
    Unified& operator=(Unified other) noexcept {  // By value!
        cout << "Unified Assignment" << endl;
        swap(other);
        return *this;
    }

    void swap(Unified& other) noexcept {
        std::swap(data, other.data);
        std::swap(size, other.size);
    }
};

int main() {
    Unified u1(10);
    Unified u2(20);

    cout << "\n--- Assign from lvalue ---" << endl;
    u1 = u2;  // Copy constructor called for parameter, then swap

    cout << "\n--- Assign from rvalue ---" << endl;
    u1 = Unified(30);  // Move constructor called for parameter, then swap

    return 0;
}
```

**Output:**

``` text

Constructor: 10
Constructor: 20

--- Assign from lvalue ---
Copy Constructor
Unified Assignment

--- Assign from rvalue ---
Constructor: 30
Move Constructor
Unified Assignment
```

### 4. Arithmetic Operators
**Complete Arithmetic Operators Example**

``` cpp
#include <iostream>
using namespace std;

class Complex {
    double real;
    double imag;

public:
    Complex(double r = 0, double i = 0) : real(r), imag(i) {}

    // Getter methods
    double getReal() const { return real; }
    double getImag() const { return imag; }

    // ========== UNARY OPERATORS ==========

    // Unary plus (usually returns copy)
    Complex operator+() const {
        return *this;
    }

    // Unary minus (negation)
    Complex operator-() const {
        return Complex(-real, -imag);
    }

    // ========== BINARY ARITHMETIC OPERATORS ==========

    // Addition
    Complex operator+(const Complex& other) const {
        return Complex(real + other.real, imag + other.imag);
    }

    // Subtraction
    Complex operator-(const Complex& other) const {
        return Complex(real - other.real, imag - other.imag);
    }

    // Multiplication
    Complex operator*(const Complex& other) const {
        // (a+bi)(c+di) = (ac-bd) + (ad+bc)i
        return Complex(
            real * other.real - imag * other.imag,
            real * other.imag + imag * other.real
        );
    }

    // Division
    Complex operator/(const Complex& other) const {
        double denominator = other.real * other.real + other.imag * other.imag;
        return Complex(
            (real * other.real + imag * other.imag) / denominator,
            (imag * other.real - real * other.imag) / denominator
        );
    }

    // ========== COMPOUND ASSIGNMENT OPERATORS ==========

    Complex& operator+=(const Complex& other) {
        real += other.real;
        imag += other.imag;
        return *this;
    }

    Complex& operator-=(const Complex& other) {
        real -= other.real;
        imag -= other.imag;
        return *this;
    }

    Complex& operator*=(const Complex& other) {
        *this = *this * other;  // Reuse operator*
        return *this;
    }

    Complex& operator/=(const Complex& other) {
        *this = *this / other;  // Reuse operator/
        return *this;
    }

    // Friend for output
    friend ostream& operator<<(ostream& os, const Complex& c);
};

// Stream output operator
ostream& operator<<(ostream& os, const Complex& c) {
    os << c.real;
    if (c.imag >= 0) os << "+";
    os << c.imag << "i";
    return os;
}

int main() {
    Complex c1(3, 4);   // 3+4i
    Complex c2(1, 2);   // 1+2i

    cout << "c1 = " << c1 << endl;
    cout << "c2 = " << c2 << endl;

    cout << "\n=== Unary Operators ===" << endl;
    cout << "+c1 = " << +c1 << endl;
    cout << "-c1 = " << -c1 << endl;

    cout << "\n=== Binary Operators ===" << endl;
    cout << "c1 + c2 = " << (c1 + c2) << endl;
    cout << "c1 - c2 = " << (c1 - c2) << endl;
    cout << "c1 * c2 = " << (c1 * c2) << endl;
    cout << "c1 / c2 = " << (c1 / c2) << endl;

    cout << "\n=== Compound Assignment ===" << endl;
    Complex c3 = c1;
    c3 += c2;
    cout << "c3 = c1; c3 += c2: " << c3 << endl;

    c3 = c1;
    c3 *= c2;
    cout << "c3 = c1; c3 *= c2: " << c3 << endl;

    return 0;
}
```

**Output:**

```text

c1 = 3+4i
c2 = 1+2i

=== Unary Operators ===
+c1 = 3+4i
-c1 = -3-4i

=== Binary Operators ===
c1 + c2 = 4+6i
c1 - c2 = 2+2i
c1 * c2 = -5+10i
c1 / c2 = 2.2+0.4i

=== Compound Assignment ===
c3 = c1; c3 += c2: 4+6i
c3 = c1; c3 *= c2: -5+10i
```

**Mixed Type Arithmetic**

``` cpp
#include <iostream>
using namespace std;

class Fraction {
    int numerator;
    int denominator;

    // Helper: GCD for simplification
    static int gcd(int a, int b) {
        a = abs(a);
        b = abs(b);
        while (b) {
            int t = b;
            b = a % b;
            a = t;
        }
        return a;
    }

    void simplify() {
        int g = gcd(numerator, denominator);
        numerator /= g;
        denominator /= g;
        if (denominator < 0) {
            numerator = -numerator;
            denominator = -denominator;
        }
    }

public:
    Fraction(int num = 0, int den = 1) : numerator(num), denominator(den) {
        simplify();
    }

    // Fraction + Fraction
    Fraction operator+(const Fraction& other) const {
        return Fraction(
            numerator * other.denominator + other.numerator * denominator,
            denominator * other.denominator
        );
    }

    // Fraction + int (member function)
    Fraction operator+(int value) const {
        return *this + Fraction(value);
    }

    // Fraction * Fraction
    Fraction operator*(const Fraction& other) const {
        return Fraction(
            numerator * other.numerator,
            denominator * other.denominator
        );
    }

    // Friend: int + Fraction (non-member for left-side int)
    friend Fraction operator+(int value, const Fraction& f);

    // Friend: int * Fraction
    friend Fraction operator*(int value, const Fraction& f);

    // Stream output
    friend ostream& operator<<(ostream& os, const Fraction& f);
};

// Non-member operators for symmetry
Fraction operator+(int value, const Fraction& f) {
    return f + value;  // Reuse member operator
}

Fraction operator*(int value, const Fraction& f) {
    return Fraction(value) * f;
}

ostream& operator<<(ostream& os, const Fraction& f) {
    os << f.numerator << "/" << f.denominator;
    return os;
}

int main() {
    Fraction f1(1, 2);  // 1/2
    Fraction f2(2, 3);  // 2/3

    cout << "f1 = " << f1 << endl;
    cout << "f2 = " << f2 << endl;

    cout << "\n=== Fraction + Fraction ===" << endl;
    cout << "f1 + f2 = " << (f1 + f2) << endl;

    cout << "\n=== Fraction + int ===" << endl;
    cout << "f1 + 2 = " << (f1 + 2) << endl;

    cout << "\n=== int + Fraction ===" << endl;
    cout << "3 + f1 = " << (3 + f1) << endl;

    cout << "\n=== Mixed multiplication ===" << endl;
    cout << "f1 * f2 = " << (f1 * f2) << endl;
    cout << "2 * f1 = " << (2 * f1) << endl;

    return 0;
}
```

**Output:**  

```text

f1 = 1/2
f2 = 2/3

=== Fraction + Fraction ===
f1 + f2 = 7/6

=== Fraction + int ===
f1 + 2 = 5/2

=== int + Fraction ===
3 + f1 = 7/2

=== Mixed multiplication ===
f1 * f2 = 1/3
2 * f1 = 1/1
```


### 5. Comparison Operators
**Pre-C++20 Approach**

``` cpp
#include <iostream>
#include <string>
using namespace std;

class Person {
    string name;
    int age;

public:
    Person(const string& n, int a) : name(n), age(a) {}

    // Equality operators
    bool operator==(const Person& other) const {
        return name == other.name && age == other.age;
    }

    bool operator!=(const Person& other) const {
        return !(*this == other);  // Reuse operator==
    }

    // Relational operators (compare by age)
    bool operator<(const Person& other) const {
        return age < other.age;
    }

    bool operator>(const Person& other) const {
        return other < *this;  // Reuse operator<
    }

    bool operator<=(const Person& other) const {
        return !(other < *this);  // Reuse operator<
    }

    bool operator>=(const Person& other) const {
        return !(*this < other);  // Reuse operator<
    }

    friend ostream& operator<<(ostream& os, const Person& p);
};

ostream& operator<<(ostream& os, const Person& p) {
    os << p.name << " (age " << p.age << ")";
    return os;
}

int main() {
    Person alice("Alice", 30);
    Person bob("Bob", 25);
    Person charlie("Charlie", 30);
    Person alice2("Alice", 30);

    cout << alice << endl;
    cout << bob << endl;

    cout << "\n=== Equality ===" << endl;
    cout << "alice == alice2: " << boolalpha << (alice == alice2) << endl;
    cout << "alice == bob: " << (alice == bob) << endl;
    cout << "alice != bob: " << (alice != bob) << endl;

    cout << "\n=== Comparison ===" << endl;
    cout << "alice < bob: " << (alice < bob) << endl;
    cout << "alice > bob: " << (alice > bob) << endl;
    cout << "alice <= charlie: " << (alice <= charlie) << endl;

    return 0;
}
```

**C++20 Spaceship Operator**

``` cpp

#include <iostream>
#include <compare>
#include <string>
using namespace std;

class Version {
    int major;
    int minor;
    int patch;

public:
    Version(int ma, int mi, int pa) : major(ma), minor(mi), patch(pa) {}

    // Spaceship operator - generates all comparison operators!
    auto operator<=>(const Version& other) const = default;

    // Equality is also generated by default with <=>
    bool operator==(const Version& other) const = default;

    friend ostream& operator<<(ostream& os, const Version& v) {
        os << v.major << "." << v.minor << "." << v.patch;
        return os;
    }
};

class Product {
    string name;
    Version version;
    double price;

public:
    Product(const string& n, Version v, double p) 
        : name(n), version(v), price(p) {}

    // Custom spaceship operator
    auto operator<=>(const Product& other) const {
        // First compare by name
        if (auto cmp = name <=> other.name; cmp != 0) return cmp;
        // Then by version
        if (auto cmp = version <=> other.version; cmp != 0) return cmp;
        // Finally by price
        return price <=> other.price;
    }

    bool operator==(const Product& other) const = default;

    friend ostream& operator<<(ostream& os, const Product& p) {
        os << p.name << " v" << p.version << " ($" << p.price << ")";
        return os;
    }
};

int main() {
    Version v1(1, 0, 0);
    Version v2(1, 2, 0);
    Version v3(2, 0, 0);

    cout << "=== Version Comparison ===" << endl;
    cout << v1 << " < " << v2 << ": " << boolalpha << (v1 < v2) << endl;
    cout << v1 << " > " << v2 << ": " << (v1 > v2) << endl;
    cout << v1 << " == " << v2 << ": " << (v1 == v2) << endl;
    cout << v2 << " <= " << v3 << ": " << (v2 <= v3) << endl;

    cout << "\n=== Product Comparison ===" << endl;
    Product p1("App", Version(1, 0, 0), 9.99);
    Product p2("App", Version(2, 0, 0), 14.99);
    Product p3("Zapp", Version(1, 0, 0), 4.99);

    cout << p1 << endl;
    cout << p2 << endl;
    cout << p1 << " < " << p2 << ": " << (p1 < p2) << endl;
    cout << p1 << " < " << p3 << ": " << (p1 < p3) << endl;

    return 0;
}
```
**Spaceship Operator Categories**

``` 
┌─────────────────────────────────────────────────────────────────┐
│                 C++20 COMPARISON CATEGORIES                     │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  std::strong_ordering                                           │
│  ────────────────────                                           │
│  • Total ordering: every pair is comparable                     │
│  • Equal means substitutable                                    │
│  • Values: less, equal, greater                                 │
│  • Example: integers, strings                                   │
│                                                                 │
│  std::weak_ordering                                             │
│  ──────────────────                                             │
│  • Total ordering: every pair is comparable                     │
│  • Equivalent values may not be substitutable                   │
│  • Values: less, equivalent, greater                            │
│  • Example: case-insensitive strings                            │
│                                                                 │
│  std::partial_ordering                                          │
│  ─────────────────────                                          │
│  • Some pairs may be incomparable                               │
│  • Values: less, equivalent, greater, unordered                 │
│  • Example: floating-point (NaN != NaN)                         │
│                                                                 │
│  WHAT <=> GENERATES:                                            │
│  • operator<                                                    │
│  • operator>                                                    │
│  • operator<=                                                   │
│  • operator>=                                                   │
│  • operator== (if defaulted)                                    │
│  • operator!= (via ==)                                          │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 6. Increment & Decrement Operators
**Prefix vs Postfix**

``` cpp
#include <iostream>
using namespace std;

class Counter {
    int value;

public:
    Counter(int v = 0) : value(v) {}

    // Pre-increment: ++counter
    // Returns reference to modified object
    Counter& operator++() {
        ++value;
        cout << "Pre-increment: now " << value << endl;
        return *this;
    }

    // Post-increment: counter++
    // Returns copy of original, then modifies
    // int parameter is dummy to distinguish from prefix
    Counter operator++(int) {
        Counter temp = *this;  // Save current state
        ++value;
        cout << "Post-increment: was " << temp.value << ", now " << value << endl;
        return temp;  // Return old value
    }

    // Pre-decrement: --counter
    Counter& operator--() {
        --value;
        cout << "Pre-decrement: now " << value << endl;
        return *this;
    }

    // Post-decrement: counter--
    Counter operator--(int) {
        Counter temp = *this;
        --value;
        cout << "Post-decrement: was " << temp.value << ", now " << value << endl;
        return temp;
    }

    int get() const { return value; }

    friend ostream& operator<<(ostream& os, const Counter& c) {
        os << c.value;
        return os;
    }
};

int main() {
    Counter c(5);
    cout << "Initial: " << c << endl;

    cout << "\n=== Pre-increment ===" << endl;
    Counter result1 = ++c;  // c becomes 6, result1 is 6
    cout << "Result: " << result1 << ", c: " << c << endl;

    cout << "\n=== Post-increment ===" << endl;
    Counter result2 = c++;  // c becomes 7, result2 is 6
    cout << "Result: " << result2 << ", c: " << c << endl;

    cout << "\n=== Chained pre-increment ===" << endl;
    ++++c;  // Equivalent to ++(++c)
    cout << "After ++++c: " << c << endl;

    cout << "\n=== Pre-decrement ===" << endl;
    --c;
    cout << "After --c: " << c << endl;

    return 0;
}
```
**Output:**

```text

Initial: 5

=== Pre-increment ===
Pre-increment: now 6
Result: 6, c: 6

=== Post-increment ===
Post-increment: was 6, now 7
Result: 6, c: 7

=== Chained pre-increment ===
Pre-increment: now 8
Pre-increment: now 9
After ++++c: 9

=== Pre-decrement ===
Pre-decrement: now 8
After --c: 8

```

**Iterator-like Example**

``` cpp
#include <iostream>
using namespace std;

class IntRange {
    int current;
    int end;

public:
    IntRange(int start, int finish) : current(start), end(finish) {}

    // For range-based for loop support
    IntRange& begin() { return *this; }
    IntRange end_sentinel() const { return IntRange(end, end); }

    // Dereference
    int operator*() const { return current; }

    // Pre-increment for iteration
    IntRange& operator++() {
        ++current;
        return *this;
    }

    // Comparison for loop termination
    bool operator!=(const IntRange& other) const {
        return current != other.current;
    }
};

// Custom iterator class
class ArrayIterator {
    int* ptr;

public:
    ArrayIterator(int* p) : ptr(p) {}

    int& operator*() { return *ptr; }
    const int& operator*() const { return *ptr; }

    ArrayIterator& operator++() { ++ptr; return *this; }
    ArrayIterator operator++(int) { ArrayIterator tmp = *this; ++ptr; return tmp; }

    ArrayIterator& operator--() { --ptr; return *this; }
    ArrayIterator operator--(int) { ArrayIterator tmp = *this; --ptr; return tmp; }

    bool operator==(const ArrayIterator& other) const { return ptr == other.ptr; }
    bool operator!=(const ArrayIterator& other) const { return ptr != other.ptr; }
};

int main() {
    cout << "=== IntRange iteration ===" << endl;
    IntRange range(1, 6);
    for (auto it = range.begin(); it != range.end_sentinel(); ++it) {
        cout << *it << " ";
    }
    cout << endl;

    cout << "\n=== ArrayIterator ===" << endl;
    int arr[] = {10, 20, 30, 40, 50};
    ArrayIterator begin(arr);
    ArrayIterator end(arr + 5);

    cout << "Forward: ";
    for (ArrayIterator it = begin; it != end; ++it) {
        cout << *it << " ";
    }
    cout << endl;

    return 0;
}
```
**Prefix vs Postfix Summary**

``` 
┌─────────────────────────────────────────────────────────────────┐
│              PREFIX vs POSTFIX OPERATORS                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  PREFIX (++x, --x):                                             │
│  ─────────────────                                              │
│  • Signature: T& operator++()                                   │
│  • Modifies, then returns reference                             │
│  • More efficient (no copy)                                     │
│  • Can be chained: ++++x                                        │
│                                                                 │
│  POSTFIX (x++, x--):                                            │
│  ──────────────────                                             │
│  • Signature: T operator++(int)  // dummy int parameter         │
│  • Saves copy, modifies, returns copy                           │
│  • Less efficient (creates temporary)                           │
│  • Cannot be meaningfully chained                               │
│                                                                 │
│  PREFERENCE:                                                    │
│  • Use prefix when you don't need the old value                 │
│  • Use postfix only when old value is needed                    │
│                                                                 │
│  IMPLEMENTATION TIP:                                            │
│  • Implement postfix in terms of prefix                         │
│    T operator++(int) {                                          │
│        T temp = *this;                                          │
│        ++(*this);  // Use prefix                                │
│        return temp;                                             │
│    }                                                            │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 7. Subscript Operator
**Basic Array Class**

``` cpp
#include <iostream>
#include <stdexcept>
using namespace std;

class Array {
    int* data;
    size_t size;

public:
    Array(size_t sz) : size(sz), data(new int[sz]) {
        for (size_t i = 0; i < size; i++) data[i] = 0;
    }

    ~Array() { delete[] data; }

    // Non-const subscript operator (read/write)
    int& operator[](size_t index) {
        if (index >= size) {
            throw out_of_range("Index out of bounds");
        }
        return data[index];
    }

    // Const subscript operator (read-only)
    const int& operator[](size_t index) const {
        if (index >= size) {
            throw out_of_range("Index out of bounds");
        }
        return data[index];
    }

    size_t length() const { return size; }
};

void printArray(const Array& arr) {  // Takes const reference
    cout << "[ ";
    for (size_t i = 0; i < arr.length(); i++) {
        cout << arr[i] << " ";  // Uses const operator[]
    }
    cout << "]" << endl;
}

int main() {
    Array arr(5);

    // Write using non-const operator[]
    for (size_t i = 0; i < arr.length(); i++) {
        arr[i] = (i + 1) * 10;
    }

    // Read using const operator[]
    printArray(arr);

    // Modify single element
    arr[2] = 999;
    printArray(arr);

    // Bounds checking
    try {
        cout << arr[10] << endl;
    } catch (const out_of_range& e) {
        cout << "Exception: " << e.what() << endl;
    }

    return 0;
}
```

**Output:**

```text

[ 10 20 30 40 50 ]
[ 10 20 999 40 50 ]
Exception: Index out of bounds
```

**Multi-dimensional Subscript**

``` cpp
#include <iostream>
#include <vector>
using namespace std;

class Matrix {
    vector<vector<double>> data;
    size_t rows, cols;

public:
    Matrix(size_t r, size_t c, double init = 0.0)
        : rows(r), cols(c), data(r, vector<double>(c, init)) {}

    // Proxy class for second subscript
    class RowProxy {
        vector<double>& row;
    public:
        RowProxy(vector<double>& r) : row(r) {}
        
        double& operator[](size_t col) { return row[col]; }
        const double& operator[](size_t col) const { return row[col]; }
    };

    class ConstRowProxy {
        const vector<double>& row;
    public:
        ConstRowProxy(const vector<double>& r) : row(r) {}
        
        const double& operator[](size_t col) const { return row[col]; }
    };

    // First subscript returns proxy
    RowProxy operator[](size_t row) {
        return RowProxy(data[row]);
    }

    ConstRowProxy operator[](size_t row) const {
        return ConstRowProxy(data[row]);
    }

    // Alternative: operator() for multi-dimensional
    double& operator()(size_t row, size_t col) {
        return data[row][col];
    }

    const double& operator()(size_t row, size_t col) const {
        return data[row][col];
    }

    void print() const {
        for (size_t i = 0; i < rows; i++) {
            for (size_t j = 0; j < cols; j++) {
                cout << data[i][j] << "\t";
            }
            cout << endl;
        }
    }
};

int main() {
    Matrix m(3, 4);

    // Using double subscript
    m[0][0] = 1.0;
    m[1][1] = 2.0;
    m[2][2] = 3.0;

    // Using function call operator
    m(0, 3) = 4.0;
    m(2, 0) = 5.0;

    cout << "Matrix:" << endl;
    m.print();

    cout << "\nm[1][1] = " << m[1][1] << endl;
    cout << "m(2, 2) = " << m(2, 2) << endl;

    return 0;
}
```
**Output:**

```text

Matrix:
1	0	0	4	
0	2	0	0	
5	0	3	0	

m[1][1] = 2
m(2, 2) = 3
```
**C++23 Multidimensional Subscript**

``` cpp
// C++23 feature - direct multidimensional subscript
#if __cplusplus >= 202302L

class Matrix23 {
    vector<double> data;
    size_t rows, cols;

public:
    Matrix23(size_t r, size_t c) : rows(r), cols(c), data(r * c) {}

    // C++23: Multiple parameters in operator[]
    double& operator[](size_t row, size_t col) {
        return data[row * cols + col];
    }

    const double& operator[](size_t row, size_t col) const {
        return data[row * cols + col];
    }
};

// Usage:
// Matrix23 m(3, 4);
// m[1, 2] = 5.0;  // Direct multi-dimensional indexing!

#endif
```

### 8. Function Call Operator
**Functor (Function Object)**

``` cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

// Functor for adding a constant
class Adder {
    int value;

public:
    Adder(int v) : value(v) {}

    int operator()(int x) const {
        return x + value;
    }
};

// Functor for multiplication
class Multiplier {
    double factor;

public:
    Multiplier(double f) : factor(f) {}

    double operator()(double x) const {
        return x * factor;
    }
};

// Functor with state
class Counter {
    int count;

public:
    Counter() : count(0) {}

    void operator()(int) {
        ++count;
    }

    int getCount() const { return count; }
};

// Predicate functor
class InRange {
    int low, high;

public:
    InRange(int l, int h) : low(l), high(h) {}

    bool operator()(int x) const {
        return x >= low && x <= high;
    }
};

int main() {
    cout << "=== Basic Functor ===" << endl;
    Adder add5(5);
    cout << "add5(10) = " << add5(10) << endl;
    cout << "add5(20) = " << add5(20) << endl;

    Multiplier times2(2.0);
    cout << "times2(3.5) = " << times2(3.5) << endl;

    cout << "\n=== With STL Algorithms ===" << endl;
    vector<int> nums = {1, 2, 3, 4, 5};

    cout << "Original: ";
    for (int n : nums) cout << n << " ";
    cout << endl;

    // Transform with functor
    vector<int> result(nums.size());
    transform(nums.begin(), nums.end(), result.begin(), Adder(10));

    cout << "After Adder(10): ";
    for (int n : result) cout << n << " ";
    cout << endl;

    cout << "\n=== Stateful Functor ===" << endl;
    Counter counter;
    counter = for_each(nums.begin(), nums.end(), counter);
    cout << "Counted " << counter.getCount() << " elements" << endl;

    cout << "\n=== Predicate Functor ===" << endl;
    InRange between5and15(5, 15);
    vector<int> values = {3, 7, 12, 18, 5, 15, 2};

    cout << "Values in range [5, 15]: ";
    for (int v : values) {
        if (between5and15(v)) {
            cout << v << " ";
        }
    }
    cout << endl;

    // Count with predicate
    int count = count_if(values.begin(), values.end(), InRange(5, 15));
    cout << "Count: " << count << endl;

    return 0;
}
```

**Output:**

```text

=== Basic Functor ===
add5(10) = 15
add5(20) = 25
times2(3.5) = 7

=== With STL Algorithms ===
Original: 1 2 3 4 5 
After Adder(10): 11 12 13 14 15 

=== Stateful Functor ===
Counted 5 elements

=== Predicate Functor ===
Values in range [5, 15]: 7 12 5 15 
Count: 4
```

**Advanced Functor Examples**
``` cpp
#include <iostream>
#include <string>
#include <map>
using namespace std;

// Polynomial evaluator
class Polynomial {
    vector<double> coefficients;  // coefficients[i] = coefficient of x^i

public:
    Polynomial(initializer_list<double> coeffs) : coefficients(coeffs) {}

    // Evaluate polynomial at x
    double operator()(double x) const {
        double result = 0;
        double power = 1;
        for (double coef : coefficients) {
            result += coef * power;
            power *= x;
        }
        return result;
    }
};

// Memoizing functor
class Fibonacci {
    mutable map<int, long long> cache;

public:
    long long operator()(int n) const {
        if (n <= 1) return n;

        auto it = cache.find(n);
        if (it != cache.end()) {
            return it->second;
        }

        long long result = (*this)(n - 1) + (*this)(n - 2);
        cache[n] = result;
        return result;
    }
};

// String formatter
class Formatter {
    string prefix;
    string suffix;

public:
    Formatter(const string& pre, const string& suf) 
        : prefix(pre), suffix(suf) {}

    string operator()(const string& text) const {
        return prefix + text + suffix;
    }
};

// Multiple overloads
class Printer {
public:
    void operator()(int x) const {
        cout << "Integer: " << x << endl;
    }

    void operator()(double x) const {
        cout << "Double: " << x << endl;
    }

    void operator()(const string& x) const {
        cout << "String: \"" << x << "\"" << endl;
    }

    template<typename T>
    void operator()(const vector<T>& v) const {
        cout << "Vector: [ ";
        for (const auto& item : v) cout << item << " ";
        cout << "]" << endl;
    }
};

int main() {
    cout << "=== Polynomial ===" << endl;
    // 2 + 3x + x^2
    Polynomial poly({2, 3, 1});
    cout << "p(0) = " << poly(0) << endl;
    cout << "p(2) = " << poly(2) << endl;  // 2 + 6 + 4 = 12
    cout << "p(3) = " << poly(3) << endl;  // 2 + 9 + 9 = 20

    cout << "\n=== Memoized Fibonacci ===" << endl;
    Fibonacci fib;
    cout << "fib(10) = " << fib(10) << endl;
    cout << "fib(20) = " << fib(20) << endl;
    cout << "fib(40) = " << fib(40) << endl;  // Fast due to memoization

    cout << "\n=== String Formatter ===" << endl;
    Formatter html("<p>", "</p>");
    Formatter quote("\"", "\"");
    cout << html("Hello, World!") << endl;
    cout << quote("quoted text") << endl;

    cout << "\n=== Overloaded Printer ===" << endl;
    Printer print;
    print(42);
    print(3.14159);
    print("Hello");
    print(vector<int>{1, 2, 3, 4, 5});

    return 0;
}
```

**Output:**

```text

=== Polynomial ===
p(0) = 2
p(2) = 12
p(3) = 20

=== Memoized Fibonacci ===
fib(10) = 55
fib(20) = 6765
fib(40) = 102334155

=== String Formatter ===
<p>Hello, World!</p>
"quoted text"

=== Overloaded Printer ===
Integer: 42
Double: 3.14159
String: "Hello"
Vector: [ 1 2 3 4 5 ]
```
**Comparison: Functor vs Lambda**
``` cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

// Functor approach
class MultiplyBy {
    int factor;
public:
    MultiplyBy(int f) : factor(f) {}
    int operator()(int x) const { return x * factor; }
};

int main() {
    vector<int> nums = {1, 2, 3, 4, 5};
    vector<int> result(nums.size());
    int factor = 3;

    // Using functor
    transform(nums.begin(), nums.end(), result.begin(), MultiplyBy(factor));
    cout << "Functor result: ";
    for (int n : result) cout << n << " ";
    cout << endl;

    // Using lambda (C++11+) - often simpler
    transform(nums.begin(), nums.end(), result.begin(), 
              [factor](int x) { return x * factor; });
    cout << "Lambda result: ";
    for (int n : result) cout << n << " ";
    cout << endl;

    return 0;
}
```

### 9. Stream Operators
**Output Stream Operator (<<)**

``` cpp
#include <iostream>
#include <iomanip>
#include <sstream>
using namespace std;

class Date {
    int year, month, day;

public:
    Date(int y, int m, int d) : year(y), month(m), day(d) {}

    // Stream output - MUST be non-member (friend)
    friend ostream& operator<<(ostream& os, const Date& date);

    // Stream input - MUST be non-member (friend)
    friend istream& operator>>(istream& is, Date& date);
};

// Output: Date in YYYY-MM-DD format
ostream& operator<<(ostream& os, const Date& date) {
    os << date.year << "-"
       << setw(2) << setfill('0') << date.month << "-"
       << setw(2) << setfill('0') << date.day;
    return os;
}

// Input: Expect YYYY-MM-DD format
istream& operator>>(istream& is, Date& date) {
    char sep1, sep2;
    is >> date.year >> sep1 >> date.month >> sep2 >> date.day;
    
    if (sep1 != '-' || sep2 != '-') {
        is.setstate(ios::failbit);
    }
    return is;
}

int main() {
    Date d1(2024, 1, 15);
    Date d2(2024, 12, 25);

    cout << "=== Output Operator ===" << endl;
    cout << "Date 1: " << d1 << endl;
    cout << "Date 2: " << d2 << endl;

    cout << "\n=== Chained Output ===" << endl;
    cout << "Dates: " << d1 << " and " << d2 << endl;

    cout << "\n=== Input Operator ===" << endl;
    Date d3(0, 0, 0);
    cout << "Enter date (YYYY-MM-DD): ";
    
    // Simulate input with stringstream
    stringstream ss("2024-06-20");
    if (ss >> d3) {
        cout << "You entered: " << d3 << endl;
    } else {
        cout << "Invalid format!" << endl;
    }

    return 0;
}
```

**Complete Example with Multiple Formats**

``` cpp
#include <iostream>
#include <iomanip>
#include <string>
using namespace std;

class Money {
    long cents;  // Store as cents to avoid floating point issues

public:
    Money(long dollars = 0, int cents = 0) : cents(dollars * 100 + cents) {}
    Money(double amount) : cents(static_cast<long>(amount * 100 + 0.5)) {}

    // Arithmetic
    Money operator+(const Money& other) const {
        Money result;
        result.cents = cents + other.cents;
        return result;
    }

    Money operator-(const Money& other) const {
        Money result;
        result.cents = cents - other.cents;
        return result;
    }

    Money operator*(double factor) const {
        Money result;
        result.cents = static_cast<long>(cents * factor);
        return result;
    }

    // Comparison
    bool operator<(const Money& other) const { return cents < other.cents; }
    bool operator==(const Money& other) const { return cents == other.cents; }

    // Stream operators
    friend ostream& operator<<(ostream& os, const Money& m);
    friend istream& operator>>(istream& is, Money& m);
};

ostream& operator<<(ostream& os, const Money& m) {
    bool negative = m.cents < 0;
    long absCents = negative ? -m.cents : m.cents;
    
    os << (negative ? "-$" : "$")
       << absCents / 100 << "."
       << setw(2) << setfill('0') << absCents % 100;
    return os;
}

istream& operator>>(istream& is, Money& m) {
    char dollar;
    double amount;
    
    is >> dollar >> amount;
    
    if (dollar != '$') {
        is.setstate(ios::failbit);
        return is;
    }
    
    m.cents = static_cast<long>(amount * 100 + 0.5);
    return is;
}

class Person {
    string firstName;
    string lastName;
    int age;
    Money salary;

public:
    Person(const string& fn, const string& ln, int a, Money s)
        : firstName(fn), lastName(ln), age(a), salary(s) {}

    friend ostream& operator<<(ostream& os, const Person& p);
    friend istream& operator>>(istream& is, Person& p);
};

ostream& operator<<(ostream& os, const Person& p) {
    os << "Person {\n"
       << "  Name: " << p.firstName << " " << p.lastName << "\n"
       << "  Age: " << p.age << "\n"
       << "  Salary: " << p.salary << "\n"
       << "}";
    return os;
}

istream& operator>>(istream& is, Person& p) {
    is >> p.firstName >> p.lastName >> p.age >> p.salary;
    return is;
}

int main() {
    cout << "=== Money ===" << endl;
    Money m1(100, 50);      // $100.50
    Money m2(75.25);        // $75.25
    Money m3 = m1 + m2;
    Money m4 = m1 * 1.5;

    cout << "m1 = " << m1 << endl;
    cout << "m2 = " << m2 << endl;
    cout << "m1 + m2 = " << m3 << endl;
    cout << "m1 * 1.5 = " << m4 << endl;

    cout << "\n=== Person ===" << endl;
    Person p("John", "Doe", 30, Money(75000));
    cout << p << endl;

    cout << "\n=== Reading Person ===" << endl;
    // Simulate input
    stringstream ss("Jane Smith 25 $85000.00");
    Person p2("", "", 0, Money(0));
    if (ss >> p2) {
        cout << p2 << endl;
    }

    return 0;
}
```

**Output:**

```text

=== Money ===
m1 = $100.50
m2 = $75.25
m1 + m2 = $175.75
m1 * 1.5 = $150.75

=== Person ===
Person {
  Name: John Doe
  Age: 30
  Salary: $75000.00
}

=== Reading Person ===
Person {
  Name: Jane Smith
  Age: 25
  Salary: $85000.00
}
```

### 10. Conversion Operators
**Implicit and Explicit Conversions**

``` cpp
#include <iostream>
#include <string>
using namespace std;

class Fraction {
    int numerator;
    int denominator;

public:
    Fraction(int num = 0, int den = 1) : numerator(num), denominator(den) {}

    // Conversion to double (explicit to prevent accidents)
    explicit operator double() const {
        return static_cast<double>(numerator) / denominator;
    }

    // Conversion to bool (typically explicit)
    explicit operator bool() const {
        return numerator != 0;
    }

    // Conversion to string
    operator string() const {
        return to_string(numerator) + "/" + to_string(denominator);
    }

    friend ostream& operator<<(ostream& os, const Fraction& f) {
        os << f.numerator << "/" << f.denominator;
        return os;
    }
};

class SmartInt {
    int value;

public:
    SmartInt(int v = 0) : value(v) {}

    // Implicit conversion to int
    operator int() const {
        cout << "(converting to int)" << endl;
        return value;
    }
};

class SafeInt {
    int value;

public:
    SafeInt(int v = 0) : value(v) {}

    // Explicit conversion only
    explicit operator int() const {
        return value;
    }

    // For use in boolean contexts (if, while, etc.)
    explicit operator bool() const {
        return value != 0;
    }
};

int main() {
    cout << "=== Fraction Conversions ===" << endl;
    Fraction f(3, 4);

    // Explicit conversion to double
    double d = static_cast<double>(f);  // Required due to explicit
    // double d2 = f;  // ERROR: explicit conversion required
    cout << "Fraction " << f << " as double: " << d << endl;

    // Implicit conversion to string (allowed)
    string s = f;
    cout << "Fraction as string: " << s << endl;

    // Explicit conversion to bool in conditions
    if (f) {  // Allowed in boolean context even if explicit
        cout << "Fraction is non-zero" << endl;
    }

    Fraction zero(0, 1);
    if (!zero) {
        cout << "Zero fraction is falsy" << endl;
    }

    cout << "\n=== SmartInt (Implicit) ===" << endl;
    SmartInt si(42);
    int x = si;  // Implicit conversion
    cout << "Value: " << x << endl;
    cout << "si + 10 = " << (si + 10) << endl;  // Implicit conversion

    cout << "\n=== SafeInt (Explicit) ===" << endl;
    SafeInt safe(100);
    // int y = safe;  // ERROR: explicit required
    int y = static_cast<int>(safe);  // OK
    cout << "Value: " << y << endl;

    // Boolean context still works
    if (safe) {
        cout << "SafeInt is non-zero" << endl;
    }

    return 0;
}
```

**Output:**

```text

=== Fraction Conversions ===
Fraction 3/4 as double: 0.75
Fraction as string: 3/4
Fraction is non-zero
Zero fraction is falsy

=== SmartInt (Implicit) ===
(converting to int)
Value: 42
(converting to int)
si + 10 = 52

=== SafeInt (Explicit) ===
Value: 100
SafeInt is non-zero
```

**Smart Pointer Conversion Example**
``` cpp
#include <iostream>
using namespace std;

template<typename T>
class SmartPtr {
    T* ptr;

public:
    explicit SmartPtr(T* p = nullptr) : ptr(p) {}

    ~SmartPtr() { delete ptr; }

    // Prevent copying
    SmartPtr(const SmartPtr&) = delete;
    SmartPtr& operator=(const SmartPtr&) = delete;

    // Allow moving
    SmartPtr(SmartPtr&& other) noexcept : ptr(other.ptr) {
        other.ptr = nullptr;
    }

    SmartPtr& operator=(SmartPtr&& other) noexcept {
        if (this != &other) {
            delete ptr;
            ptr = other.ptr;
            other.ptr = nullptr;
        }
        return *this;
    }

    // Conversion to bool for null checking
    explicit operator bool() const {
        return ptr != nullptr;
    }

    // Dereference operators
    T& operator*() const { return *ptr; }
    T* operator->() const { return ptr; }

    // Get raw pointer
    T* get() const { return ptr; }
};

class Resource {
public:
    int value;
    Resource(int v) : value(v) {
        cout << "Resource(" << value << ") created" << endl;
    }
    ~Resource() {
        cout << "Resource(" << value << ") destroyed" << endl;
    }
};

int main() {
    SmartPtr<Resource> ptr1(new Resource(42));

    if (ptr1) {  // Uses operator bool()
        cout << "ptr1 is valid, value = " << ptr1->value << endl;
    }

    SmartPtr<Resource> ptr2;  // nullptr

    if (!ptr2) {
        cout << "ptr2 is null" << endl;
    }

    // Move ptr1 to ptr3
    SmartPtr<Resource> ptr3 = std::move(ptr1);

    if (!ptr1) {
        cout << "ptr1 is now null after move" << endl;
    }

    if (ptr3) {
        cout << "ptr3 has the resource: " << (*ptr3).value << endl;
    }

    return 0;
}
```
### 11. Smart Pointer Operators
**Complete Smart Pointer Implementation**

``` cpp
#include <iostream>
#include <utility>
using namespace std;

template<typename T>
class UniquePtr {
    T* ptr;

public:
    // Constructors
    explicit UniquePtr(T* p = nullptr) : ptr(p) {}

    // Destructor
    ~UniquePtr() {
        delete ptr;
    }

    // No copying
    UniquePtr(const UniquePtr&) = delete;
    UniquePtr& operator=(const UniquePtr&) = delete;

    // Move operations
    UniquePtr(UniquePtr&& other) noexcept : ptr(other.ptr) {
        other.ptr = nullptr;
    }

    UniquePtr& operator=(UniquePtr&& other) noexcept {
        if (this != &other) {
            delete ptr;
            ptr = other.ptr;
            other.ptr = nullptr;
        }
        return *this;
    }

    // ========== SMART POINTER OPERATORS ==========

    // Dereference operator
    T& operator*() const {
        return *ptr;
    }

    // Arrow operator (member access)
    T* operator->() const {
        return ptr;
    }

    // Boolean conversion
    explicit operator bool() const {
        return ptr != nullptr;
    }

    // Subscript for array-like access (if T is array)
    T& operator[](size_t index) const {
        return ptr[index];
    }

    // ========== UTILITY METHODS ==========

    T* get() const { return ptr; }

    T* release() {
        T* temp = ptr;
        ptr = nullptr;
        return temp;
    }

    void reset(T* p = nullptr) {
        delete ptr;
        ptr = p;
    }

    void swap(UniquePtr& other) noexcept {
        std::swap(ptr, other.ptr);
    }
};

// Factory function
template<typename T, typename... Args>
UniquePtr<T> makeUnique(Args&&... args) {
    return UniquePtr<T>(new T(std::forward<Args>(args)...));
}

class Widget {
public:
    int x, y;
    string name;

    Widget(int x, int y, const string& n) : x(x), y(y), name(n) {
        cout << "Widget \"" << name << "\" created" << endl;
    }

    ~Widget() {
        cout << "Widget \"" << name << "\" destroyed" << endl;
    }

    void display() const {
        cout << "Widget: " << name << " at (" << x << ", " << y << ")" << endl;
    }
};

int main() {
    cout << "=== Creating UniquePtr ===" << endl;
    UniquePtr<Widget> w1 = makeUnique<Widget>(10, 20, "First");

    cout << "\n=== Using operator-> ===" << endl;
    w1->display();
    cout << "Name via ->: " << w1->name << endl;

    cout << "\n=== Using operator* ===" << endl;
    (*w1).x = 100;
    (*w1).display();

    cout << "\n=== Using operator bool ===" << endl;
    if (w1) {
        cout << "w1 is valid" << endl;
    }

    cout << "\n=== Moving ownership ===" << endl;
    UniquePtr<Widget> w2 = std::move(w1);

    if (!w1) {
        cout << "w1 is now null" << endl;
    }
    if (w2) {
        cout << "w2 owns the widget: " << w2->name << endl;
    }

    cout << "\n=== Array-like UniquePtr ===" << endl;
    UniquePtr<int> arr(new int[5]);
    for (int i = 0; i < 5; i++) {
        arr[i] = i * 10;
    }
    cout << "arr[3] = " << arr[3] << endl;

    cout << "\n=== Cleanup ===" << endl;
    return 0;
}
```

**Output:**

```text

=== Creating UniquePtr ===
Widget "First" created

=== Using operator-> ===
Widget: First at (10, 20)
Name via ->: First

=== Using operator* ===
Widget: First at (100, 20)

=== Using operator bool ===
w1 is valid

=== Moving ownership ===
w1 is now null
w2 owns the widget: First

=== Array-like UniquePtr ===
arr[3] = 30

=== Cleanup ===
Widget "First" destroyed
```
**Shared Pointer (Reference Counting)**

``` cpp
#include <iostream>
using namespace std;

template<typename T>
class SharedPtr {
    T* ptr;
    size_t* refCount;

    void release() {
        if (refCount) {
            (*refCount)--;
            if (*refCount == 0) {
                delete ptr;
                delete refCount;
            }
        }
    }

public:
    explicit SharedPtr(T* p = nullptr) : ptr(p), refCount(p ? new size_t(1) : nullptr) {}

    // Copy constructor - increment ref count
    SharedPtr(const SharedPtr& other) : ptr(other.ptr), refCount(other.refCount) {
        if (refCount) {
            (*refCount)++;
        }
    }

    // Move constructor
    SharedPtr(SharedPtr&& other) noexcept : ptr(other.ptr), refCount(other.refCount) {
        other.ptr = nullptr;
        other.refCount = nullptr;
    }

    // Destructor
    ~SharedPtr() {
        release();
    }

    // Copy assignment
    SharedPtr& operator=(const SharedPtr& other) {
        if (this != &other) {
            release();
            ptr = other.ptr;
            refCount = other.refCount;
            if (refCount) {
                (*refCount)++;
            }
        }
        return *this;
    }

    // Move assignment
    SharedPtr& operator=(SharedPtr&& other) noexcept {
        if (this != &other) {
            release();
            ptr = other.ptr;
            refCount = other.refCount;
            other.ptr = nullptr;
            other.refCount = nullptr;
        }
        return *this;
    }

    // Smart pointer operators
    T& operator*() const { return *ptr; }
    T* operator->() const { return ptr; }
    explicit operator bool() const { return ptr != nullptr; }

    // Utility
    T* get() const { return ptr; }
    size_t useCount() const { return refCount ? *refCount : 0; }
};

int main() {
    cout << "=== SharedPtr Demo ===" << endl;

    SharedPtr<string> s1(new string("Hello"));
    cout << "s1 created, refCount = " << s1.useCount() << endl;

    {
        SharedPtr<string> s2 = s1;  // Copy
        cout << "s2 = s1, refCount = " << s1.useCount() << endl;

        SharedPtr<string> s3 = s1;  // Another copy
        cout << "s3 = s1, refCount = " << s1.useCount() << endl;

        *s2 = "World";
        cout << "Modified via s2: " << *s1 << endl;
    }

    cout << "After s2, s3 destroyed, refCount = " << s1.useCount() << endl;
    cout << "Value: " << *s1 << endl;

    return 0;
}
```

### 12. Rules & Best Practices
**Operator Overloading Summary Table**

``` 
┌─────────────────────────────────────────────────────────────────┐
│              OPERATOR OVERLOADING SUMMARY                       │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  OPERATOR        MEMBER/NON-MEMBER    TYPICAL SIGNATURE         │
│  ────────        ─────────────────    ─────────────────         │
│                                                                 │
│  =               Member (required)    T& operator=(const T&)    │
│  []              Member (required)    T& operator[](size_t)     │
│  ()              Member (required)    R operator()(Args...)     │
│  ->              Member (required)    T* operator->()           │
│  ->*             Member (required)    T& operator->*(M T::*)    │
│                                                                 │
│  + - * /         Prefer non-member    T operator+(T, T)         │
│  == != < > <= >= Prefer non-member    bool operator==(T, T)     │
│  << >>           Non-member (required) ostream& operator<<(...)  │
│                                                                 │
│  += -= *= /=     Member               T& operator+=(const T&)   │
│  ++ --           Member               T& operator++() (prefix)  │
│                                        T operator++(int) (post)  │
│                                                                 │
│  unary + - ! ~   Either               T operator-() const       │
│                                                                 │
│  conversion      Member (required)    operator TargetType()     │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**Best Practices**

``` cpp
#include <iostream>
#include <utility>
using namespace std;

// ✓ GOOD: Complete, consistent operator set
class GoodNumber {
    int value;

public:
    GoodNumber(int v = 0) : value(v) {}

    // ✓ Return reference for compound assignment
    GoodNumber& operator+=(const GoodNumber& other) {
        value += other.value;
        return *this;
    }

    // ✓ Implement binary in terms of compound
    friend GoodNumber operator+(GoodNumber lhs, const GoodNumber& rhs) {
        lhs += rhs;
        return lhs;
    }

    // ✓ Symmetric comparison operators
    friend bool operator==(const GoodNumber& lhs, const GoodNumber& rhs) {
        return lhs.value == rhs.value;
    }

    friend bool operator!=(const GoodNumber& lhs, const GoodNumber& rhs) {
        return !(lhs == rhs);
    }

    // ✓ Const correctness for read-only operations
    GoodNumber operator-() const {
        return GoodNumber(-value);
    }

    // ✓ noexcept for move operations
    GoodNumber(GoodNumber&& other) noexcept : value(other.value) {
        other.value = 0;
    }

    GoodNumber& operator=(GoodNumber&& other) noexcept {
        value = other.value;
        other.value = 0;
        return *this;
    }

    // ✓ Stream operators as non-member friends
    friend ostream& operator<<(ostream& os, const GoodNumber& n) {
        os << n.value;
        return os;
    }
};

// ✗ BAD: Common mistakes to avoid
class BadNumber {
    int value;

public:
    // ✗ Returning void from compound assignment
    void operator+=(int x) {  // Should return BadNumber&
        value += x;
    }

    // ✗ Non-const binary operator that modifies operand
    BadNumber operator+(BadNumber other) {  // Should be const
        value += other.value;  // Modifying *this!
        return *this;
    }

    // ✗ Asymmetric comparison (member instead of friend)
    bool operator==(int x) const {
        return value == x;
        // This allows: badNum == 5
        // But not: 5 == badNum (unless non-member)
    }

    // ✗ Missing const on read-only operator
    int operator[](size_t idx) {  // Should have const version too
        return value;
    }
};
```
**Complete Best Practices Checklist**

```
┌─────────────────────────────────────────────────────────────────┐
│            OPERATOR OVERLOADING BEST PRACTICES                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  GENERAL RULES:                                                 │
│  ✓ Maintain intuitive semantics (+ should add, not subtract)   │
│  ✓ Be consistent (if you have +, also have +=)                 │
│  ✓ Return appropriate types:                                   │
│    • Compound assignment: return *this by reference             │
│    • Binary operators: return new object by value               │
│    • Prefix ++/--: return *this by reference                    │
│    • Postfix ++/--: return copy by value                        │
│                                                                 │
│  CONST CORRECTNESS:                                             │
│  ✓ Mark operators const if they don't modify object            │
│  ✓ Provide both const and non-const versions of []             │
│  ✓ Take parameters by const reference when possible            │
│                                                                 │
│  MEMBER VS NON-MEMBER:                                          │
│  ✓ Use member for: = [] () -> and operators that modify        │
│  ✓ Use non-member for: << >> and symmetric binary operators    │
│  ✓ Non-member allows implicit conversion on both operands      │
│                                                                 │
│  IMPLEMENTATION TIPS:                                           │
│  ✓ Implement + in terms of +=                                  │
│  ✓ Implement != in terms of ==                                 │
│  ✓ Implement >, <=, >= in terms of <                           │
│  ✓ Implement postfix in terms of prefix                        │
│  ✓ Use copy-and-swap for exception-safe assignment             │
│                                                                 │
│  MODERN C++ (C++20):                                            │
│  ✓ Use <=> spaceship operator to generate all comparisons      │
│  ✓ Default <=> when possible: auto operator<=>(const T&) const │
│                                                                 │
│  AVOID:                                                         │
│  ✗ Overloading && and || (short-circuit evaluation lost)       │
│  ✗ Overloading , (comma) operator                              │
│  ✗ Overloading & (address-of) for non-proxy classes            │
│  ✗ Making operators do unexpected things                        │
│  ✗ Forgetting self-assignment check in operator=               │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```
**Quick Reference Card**

``` 
┌─────────────────────────────────────────────────────────────────┐
│              OPERATOR OVERLOADING QUICK REFERENCE               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  COPY ASSIGNMENT:                                               │
│  T& operator=(const T& other) {                                 │
│      if (this != &other) { /* copy */ }                         │
│      return *this;                                              │
│  }                                                              │
│                                                                 │
│  MOVE ASSIGNMENT:                                               │
│  T& operator=(T&& other) noexcept {                             │
│      if (this != &other) { /* steal resources */ }              │
│      return *this;                                              │
│  }                                                              │
│                                                                 │
│  BINARY OPERATOR (non-member):                                  │
│  T operator+(T lhs, const T& rhs) {                             │
│      lhs += rhs;                                                │
│      return lhs;                                                │
│  }                                                              │
│                                                                 │
│  STREAM OUTPUT:                                                 │
│  friend ostream& operator<<(ostream& os, const T& obj) {        │
│      os << /* format */;                                        │
│      return os;                                                 │
│  }                                                              │
│                                                                 │
│  SUBSCRIPT:                                                     │
│  T& operator[](size_t i) { return data[i]; }                    │
│  const T& operator[](size_t i) const { return data[i]; }        │
│                                                                 │
│  INCREMENT:                                                     │
│  T& operator++() { /* inc */ return *this; }      // prefix     │
│  T operator++(int) { T t=*this; ++*this; return t; } // postfix │
│                                                                 │
│  CONVERSION:                                                    │
│  explicit operator bool() const { return /* condition */; }     │
│  explicit operator double() const { return /* value */; }       │
│                                                                 │
│  SPACESHIP (C++20):                                             │
│  auto operator<=>(const T&) const = default;                    │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

