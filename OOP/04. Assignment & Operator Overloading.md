## Assignment & Operator Overloading in C++
A comprehensive guide covering assignment operators and all aspects of operator overloading.

### Table of Contents
* Introduction to Operator Overloading
* Copy Assignment Operator
* Move Assignment Operator
* Arithmetic Operators
* Comparison Operators
* Increment & Decrement Operators
* Subscript Operator
* Function Call Operator
* Stream Operators
* Conversion Operators
* Smart Pointer Operators
* Rules & Best Practices

### 1. Introduction to Operator Overloading
Operator overloading allows you to define custom behavior for operators when applied to user-defined types.

**Basic Concept**
``` cpp
#include <iostream>
using namespace std;

class Point {
    int x, y;

public:
    Point(int x = 0, int y = 0) : x(x), y(y) {}

    // Operator overloading: Define what + means for Point
    Point operator+(const Point& other) const {
        return Point(x + other.x, y + other.y);
    }

    void print() const {
        cout << "(" << x << ", " << y << ")" << endl;
    }
};

int main() {
    Point p1(3, 4);
    Point p2(1, 2);
    
    Point p3 = p1 + p2;  // Uses overloaded operator+
    
    p1.print();  // (3, 4)
    p2.print();  // (1, 2)
    p3.print();  // (4, 6)
    
    return 0;
}
```
**Operators That Can/Cannot Be Overloaded**

``` 
┌─────────────────────────────────────────────────────────────────┐
│                 OPERATOR OVERLOADING RULES                      │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  CAN BE OVERLOADED:                                             │
│  ─────────────────                                              │
│  Arithmetic:    +  -  *  /  %                                   │
│  Comparison:    == != <  >  <= >=  <=> (C++20)                  │
│  Logical:       && || !                                         │
│  Bitwise:       &  |  ^  ~  << >>                               │
│  Assignment:    =  += -= *= /= %= &= |= ^= <<= >>=              │
│  Inc/Dec:       ++ --                                           │
│  Member Access: -> ->*                                          │
│  Subscript:     []                                              │
│  Function Call: ()                                              │
│  Comma:         ,                                               │
│  Memory:        new delete new[] delete[]                       │
│  Dereference:   *                                               │
│  Address-of:    &                                               │
│                                                                 │
│  CANNOT BE OVERLOADED:                                          │
│  ────────────────────                                           │
│  ::    (Scope resolution)                                       │
│  .     (Member access)                                          │
│  .*    (Pointer-to-member access)                               │
│  ?:    (Ternary conditional)                                    │
│  sizeof                                                         │
│  typeid                                                         │
│  alignof                                                        │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘

```
**Member vs Non-Member Overloading**
``` cpp
#include <iostream>
using namespace std;

class Number {
    int value;

public:
    Number(int v = 0) : value(v) {}

    // MEMBER function overload
    // Called as: obj1.operator+(obj2) → obj1 + obj2
    Number operator+(const Number& other) const {
        return Number(value + other.value);
    }

    // Friend declaration for non-member
    friend Number operator-(const Number& a, const Number& b);
    friend ostream& operator<<(ostream& os, const Number& n);

    int getValue() const { return value; }
};

// NON-MEMBER function overload (friend)
// Called as: operator-(a, b) → a - b
Number operator-(const Number& a, const Number& b) {
    return Number(a.value - b.value);
}

// NON-MEMBER: Required for stream operators
ostream& operator<<(ostream& os, const Number& n) {
    os << n.value;
    return os;
}

int main() {
    Number a(10), b(3);
    
    Number sum = a + b;   // Member: a.operator+(b)
    Number diff = a - b;  // Non-member: operator-(a, b)
    
    cout << "Sum: " << sum << endl;   // 13
    cout << "Diff: " << diff << endl; // 7
    
    return 0;
}
```

**When to Use Member vs Non-Member**

``` 
┌─────────────────────────────────────────────────────────────────┐
│           MEMBER vs NON-MEMBER GUIDELINES                       │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  USE MEMBER FUNCTION:                                           │
│  • Assignment operators: = += -= *= etc.                        │
│  • Subscript operator: []                                       │
│  • Function call operator: ()                                   │
│  • Member access operators: -> ->*                              │
│  • Unary operators that modify: ++ --                           │
│  • When left operand must be class object                       │
│                                                                 │
│  USE NON-MEMBER (friend) FUNCTION:                              │
│  • Stream operators: << >>                                      │
│  • Binary operators for symmetry: + - * / == !=                 │
│  • When left operand is not class type (e.g., int + MyClass)    │
│  • To allow implicit conversion on left operand                 │
│                                                                 │
│  REQUIRED AS MEMBER:                                            │
│  • = (assignment)                                               │
│  • [] (subscript)                                               │
│  • () (function call)                                           │
│  • -> (member access)                                           │
│  • type conversion operators                                    │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 2. Copy Assignment Operator
**Basic Syntax**

``` cpp
class ClassName {
public:
    ClassName& operator=(const ClassName& other);  // Declaration
};
```

**Simple Example**
``` cpp
#include <iostream>
#include <cstring>
using namespace std;

class String {
    char* data;
    size_t length;

public:
    // Constructor
    String(const char* str = "") {
        length = strlen(str);
        data = new char[length + 1];
        strcpy(data, str);
        cout << "Constructor: \"" << data << "\"" << endl;
    }

    // Copy Constructor
    String(const String& other) {
        length = other.length;
        data = new char[length + 1];
        strcpy(data, other.data);
        cout << "Copy Constructor: \"" << data << "\"" << endl;
    }

    // Copy Assignment Operator
    String& operator=(const String& other) {
        cout << "Copy Assignment: \"" << other.data << "\" to \"" << data << "\"" << endl;

        // 1. Self-assignment check
        if (this == &other) {
            return *this;
        }

        // 2. Release old resources
        delete[] data;

        // 3. Allocate new resources
        length = other.length;
        data = new char[length + 1];

        // 4. Copy data
        strcpy(data, other.data);

        // 5. Return *this for chaining
        return *this;
    }

    // Destructor
    ~String() {
        cout << "Destructor: \"" << data << "\"" << endl;
        delete[] data;
    }

    void print() const {
        cout << "String: \"" << data << "\" (length: " << length << ")" << endl;
    }
};

int main() {
    cout << "=== Creating strings ===" << endl;
    String s1("Hello");
    String s2("World");
    String s3("Test");

    cout << "\n=== Copy Assignment ===" << endl;
    s2 = s1;  // Copy assignment
    s2.print();

    cout << "\n=== Chained Assignment ===" << endl;
    s3 = s2 = s1;  // Chained assignment
    s3.print();

    cout << "\n=== Self Assignment ===" << endl;
    s1 = s1;  // Self-assignment (should be handled)
    s1.print();

    cout << "\n=== Cleanup ===" << endl;
    return 0;
}
```
**Output:**

```text

=== Creating strings ===
Constructor: "Hello"
Constructor: "World"
Constructor: "Test"

=== Copy Assignment ===
Copy Assignment: "Hello" to "World"
String: "Hello" (length: 5)

=== Chained Assignment ===
Copy Assignment: "Hello" to "Hello"
Copy Assignment: "Hello" to "Test"
String: "Hello" (length: 5)

=== Self Assignment ===
Copy Assignment: "Hello" to "Hello"
String: "Hello" (length: 5)

=== Cleanup ===
Destructor: "Hello"
Destructor: "Hello"
Destructor: "Hello"
```

**Copy-and-Swap Idiom (Exception Safe)**
``` cpp
#include <iostream>
#include <algorithm>
#include <cstring>
using namespace std;

class SafeString {
    char* data;
    size_t length;

public:
    SafeString(const char* str = "") {
        length = strlen(str);
        data = new char[length + 1];
        strcpy(data, str);
    }

    // Copy Constructor
    SafeString(const SafeString& other)
        : length(other.length)
        , data(new char[other.length + 1]) 
    {
        strcpy(data, other.data);
    }

    // Destructor
    ~SafeString() {
        delete[] data;
    }

    // Swap function (noexcept)
    void swap(SafeString& other) noexcept {
        using std::swap;
        swap(data, other.data);
        swap(length, other.length);
    }

    // Copy Assignment using Copy-and-Swap
    SafeString& operator=(SafeString other) {  // Note: pass by VALUE
        // 'other' is already a copy (copy constructor called)
        swap(other);  // Swap with the copy
        return *this;
        // 'other' (with old data) is destroyed here
    }

    void print() const {
        cout << "\"" << data << "\"" << endl;
    }
};

// Non-member swap (for STL compatibility)
void swap(SafeString& a, SafeString& b) noexcept {
    a.swap(b);
}

int main() {
    SafeString s1("Hello");
    SafeString s2("World");

    cout << "Before: ";
    s1.print();
    s2.print();

    s1 = s2;  // Copy-and-swap

    cout << "After: ";
    s1.print();
    s2.print();

    return 0;
}
```

**Visual: Copy-and-Swap**

```
═══════════════════════════════════════════════════════════════════
                    COPY-AND-SWAP IDIOM
═══════════════════════════════════════════════════════════════════

    s1 = s2;    // Assignment

    STEP 1: Parameter 'other' is COPY constructed from s2
    ┌─────────┐     ┌─────────┐     ┌─────────┐
    │   s1    │     │   s2    │     │  other  │
    │ "Hello" │     │ "World" │ ──► │ "World" │  (copy of s2)
    └─────────┘     └─────────┘     └─────────┘

    STEP 2: Swap s1's data with other's data
    ┌─────────┐     ┌─────────┐     ┌─────────┐
    │   s1    │     │   s2    │     │  other  │
    │ "World" │◄───►│ "World" │     │ "Hello" │
    └─────────┘     └─────────┘     └─────────┘
         │                               │
         └───────── SWAPPED ─────────────┘

    STEP 3: 'other' goes out of scope, destructor called
    ┌─────────┐     ┌─────────┐
    │   s1    │     │   s2    │     other destroyed
    │ "World" │     │ "World" │     (releases "Hello")
    └─────────┘     └─────────┘

    BENEFITS:
    ✓ Exception safe (copy happens first)
    ✓ Self-assignment safe (swap is always valid)
    ✓ Clean, simple code
    ✓ Reuses copy constructor logic

═══════════════════════════════════════════════════════════════════
```

### 3. Move Assignment Operator
**Basic Syntax** 

``` cpp
class ClassName {
public:
    ClassName& operator=(ClassName&& other) noexcept;  // Declaration
};
```

**Complete Example**

``` cpp
#include <iostream>
#include <utility>
#include <cstring>
using namespace std;

class Buffer {
    int* data;
    size_t size;
    string name;

public:
    // Constructor
    Buffer(size_t sz, const string& n) 
        : data(new int[sz]), size(sz), name(n) {
        for (size_t i = 0; i < size; i++) data[i] = 0;
        cout << "[" << name << "] Constructor: allocated " << size << " ints" << endl;
    }

    // Copy Constructor
    Buffer(const Buffer& other)
        : data(new int[other.size])
        , size(other.size)
        , name(other.name + "_copy")
    {
        for (size_t i = 0; i < size; i++) data[i] = other.data[i];
        cout << "[" << name << "] Copy Constructor (EXPENSIVE)" << endl;
    }

    // Move Constructor
    Buffer(Buffer&& other) noexcept
        : data(other.data)
        , size(other.size)
        , name(std::move(other.name))
    {
        other.data = nullptr;
        other.size = 0;
        cout << "[" << name << "] Move Constructor (CHEAP)" << endl;
    }

    // Copy Assignment Operator
    Buffer& operator=(const Buffer& other) {
        cout << "[" << name << "] Copy Assignment from [" << other.name << "]" << endl;

        if (this != &other) {
            // Release old resources
            delete[] data;

            // Allocate and copy
            size = other.size;
            data = new int[size];
            for (size_t i = 0; i < size; i++) data[i] = other.data[i];
            name = other.name + "_assigned";
        }
        return *this;
    }

    // Move Assignment Operator
    Buffer& operator=(Buffer&& other) noexcept {
        cout << "[" << name << "] Move Assignment from [" << other.name << "]" << endl;

        if (this != &other) {
            // Release old resources
            delete[] data;

            // Steal resources
            data = other.data;
            size = other.size;
            name = std::move(other.name);

            // Leave other in valid state
            other.data = nullptr;
            other.size = 0;
        }
        return *this;
    }

    // Destructor
    ~Buffer() {
        cout << "[" << (name.empty() ? "moved-from" : name) << "] Destructor" << endl;
        delete[] data;
    }

    void info() const {
        cout << "Buffer \"" << name << "\": size=" << size 
             << ", data=" << (data ? "valid" : "null") << endl;
    }
};

Buffer createBuffer(size_t size) {
    Buffer temp(size, "Temporary");
    return temp;
}

int main() {
    cout << "=== Creating buffers ===" << endl;
    Buffer b1(100, "Buffer1");
    Buffer b2(200, "Buffer2");

    cout << "\n=== Copy Assignment ===" << endl;
    b1 = b2;  // Copy assignment
    b1.info();
    b2.info();

    cout << "\n=== Move Assignment ===" << endl;
    Buffer b3(50, "Buffer3");
    b3 = std::move(b1);  // Move assignment
    b1.info();  // b1 is now empty
    b3.info();

    cout << "\n=== Move from temporary ===" << endl;
    Buffer b4(10, "Buffer4");
    b4 = createBuffer(500);  // Move assignment from temporary

    cout << "\n=== Cleanup ===" << endl;
    return 0;
}
```
**Output:**

``` text

=== Creating buffers ===
[Buffer1] Constructor: allocated 100 ints
[Buffer2] Constructor: allocated 200 ints

=== Copy Assignment ===
[Buffer1] Copy Assignment from [Buffer2]
Buffer "Buffer2_assigned": size=200, data=valid
Buffer "Buffer2": size=200, data=valid

=== Move Assignment ===
[Buffer3] Constructor: allocated 50 ints
[Buffer2_assigned] Move Assignment from [Buffer3]
Buffer "": size=0, data=null
Buffer "Buffer3": size=50, data=valid

=== Move from temporary ===
[Buffer4] Constructor: allocated 10 ints
[Temporary] Constructor: allocated 500 ints
[Buffer4] Move Assignment from [Temporary]
[moved-from] Destructor

=== Cleanup ===
[Temporary] Destructor
[Buffer3] Destructor
[Buffer2] Destructor
[moved-from] Destructor
```

**Unified Assignment Operator (Handles Both)**

``` cpp
#include <iostream>
#include <utility>
using namespace std;

class Unified {
    int* data;
    size_t size;

public:
    Unified(size_t sz = 0) : data(sz ? new int[sz] : nullptr), size(sz) {
        cout << "Constructor: " << size << endl;
    }

    Unified(const Unified& other) : data(new int[other.size]), size(other.size) {
        for (size_t i = 0; i < size; i++) data[i] = other.data[i];
        cout << "Copy Constructor" << endl;
    }

    Unified(Unified&& other) noexcept : data(other.data), size(other.size) {
        other.data = nullptr;
        other.size = 0;
        cout << "Move Constructor" << endl;
    }

    ~Unified() {
        delete[] data;
    }

    // Single unified assignment operator
    Unified& operator=(Unified other) noexcept {  // By value!
        cout << "Unified Assignment" << endl;
        swap(other);
        return *this;
    }

    void swap(Unified& other) noexcept {
        std::swap(data, other.data);
        std::swap(size, other.size);
    }
};

int main() {
    Unified u1(10);
    Unified u2(20);

    cout << "\n--- Assign from lvalue ---" << endl;
    u1 = u2;  // Copy constructor called for parameter, then swap

    cout << "\n--- Assign from rvalue ---" << endl;
    u1 = Unified(30);  // Move constructor called for parameter, then swap

    return 0;
}
```

**Output:**

``` text

Constructor: 10
Constructor: 20

--- Assign from lvalue ---
Copy Constructor
Unified Assignment

--- Assign from rvalue ---
Constructor: 30
Move Constructor
Unified Assignment
```

### 4. Arithmetic Operators
**Complete Arithmetic Operators Example**

``` cpp
#include <iostream>
using namespace std;

class Complex {
    double real;
    double imag;

public:
    Complex(double r = 0, double i = 0) : real(r), imag(i) {}

    // Getter methods
    double getReal() const { return real; }
    double getImag() const { return imag; }

    // ========== UNARY OPERATORS ==========

    // Unary plus (usually returns copy)
    Complex operator+() const {
        return *this;
    }

    // Unary minus (negation)
    Complex operator-() const {
        return Complex(-real, -imag);
    }

    // ========== BINARY ARITHMETIC OPERATORS ==========

    // Addition
    Complex operator+(const Complex& other) const {
        return Complex(real + other.real, imag + other.imag);
    }

    // Subtraction
    Complex operator-(const Complex& other) const {
        return Complex(real - other.real, imag - other.imag);
    }

    // Multiplication
    Complex operator*(const Complex& other) const {
        // (a+bi)(c+di) = (ac-bd) + (ad+bc)i
        return Complex(
            real * other.real - imag * other.imag,
            real * other.imag + imag * other.real
        );
    }

    // Division
    Complex operator/(const Complex& other) const {
        double denominator = other.real * other.real + other.imag * other.imag;
        return Complex(
            (real * other.real + imag * other.imag) / denominator,
            (imag * other.real - real * other.imag) / denominator
        );
    }

    // ========== COMPOUND ASSIGNMENT OPERATORS ==========

    Complex& operator+=(const Complex& other) {
        real += other.real;
        imag += other.imag;
        return *this;
    }

    Complex& operator-=(const Complex& other) {
        real -= other.real;
        imag -= other.imag;
        return *this;
    }

    Complex& operator*=(const Complex& other) {
        *this = *this * other;  // Reuse operator*
        return *this;
    }

    Complex& operator/=(const Complex& other) {
        *this = *this / other;  // Reuse operator/
        return *this;
    }

    // Friend for output
    friend ostream& operator<<(ostream& os, const Complex& c);
};

// Stream output operator
ostream& operator<<(ostream& os, const Complex& c) {
    os << c.real;
    if (c.imag >= 0) os << "+";
    os << c.imag << "i";
    return os;
}

int main() {
    Complex c1(3, 4);   // 3+4i
    Complex c2(1, 2);   // 1+2i

    cout << "c1 = " << c1 << endl;
    cout << "c2 = " << c2 << endl;

    cout << "\n=== Unary Operators ===" << endl;
    cout << "+c1 = " << +c1 << endl;
    cout << "-c1 = " << -c1 << endl;

    cout << "\n=== Binary Operators ===" << endl;
    cout << "c1 + c2 = " << (c1 + c2) << endl;
    cout << "c1 - c2 = " << (c1 - c2) << endl;
    cout << "c1 * c2 = " << (c1 * c2) << endl;
    cout << "c1 / c2 = " << (c1 / c2) << endl;

    cout << "\n=== Compound Assignment ===" << endl;
    Complex c3 = c1;
    c3 += c2;
    cout << "c3 = c1; c3 += c2: " << c3 << endl;

    c3 = c1;
    c3 *= c2;
    cout << "c3 = c1; c3 *= c2: " << c3 << endl;

    return 0;
}
```

**Output:**

```text

c1 = 3+4i
c2 = 1+2i

=== Unary Operators ===
+c1 = 3+4i
-c1 = -3-4i

=== Binary Operators ===
c1 + c2 = 4+6i
c1 - c2 = 2+2i
c1 * c2 = -5+10i
c1 / c2 = 2.2+0.4i

=== Compound Assignment ===
c3 = c1; c3 += c2: 4+6i
c3 = c1; c3 *= c2: -5+10i
```

**Mixed Type Arithmetic**

``` cpp
#include <iostream>
using namespace std;

class Fraction {
    int numerator;
    int denominator;

    // Helper: GCD for simplification
    static int gcd(int a, int b) {
        a = abs(a);
        b = abs(b);
        while (b) {
            int t = b;
            b = a % b;
            a = t;
        }
        return a;
    }

    void simplify() {
        int g = gcd(numerator, denominator);
        numerator /= g;
        denominator /= g;
        if (denominator < 0) {
            numerator = -numerator;
            denominator = -denominator;
        }
    }

public:
    Fraction(int num = 0, int den = 1) : numerator(num), denominator(den) {
        simplify();
    }

    // Fraction + Fraction
    Fraction operator+(const Fraction& other) const {
        return Fraction(
            numerator * other.denominator + other.numerator * denominator,
            denominator * other.denominator
        );
    }

    // Fraction + int (member function)
    Fraction operator+(int value) const {
        return *this + Fraction(value);
    }

    // Fraction * Fraction
    Fraction operator*(const Fraction& other) const {
        return Fraction(
            numerator * other.numerator,
            denominator * other.denominator
        );
    }

    // Friend: int + Fraction (non-member for left-side int)
    friend Fraction operator+(int value, const Fraction& f);

    // Friend: int * Fraction
    friend Fraction operator*(int value, const Fraction& f);

    // Stream output
    friend ostream& operator<<(ostream& os, const Fraction& f);
};

// Non-member operators for symmetry
Fraction operator+(int value, const Fraction& f) {
    return f + value;  // Reuse member operator
}

Fraction operator*(int value, const Fraction& f) {
    return Fraction(value) * f;
}

ostream& operator<<(ostream& os, const Fraction& f) {
    os << f.numerator << "/" << f.denominator;
    return os;
}

int main() {
    Fraction f1(1, 2);  // 1/2
    Fraction f2(2, 3);  // 2/3

    cout << "f1 = " << f1 << endl;
    cout << "f2 = " << f2 << endl;

    cout << "\n=== Fraction + Fraction ===" << endl;
    cout << "f1 + f2 = " << (f1 + f2) << endl;

    cout << "\n=== Fraction + int ===" << endl;
    cout << "f1 + 2 = " << (f1 + 2) << endl;

    cout << "\n=== int + Fraction ===" << endl;
    cout << "3 + f1 = " << (3 + f1) << endl;

    cout << "\n=== Mixed multiplication ===" << endl;
    cout << "f1 * f2 = " << (f1 * f2) << endl;
    cout << "2 * f1 = " << (2 * f1) << endl;

    return 0;
}
```

**Output:**  

```text

f1 = 1/2
f2 = 2/3

=== Fraction + Fraction ===
f1 + f2 = 7/6

=== Fraction + int ===
f1 + 2 = 5/2

=== int + Fraction ===
3 + f1 = 7/2

=== Mixed multiplication ===
f1 * f2 = 1/3
2 * f1 = 1/1
```


### 5. Comparison Operators
**Pre-C++20 Approach**

``` cpp
#include <iostream>
#include <string>
using namespace std;

class Person {
    string name;
    int age;

public:
    Person(const string& n, int a) : name(n), age(a) {}

    // Equality operators
    bool operator==(const Person& other) const {
        return name == other.name && age == other.age;
    }

    bool operator!=(const Person& other) const {
        return !(*this == other);  // Reuse operator==
    }

    // Relational operators (compare by age)
    bool operator<(const Person& other) const {
        return age < other.age;
    }

    bool operator>(const Person& other) const {
        return other < *this;  // Reuse operator<
    }

    bool operator<=(const Person& other) const {
        return !(other < *this);  // Reuse operator<
    }

    bool operator>=(const Person& other) const {
        return !(*this < other);  // Reuse operator<
    }

    friend ostream& operator<<(ostream& os, const Person& p);
};

ostream& operator<<(ostream& os, const Person& p) {
    os << p.name << " (age " << p.age << ")";
    return os;
}

int main() {
    Person alice("Alice", 30);
    Person bob("Bob", 25);
    Person charlie("Charlie", 30);
    Person alice2("Alice", 30);

    cout << alice << endl;
    cout << bob << endl;

    cout << "\n=== Equality ===" << endl;
    cout << "alice == alice2: " << boolalpha << (alice == alice2) << endl;
    cout << "alice == bob: " << (alice == bob) << endl;
    cout << "alice != bob: " << (alice != bob) << endl;

    cout << "\n=== Comparison ===" << endl;
    cout << "alice < bob: " << (alice < bob) << endl;
    cout << "alice > bob: " << (alice > bob) << endl;
    cout << "alice <= charlie: " << (alice <= charlie) << endl;

    return 0;
}
```

**C++20 Spaceship Operator**

``` cpp

#include <iostream>
#include <compare>
#include <string>
using namespace std;

class Version {
    int major;
    int minor;
    int patch;

public:
    Version(int ma, int mi, int pa) : major(ma), minor(mi), patch(pa) {}

    // Spaceship operator - generates all comparison operators!
    auto operator<=>(const Version& other) const = default;

    // Equality is also generated by default with <=>
    bool operator==(const Version& other) const = default;

    friend ostream& operator<<(ostream& os, const Version& v) {
        os << v.major << "." << v.minor << "." << v.patch;
        return os;
    }
};

class Product {
    string name;
    Version version;
    double price;

public:
    Product(const string& n, Version v, double p) 
        : name(n), version(v), price(p) {}

    // Custom spaceship operator
    auto operator<=>(const Product& other) const {
        // First compare by name
        if (auto cmp = name <=> other.name; cmp != 0) return cmp;
        // Then by version
        if (auto cmp = version <=> other.version; cmp != 0) return cmp;
        // Finally by price
        return price <=> other.price;
    }

    bool operator==(const Product& other) const = default;

    friend ostream& operator<<(ostream& os, const Product& p) {
        os << p.name << " v" << p.version << " ($" << p.price << ")";
        return os;
    }
};

int main() {
    Version v1(1, 0, 0);
    Version v2(1, 2, 0);
    Version v3(2, 0, 0);

    cout << "=== Version Comparison ===" << endl;
    cout << v1 << " < " << v2 << ": " << boolalpha << (v1 < v2) << endl;
    cout << v1 << " > " << v2 << ": " << (v1 > v2) << endl;
    cout << v1 << " == " << v2 << ": " << (v1 == v2) << endl;
    cout << v2 << " <= " << v3 << ": " << (v2 <= v3) << endl;

    cout << "\n=== Product Comparison ===" << endl;
    Product p1("App", Version(1, 0, 0), 9.99);
    Product p2("App", Version(2, 0, 0), 14.99);
    Product p3("Zapp", Version(1, 0, 0), 4.99);

    cout << p1 << endl;
    cout << p2 << endl;
    cout << p1 << " < " << p2 << ": " << (p1 < p2) << endl;
    cout << p1 << " < " << p3 << ": " << (p1 < p3) << endl;

    return 0;
}
```
**Spaceship Operator Categories**

``` 
┌─────────────────────────────────────────────────────────────────┐
│                 C++20 COMPARISON CATEGORIES                     │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  std::strong_ordering                                           │
│  ────────────────────                                           │
│  • Total ordering: every pair is comparable                     │
│  • Equal means substitutable                                    │
│  • Values: less, equal, greater                                 │
│  • Example: integers, strings                                   │
│                                                                 │
│  std::weak_ordering                                             │
│  ──────────────────                                             │
│  • Total ordering: every pair is comparable                     │
│  • Equivalent values may not be substitutable                   │
│  • Values: less, equivalent, greater                            │
│  • Example: case-insensitive strings                            │
│                                                                 │
│  std::partial_ordering                                          │
│  ─────────────────────                                          │
│  • Some pairs may be incomparable                               │
│  • Values: less, equivalent, greater, unordered                 │
│  • Example: floating-point (NaN != NaN)                         │
│                                                                 │
│  WHAT <=> GENERATES:                                            │
│  • operator<                                                    │
│  • operator>                                                    │
│  • operator<=                                                   │
│  • operator>=                                                   │
│  • operator== (if defaulted)                                    │
│  • operator!= (via ==)                                          │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 6. Increment & Decrement Operators
**Prefix vs Postfix**

``` cpp
#include <iostream>
using namespace std;

class Counter {
    int value;

public:
    Counter(int v = 0) : value(v) {}

    // Pre-increment: ++counter
    // Returns reference to modified object
    Counter& operator++() {
        ++value;
        cout << "Pre-increment: now " << value << endl;
        return *this;
    }

    // Post-increment: counter++
    // Returns copy of original, then modifies
    // int parameter is dummy to distinguish from prefix
    Counter operator++(int) {
        Counter temp = *this;  // Save current state
        ++value;
        cout << "Post-increment: was " << temp.value << ", now " << value << endl;
        return temp;  // Return old value
    }

    // Pre-decrement: --counter
    Counter& operator--() {
        --value;
        cout << "Pre-decrement: now " << value << endl;
        return *this;
    }

    // Post-decrement: counter--
    Counter operator--(int) {
        Counter temp = *this;
        --value;
        cout << "Post-decrement: was " << temp.value << ", now " << value << endl;
        return temp;
    }

    int get() const { return value; }

    friend ostream& operator<<(ostream& os, const Counter& c) {
        os << c.value;
        return os;
    }
};

int main() {
    Counter c(5);
    cout << "Initial: " << c << endl;

    cout << "\n=== Pre-increment ===" << endl;
    Counter result1 = ++c;  // c becomes 6, result1 is 6
    cout << "Result: " << result1 << ", c: " << c << endl;

    cout << "\n=== Post-increment ===" << endl;
    Counter result2 = c++;  // c becomes 7, result2 is 6
    cout << "Result: " << result2 << ", c: " << c << endl;

    cout << "\n=== Chained pre-increment ===" << endl;
    ++++c;  // Equivalent to ++(++c)
    cout << "After ++++c: " << c << endl;

    cout << "\n=== Pre-decrement ===" << endl;
    --c;
    cout << "After --c: " << c << endl;

    return 0;
}
```
**Output:**

```text

Initial: 5

=== Pre-increment ===
Pre-increment: now 6
Result: 6, c: 6

=== Post-increment ===
Post-increment: was 6, now 7
Result: 6, c: 7

=== Chained pre-increment ===
Pre-increment: now 8
Pre-increment: now 9
After ++++c: 9

=== Pre-decrement ===
Pre-decrement: now 8
After --c: 8

```

**Iterator-like Example**

``` cpp
#include <iostream>
using namespace std;

class IntRange {
    int current;
    int end;

public:
    IntRange(int start, int finish) : current(start), end(finish) {}

    // For range-based for loop support
    IntRange& begin() { return *this; }
    IntRange end_sentinel() const { return IntRange(end, end); }

    // Dereference
    int operator*() const { return current; }

    // Pre-increment for iteration
    IntRange& operator++() {
        ++current;
        return *this;
    }

    // Comparison for loop termination
    bool operator!=(const IntRange& other) const {
        return current != other.current;
    }
};

// Custom iterator class
class ArrayIterator {
    int* ptr;

public:
    ArrayIterator(int* p) : ptr(p) {}

    int& operator*() { return *ptr; }
    const int& operator*() const { return *ptr; }

    ArrayIterator& operator++() { ++ptr; return *this; }
    ArrayIterator operator++(int) { ArrayIterator tmp = *this; ++ptr; return tmp; }

    ArrayIterator& operator--() { --ptr; return *this; }
    ArrayIterator operator--(int) { ArrayIterator tmp = *this; --ptr; return tmp; }

    bool operator==(const ArrayIterator& other) const { return ptr == other.ptr; }
    bool operator!=(const ArrayIterator& other) const { return ptr != other.ptr; }
};

int main() {
    cout << "=== IntRange iteration ===" << endl;
    IntRange range(1, 6);
    for (auto it = range.begin(); it != range.end_sentinel(); ++it) {
        cout << *it << " ";
    }
    cout << endl;

    cout << "\n=== ArrayIterator ===" << endl;
    int arr[] = {10, 20, 30, 40, 50};
    ArrayIterator begin(arr);
    ArrayIterator end(arr + 5);

    cout << "Forward: ";
    for (ArrayIterator it = begin; it != end; ++it) {
        cout << *it << " ";
    }
    cout << endl;

    return 0;
}
```
**Prefix vs Postfix Summary**

``` 
┌─────────────────────────────────────────────────────────────────┐
│              PREFIX vs POSTFIX OPERATORS                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  PREFIX (++x, --x):                                             │
│  ─────────────────                                              │
│  • Signature: T& operator++()                                   │
│  • Modifies, then returns reference                             │
│  • More efficient (no copy)                                     │
│  • Can be chained: ++++x                                        │
│                                                                 │
│  POSTFIX (x++, x--):                                            │
│  ──────────────────                                             │
│  • Signature: T operator++(int)  // dummy int parameter         │
│  • Saves copy, modifies, returns copy                           │
│  • Less efficient (creates temporary)                           │
│  • Cannot be meaningfully chained                               │
│                                                                 │
│  PREFERENCE:                                                    │
│  • Use prefix when you don't need the old value                 │
│  • Use postfix only when old value is needed                    │
│                                                                 │
│  IMPLEMENTATION TIP:                                            │
│  • Implement postfix in terms of prefix                         │
│    T operator++(int) {                                          │
│        T temp = *this;                                          │
│        ++(*this);  // Use prefix                                │
│        return temp;                                             │
│    }                                                            │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 7. Subscript Operator
**Basic Array Class**

``` cpp
#include <iostream>
#include <stdexcept>
using namespace std;

class Array {
    int* data;
    size_t size;

public:
    Array(size_t sz) : size(sz), data(new int[sz]) {
        for (size_t i = 0; i < size; i++) data[i] = 0;
    }

    ~Array() { delete[] data; }

    // Non-const subscript operator (read/write)
    int& operator[](size_t index) {
        if (index >= size) {
            throw out_of_range("Index out of bounds");
        }
        return data[index];
    }

    // Const subscript operator (read-only)
    const int& operator[](size_t index) const {
        if (index >= size) {
            throw out_of_range("Index out of bounds");
        }
        return data[index];
    }

    size_t length() const { return size; }
};

void printArray(const Array& arr) {  // Takes const reference
    cout << "[ ";
    for (size_t i = 0; i < arr.length(); i++) {
        cout << arr[i] << " ";  // Uses const operator[]
    }
    cout << "]" << endl;
}

int main() {
    Array arr(5);

    // Write using non-const operator[]
    for (size_t i = 0; i < arr.length(); i++) {
        arr[i] = (i + 1) * 10;
    }

    // Read using const operator[]
    printArray(arr);

    // Modify single element
    arr[2] = 999;
    printArray(arr);

    // Bounds checking
    try {
        cout << arr[10] << endl;
    } catch (const out_of_range& e) {
        cout << "Exception: " << e.what() << endl;
    }

    return 0;
}
```

**Output:**

```text

[ 10 20 30 40 50 ]
[ 10 20 999 40 50 ]
Exception: Index out of bounds
```

**Multi-dimensional Subscript**

``` cpp
#include <iostream>
#include <vector>
using namespace std;

class Matrix {
    vector<vector<double>> data;
    size_t rows, cols;

public:
    Matrix(size_t r, size_t c, double init = 0.0)
        : rows(r), cols(c), data(r, vector<double>(c, init)) {}

    // Proxy class for second subscript
    class RowProxy {
        vector<double>& row;
    public:
        RowProxy(vector<double>& r) : row(r) {}
        
        double& operator[](size_t col) { return row[col]; }
        const double& operator[](size_t col) const { return row[col]; }
    };

    class ConstRowProxy {
        const vector<double>& row;
    public:
        ConstRowProxy(const vector<double>& r) : row(r) {}
        
        const double& operator[](size_t col) const { return row[col]; }
    };

    // First subscript returns proxy
    RowProxy operator[](size_t row) {
        return RowProxy(data[row]);
    }

    ConstRowProxy operator[](size_t row) const {
        return ConstRowProxy(data[row]);
    }

    // Alternative: operator() for multi-dimensional
    double& operator()(size_t row, size_t col) {
        return data[row][col];
    }

    const double& operator()(size_t row, size_t col) const {
        return data[row][col];
    }

    void print() const {
        for (size_t i = 0; i < rows; i++) {
            for (size_t j = 0; j < cols; j++) {
                cout << data[i][j] << "\t";
            }
            cout << endl;
        }
    }
};

int main() {
    Matrix m(3, 4);

    // Using double subscript
    m[0][0] = 1.0;
    m[1][1] = 2.0;
    m[2][2] = 3.0;

    // Using function call operator
    m(0, 3) = 4.0;
    m(2, 0) = 5.0;

    cout << "Matrix:" << endl;
    m.print();

    cout << "\nm[1][1] = " << m[1][1] << endl;
    cout << "m(2, 2) = " << m(2, 2) << endl;

    return 0;
}
```
**Output:**

```text

Matrix:
1	0	0	4	
0	2	0	0	
5	0	3	0	

m[1][1] = 2
m(2, 2) = 3
```
**C++23 Multidimensional Subscript**

``` cpp
// C++23 feature - direct multidimensional subscript
#if __cplusplus >= 202302L

class Matrix23 {
    vector<double> data;
    size_t rows, cols;

public:
    Matrix23(size_t r, size_t c) : rows(r), cols(c), data(r * c) {}

    // C++23: Multiple parameters in operator[]
    double& operator[](size_t row, size_t col) {
        return data[row * cols + col];
    }

    const double& operator[](size_t row, size_t col) const {
        return data[row * cols + col];
    }
};

// Usage:
// Matrix23 m(3, 4);
// m[1, 2] = 5.0;  // Direct multi-dimensional indexing!

#endif
```

### 8. Function Call Operator
**Functor (Function Object)**

``` cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

// Functor for adding a constant
class Adder {
    int value;

public:
    Adder(int v) : value(v) {}

    int operator()(int x) const {
        return x + value;
    }
};

// Functor for multiplication
class Multiplier {
    double factor;

public:
    Multiplier(double f) : factor(f) {}

    double operator()(double x) const {
        return x * factor;
    }
};

// Functor with state
class Counter {
    int count;

public:
    Counter() : count(0) {}

    void operator()(int) {
        ++count;
    }

    int getCount() const { return count; }
};

// Predicate functor
class InRange {
    int low, high;

public:
    InRange(int l, int h) : low(l), high(h) {}

    bool operator()(int x) const {
        return x >= low && x <= high;
    }
};

int main() {
    cout << "=== Basic Functor ===" << endl;
    Adder add5(5);
    cout << "add5(10) = " << add5(10) << endl;
    cout << "add5(20) = " << add5(20) << endl;

    Multiplier times2(2.0);
    cout << "times2(3.5) = " << times2(3.5) << endl;

    cout << "\n=== With STL Algorithms ===" << endl;
    vector<int> nums = {1, 2, 3, 4, 5};

    cout << "Original: ";
    for (int n : nums) cout << n << " ";
    cout << endl;

    // Transform with functor
    vector<int> result(nums.size());
    transform(nums.begin(), nums.end(), result.begin(), Adder(10));

    cout << "After Adder(10): ";
    for (int n : result) cout << n << " ";
    cout << endl;

    cout << "\n=== Stateful Functor ===" << endl;
    Counter counter;
    counter = for_each(nums.begin(), nums.end(), counter);
    cout << "Counted " << counter.getCount() << " elements" << endl;

    cout << "\n=== Predicate Functor ===" << endl;
    InRange between5and15(5, 15);
    vector<int> values = {3, 7, 12, 18, 5, 15, 2};

    cout << "Values in range [5, 15]: ";
    for (int v : values) {
        if (between5and15(v)) {
            cout << v << " ";
        }
    }
    cout << endl;

    // Count with predicate
    int count = count_if(values.begin(), values.end(), InRange(5, 15));
    cout << "Count: " << count << endl;

    return 0;
}
```

**Output:**

```text

=== Basic Functor ===
add5(10) = 15
add5(20) = 25
times2(3.5) = 7

=== With STL Algorithms ===
Original: 1 2 3 4 5 
After Adder(10): 11 12 13 14 15 

=== Stateful Functor ===
Counted 5 elements

=== Predicate Functor ===
Values in range [5, 15]: 7 12 5 15 
Count: 4
```

**Advanced Functor Examples**
``` cpp
#include <iostream>
#include <string>
#include <map>
using namespace std;

// Polynomial evaluator
class Polynomial {
    vector<double> coefficients;  // coefficients[i] = coefficient of x^i

public:
    Polynomial(initializer_list<double> coeffs) : coefficients(coeffs) {}

    // Evaluate polynomial at x
    double operator()(double x) const {
        double result = 0;
        double power = 1;
        for (double coef : coefficients) {
            result += coef * power;
            power *= x;
        }
        return result;
    }
};

// Memoizing functor
class Fibonacci {
    mutable map<int, long long> cache;

public:
    long long operator()(int n) const {
        if (n <= 1) return n;

        auto it = cache.find(n);
        if (it != cache.end()) {
            return it->second;
        }

        long long result = (*this)(n - 1) + (*this)(n - 2);
        cache[n] = result;
        return result;
    }
};

// String formatter
class Formatter {
    string prefix;
    string suffix;

public:
    Formatter(const string& pre, const string& suf) 
        : prefix(pre), suffix(suf) {}

    string operator()(const string& text) const {
        return prefix + text + suffix;
    }
};

// Multiple overloads
class Printer {
public:
    void operator()(int x) const {
        cout << "Integer: " << x << endl;
    }

    void operator()(double x) const {
        cout << "Double: " << x << endl;
    }

    void operator()(const string& x) const {
        cout << "String: \"" << x << "\"" << endl;
    }

    template<typename T>
    void operator()(const vector<T>& v) const {
        cout << "Vector: [ ";
        for (const auto& item : v) cout << item << " ";
        cout << "]" << endl;
    }
};

int main() {
    cout << "=== Polynomial ===" << endl;
    // 2 + 3x + x^2
    Polynomial poly({2, 3, 1});
    cout << "p(0) = " << poly(0) << endl;
    cout << "p(2) = " << poly(2) << endl;  // 2 + 6 + 4 = 12
    cout << "p(3) = " << poly(3) << endl;  // 2 + 9 + 9 = 20

    cout << "\n=== Memoized Fibonacci ===" << endl;
    Fibonacci fib;
    cout << "fib(10) = " << fib(10) << endl;
    cout << "fib(20) = " << fib(20) << endl;
    cout << "fib(40) = " << fib(40) << endl;  // Fast due to memoization

    cout << "\n=== String Formatter ===" << endl;
    Formatter html("<p>", "</p>");
    Formatter quote("\"", "\"");
    cout << html("Hello, World!") << endl;
    cout << quote("quoted text") << endl;

    cout << "\n=== Overloaded Printer ===" << endl;
    Printer print;
    print(42);
    print(3.14159);
    print("Hello");
    print(vector<int>{1, 2, 3, 4, 5});

    return 0;
}
```

**Output:**

```text

=== Polynomial ===
p(0) = 2
p(2) = 12
p(3) = 20

=== Memoized Fibonacci ===
fib(10) = 55
fib(20) = 6765
fib(40) = 102334155

=== String Formatter ===
<p>Hello, World!</p>
"quoted text"

=== Overloaded Printer ===
Integer: 42
Double: 3.14159
String: "Hello"
Vector: [ 1 2 3 4 5 ]
```
**Comparison: Functor vs Lambda**
``` cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

// Functor approach
class MultiplyBy {
    int factor;
public:
    MultiplyBy(int f) : factor(f) {}
    int operator()(int x) const { return x * factor; }
};

int main() {
    vector<int> nums = {1, 2, 3, 4, 5};
    vector<int> result(nums.size());
    int factor = 3;

    // Using functor
    transform(nums.begin(), nums.end(), result.begin(), MultiplyBy(factor));
    cout << "Functor result: ";
    for (int n : result) cout << n << " ";
    cout << endl;

    // Using lambda (C++11+) - often simpler
    transform(nums.begin(), nums.end(), result.begin(), 
              [factor](int x) { return x * factor; });
    cout << "Lambda result: ";
    for (int n : result) cout << n << " ";
    cout << endl;

    return 0;
}
```

### 9. Stream Operators
**Output Stream Operator (<<)**

``` cpp
#include <iostream>
#include <iomanip>
#include <sstream>
using namespace std;

class Date {
    int year, month, day;

public:
    Date(int y, int m, int d) : year(y), month(m), day(d) {}

    // Stream output - MUST be non-member (friend)
    friend ostream& operator<<(ostream& os, const Date& date);

    // Stream input - MUST be non-member (friend)
    friend istream& operator>>(istream& is, Date& date);
};

// Output: Date in YYYY-MM-DD format
ostream& operator<<(ostream& os, const Date& date) {
    os << date.year << "-"
       << setw(2) << setfill('0') << date.month << "-"
       << setw(2) << setfill('0') << date.day;
    return os;
}

// Input: Expect YYYY-MM-DD format
istream& operator>>(istream& is, Date& date) {
    char sep1, sep2;
    is >> date.year >> sep1 >> date.month >> sep2 >> date.day;
    
    if (sep1 != '-' || sep2 != '-') {
        is.setstate(ios::failbit);
    }
    return is;
}

int main() {
    Date d1(2024, 1, 15);
    Date d2(2024, 12, 25);

    cout << "=== Output Operator ===" << endl;
    cout << "Date 1: " << d1 << endl;
    cout << "Date 2: " << d2 << endl;

    cout << "\n=== Chained Output ===" << endl;
    cout << "Dates: " << d1 << " and " << d2 << endl;

    cout << "\n=== Input Operator ===" << endl;
    Date d3(0, 0, 0);
    cout << "Enter date (YYYY-MM-DD): ";
    
    // Simulate input with stringstream
    stringstream ss("2024-06-20");
    if (ss >> d3) {
        cout << "You entered: " << d3 << endl;
    } else {
        cout << "Invalid format!" << endl;
    }

    return 0;
}
```

**Complete Example with Multiple Formats**

``` cpp
#include <iostream>
#include <iomanip>
#include <string>
using namespace std;

class Money {
    long cents;  // Store as cents to avoid floating point issues

public:
    Money(long dollars = 0, int cents = 0) : cents(dollars * 100 + cents) {}
    Money(double amount) : cents(static_cast<long>(amount * 100 + 0.5)) {}

    // Arithmetic
    Money operator+(const Money& other) const {
        Money result;
        result.cents = cents + other.cents;
        return result;
    }

    Money operator-(const Money& other) const {
        Money result;
        result.cents = cents - other.cents;
        return result;
    }

    Money operator*(double factor) const {
        Money result;
        result.cents = static_cast<long>(cents * factor);
        return result;
    }

    // Comparison
    bool operator<(const Money& other) const { return cents < other.cents; }
    bool operator==(const Money& other) const { return cents == other.cents; }

    // Stream operators
    friend ostream& operator<<(ostream& os, const Money& m);
    friend istream& operator>>(istream& is, Money& m);
};

ostream& operator<<(ostream& os, const Money& m) {
    bool negative = m.cents < 0;
    long absCents = negative ? -m.cents : m.cents;
    
    os << (negative ? "-$" : "$")
       << absCents / 100 << "."
       << setw(2) << setfill('0') << absCents % 100;
    return os;
}

istream& operator>>(istream& is, Money& m) {
    char dollar;
    double amount;
    
    is >> dollar >> amount;
    
    if (dollar != '$') {
        is.setstate(ios::failbit);
        return is;
    }
    
    m.cents = static_cast<long>(amount * 100 + 0.5);
    return is;
}

class Person {
    string firstName;
    string lastName;
    int age;
    Money salary;

public:
    Person(const string& fn, const string& ln, int a, Money s)
        : firstName(fn), lastName(ln), age(a), salary(s) {}

    friend ostream& operator<<(ostream& os, const Person& p);
    friend istream& operator>>(istream& is, Person& p);
};

ostream& operator<<(ostream& os, const Person& p) {
    os << "Person {\n"
       << "  Name: " << p.firstName << " " << p.lastName << "\n"
       << "  Age: " << p.age << "\n"
       << "  Salary: " << p.salary << "\n"
       << "}";
    return os;
}

istream& operator>>(istream& is, Person& p) {
    is >> p.firstName >> p.lastName >> p.age >> p.salary;
    return is;
}

int main() {
    cout << "=== Money ===" << endl;
    Money m1(100, 50);      // $100.50
    Money m2(75.25);        // $75.25
    Money m3 = m1 + m2;
    Money m4 = m1 * 1.5;

    cout << "m1 = " << m1 << endl;
    cout << "m2 = " << m2 << endl;
    cout << "m1 + m2 = " << m3 << endl;
    cout << "m1 * 1.5 = " << m4 << endl;

    cout << "\n=== Person ===" << endl;
    Person p("John", "Doe", 30, Money(75000));
    cout << p << endl;

    cout << "\n=== Reading Person ===" << endl;
    // Simulate input
    stringstream ss("Jane Smith 25 $85000.00");
    Person p2("", "", 0, Money(0));
    if (ss >> p2) {
        cout << p2 << endl;
    }

    return 0;
}
```

**Output:**

```text

=== Money ===
m1 = $100.50
m2 = $75.25
m1 + m2 = $175.75
m1 * 1.5 = $150.75

=== Person ===
Person {
  Name: John Doe
  Age: 30
  Salary: $75000.00
}

=== Reading Person ===
Person {
  Name: Jane Smith
  Age: 25
  Salary: $85000.00
}
```

### 10. Conversion Operators
**Implicit and Explicit Conversions**

``` cpp
#include <iostream>
#include <string>
using namespace std;

class Fraction {
    int numerator;
    int denominator;

public:
    Fraction(int num = 0, int den = 1) : numerator(num), denominator(den) {}

    // Conversion to double (explicit to prevent accidents)
    explicit operator double() const {
        return static_cast<double>(numerator) / denominator;
    }

    // Conversion to bool (typically explicit)
    explicit operator bool() const {
        return numerator != 0;
    }

    // Conversion to string
    operator string() const {
        return to_string(numerator) + "/" + to_string(denominator);
    }

    friend ostream& operator<<(ostream& os, const Fraction& f) {
        os << f.numerator << "/" << f.denominator;
        return os;
    }
};

class SmartInt {
    int value;

public:
    SmartInt(int v = 0) : value(v) {}

    // Implicit conversion to int
    operator int() const {
        cout << "(converting to int)" << endl;
        return value;
    }
};

class SafeInt {
    int value;

public:
    SafeInt(int v = 0) : value(v) {}

    // Explicit conversion only
    explicit operator int() const {
        return value;
    }

    // For use in boolean contexts (if, while, etc.)
    explicit operator bool() const {
        return value != 0;
    }
};

int main() {
    cout << "=== Fraction Conversions ===" << endl;
    Fraction f(3, 4);

    // Explicit conversion to double
    double d = static_cast<double>(f);  // Required due to explicit
    // double d2 = f;  // ERROR: explicit conversion required
    cout << "Fraction " << f << " as double: " << d << endl;

    // Implicit conversion to string (allowed)
    string s = f;
    cout << "Fraction as string: " << s << endl;

    // Explicit conversion to bool in conditions
    if (f) {  // Allowed in boolean context even if explicit
        cout << "Fraction is non-zero" << endl;
    }

    Fraction zero(0, 1);
    if (!zero) {
        cout << "Zero fraction is falsy" << endl;
    }

    cout << "\n=== SmartInt (Implicit) ===" << endl;
    SmartInt si(42);
    int x = si;  // Implicit conversion
    cout << "Value: " << x << endl;
    cout << "si + 10 = " << (si + 10) << endl;  // Implicit conversion

    cout << "\n=== SafeInt (Explicit) ===" << endl;
    SafeInt safe(100);
    // int y = safe;  // ERROR: explicit required
    int y = static_cast<int>(safe);  // OK
    cout << "Value: " << y << endl;

    // Boolean context still works
    if (safe) {
        cout << "SafeInt is non-zero" << endl;
    }

    return 0;
}
```

**Output:**

```text

=== Fraction Conversions ===
Fraction 3/4 as double: 0.75
Fraction as string: 3/4
Fraction is non-zero
Zero fraction is falsy

=== SmartInt (Implicit) ===
(converting to int)
Value: 42
(converting to int)
si + 10 = 52

=== SafeInt (Explicit) ===
Value: 100
SafeInt is non-zero
```

**Smart Pointer Conversion Example**
``` cpp
#include <iostream>
using namespace std;

template<typename T>
class SmartPtr {
    T* ptr;

public:
    explicit SmartPtr(T* p = nullptr) : ptr(p) {}

    ~SmartPtr() { delete ptr; }

    // Prevent copying
    SmartPtr(const SmartPtr&) = delete;
    SmartPtr& operator=(const SmartPtr&) = delete;

    // Allow moving
    SmartPtr(SmartPtr&& other) noexcept : ptr(other.ptr) {
        other.ptr = nullptr;
    }

    SmartPtr& operator=(SmartPtr&& other) noexcept {
        if (this != &other) {
            delete ptr;
            ptr = other.ptr;
            other.ptr = nullptr;
        }
        return *this;
    }

    // Conversion to bool for null checking
    explicit operator bool() const {
        return ptr != nullptr;
    }

    // Dereference operators
    T& operator*() const { return *ptr; }
    T* operator->() const { return ptr; }

    // Get raw pointer
    T* get() const { return ptr; }
};

class Resource {
public:
    int value;
    Resource(int v) : value(v) {
        cout << "Resource(" << value << ") created" << endl;
    }
    ~Resource() {
        cout << "Resource(" << value << ") destroyed" << endl;
    }
};

int main() {
    SmartPtr<Resource> ptr1(new Resource(42));

    if (ptr1) {  // Uses operator bool()
        cout << "ptr1 is valid, value = " << ptr1->value << endl;
    }

    SmartPtr<Resource> ptr2;  // nullptr

    if (!ptr2) {
        cout << "ptr2 is null" << endl;
    }

    // Move ptr1 to ptr3
    SmartPtr<Resource> ptr3 = std::move(ptr1);

    if (!ptr1) {
        cout << "ptr1 is now null after move" << endl;
    }

    if (ptr3) {
        cout << "ptr3 has the resource: " << (*ptr3).value << endl;
    }

    return 0;
}
```
### 11. Smart Pointer Operators
**Complete Smart Pointer Implementation**

``` cpp
#include <iostream>
#include <utility>
using namespace std;

template<typename T>
class UniquePtr {
    T* ptr;

public:
    // Constructors
    explicit UniquePtr(T* p = nullptr) : ptr(p) {}

    // Destructor
    ~UniquePtr() {
        delete ptr;
    }

    // No copying
    UniquePtr(const UniquePtr&) = delete;
    UniquePtr& operator=(const UniquePtr&) = delete;

    // Move operations
    UniquePtr(UniquePtr&& other) noexcept : ptr(other.ptr) {
        other.ptr = nullptr;
    }

    UniquePtr& operator=(UniquePtr&& other) noexcept {
        if (this != &other) {
            delete ptr;
            ptr = other.ptr;
            other.ptr = nullptr;
        }
        return *this;
    }

    // ========== SMART POINTER OPERATORS ==========

    // Dereference operator
    T& operator*() const {
        return *ptr;
    }

    // Arrow operator (member access)
    T* operator->() const {
        return ptr;
    }

    // Boolean conversion
    explicit operator bool() const {
        return ptr != nullptr;
    }

    // Subscript for array-like access (if T is array)
    T& operator[](size_t index) const {
        return ptr[index];
    }

    // ========== UTILITY METHODS ==========

    T* get() const { return ptr; }

    T* release() {
        T* temp = ptr;
        ptr = nullptr;
        return temp;
    }

    void reset(T* p = nullptr) {
        delete ptr;
        ptr = p;
    }

    void swap(UniquePtr& other) noexcept {
        std::swap(ptr, other.ptr);
    }
};

// Factory function
template<typename T, typename... Args>
UniquePtr<T> makeUnique(Args&&... args) {
    return UniquePtr<T>(new T(std::forward<Args>(args)...));
}

class Widget {
public:
    int x, y;
    string name;

    Widget(int x, int y, const string& n) : x(x), y(y), name(n) {
        cout << "Widget \"" << name << "\" created" << endl;
    }

    ~Widget() {
        cout << "Widget \"" << name << "\" destroyed" << endl;
    }

    void display() const {
        cout << "Widget: " << name << " at (" << x << ", " << y << ")" << endl;
    }
};

int main() {
    cout << "=== Creating UniquePtr ===" << endl;
    UniquePtr<Widget> w1 = makeUnique<Widget>(10, 20, "First");

    cout << "\n=== Using operator-> ===" << endl;
    w1->display();
    cout << "Name via ->: " << w1->name << endl;

    cout << "\n=== Using operator* ===" << endl;
    (*w1).x = 100;
    (*w1).display();

    cout << "\n=== Using operator bool ===" << endl;
    if (w1) {
        cout << "w1 is valid" << endl;
    }

    cout << "\n=== Moving ownership ===" << endl;
    UniquePtr<Widget> w2 = std::move(w1);

    if (!w1) {
        cout << "w1 is now null" << endl;
    }
    if (w2) {
        cout << "w2 owns the widget: " << w2->name << endl;
    }

    cout << "\n=== Array-like UniquePtr ===" << endl;
    UniquePtr<int> arr(new int[5]);
    for (int i = 0; i < 5; i++) {
        arr[i] = i * 10;
    }
    cout << "arr[3] = " << arr[3] << endl;

    cout << "\n=== Cleanup ===" << endl;
    return 0;
}
```

**Output:**

```text

=== Creating UniquePtr ===
Widget "First" created

=== Using operator-> ===
Widget: First at (10, 20)
Name via ->: First

=== Using operator* ===
Widget: First at (100, 20)

=== Using operator bool ===
w1 is valid

=== Moving ownership ===
w1 is now null
w2 owns the widget: First

=== Array-like UniquePtr ===
arr[3] = 30

=== Cleanup ===
Widget "First" destroyed
```
**Shared Pointer (Reference Counting)**

``` cpp
#include <iostream>
using namespace std;

template<typename T>
class SharedPtr {
    T* ptr;
    size_t* refCount;

    void release() {
        if (refCount) {
            (*refCount)--;
            if (*refCount == 0) {
                delete ptr;
                delete refCount;
            }
        }
    }

public:
    explicit SharedPtr(T* p = nullptr) : ptr(p), refCount(p ? new size_t(1) : nullptr) {}

    // Copy constructor - increment ref count
    SharedPtr(const SharedPtr& other) : ptr(other.ptr), refCount(other.refCount) {
        if (refCount) {
            (*refCount)++;
        }
    }

    // Move constructor
    SharedPtr(SharedPtr&& other) noexcept : ptr(other.ptr), refCount(other.refCount) {
        other.ptr = nullptr;
        other.refCount = nullptr;
    }

    // Destructor
    ~SharedPtr() {
        release();
    }

    // Copy assignment
    SharedPtr& operator=(const SharedPtr& other) {
        if (this != &other) {
            release();
            ptr = other.ptr;
            refCount = other.refCount;
            if (refCount) {
                (*refCount)++;
            }
        }
        return *this;
    }

    // Move assignment
    SharedPtr& operator=(SharedPtr&& other) noexcept {
        if (this != &other) {
            release();
            ptr = other.ptr;
            refCount = other.refCount;
            other.ptr = nullptr;
            other.refCount = nullptr;
        }
        return *this;
    }

    // Smart pointer operators
    T& operator*() const { return *ptr; }
    T* operator->() const { return ptr; }
    explicit operator bool() const { return ptr != nullptr; }

    // Utility
    T* get() const { return ptr; }
    size_t useCount() const { return refCount ? *refCount : 0; }
};

int main() {
    cout << "=== SharedPtr Demo ===" << endl;

    SharedPtr<string> s1(new string("Hello"));
    cout << "s1 created, refCount = " << s1.useCount() << endl;

    {
        SharedPtr<string> s2 = s1;  // Copy
        cout << "s2 = s1, refCount = " << s1.useCount() << endl;

        SharedPtr<string> s3 = s1;  // Another copy
        cout << "s3 = s1, refCount = " << s1.useCount() << endl;

        *s2 = "World";
        cout << "Modified via s2: " << *s1 << endl;
    }

    cout << "After s2, s3 destroyed, refCount = " << s1.useCount() << endl;
    cout << "Value: " << *s1 << endl;

    return 0;
}
```

### 12. Rules & Best Practices
**Operator Overloading Summary Table**

``` 
┌─────────────────────────────────────────────────────────────────┐
│              OPERATOR OVERLOADING SUMMARY                       │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  OPERATOR        MEMBER/NON-MEMBER    TYPICAL SIGNATURE         │
│  ────────        ─────────────────    ─────────────────         │
│                                                                 │
│  =               Member (required)    T& operator=(const T&)    │
│  []              Member (required)    T& operator[](size_t)     │
│  ()              Member (required)    R operator()(Args...)     │
│  ->              Member (required)    T* operator->()           │
│  ->*             Member (required)    T& operator->*(M T::*)    │
│                                                                 │
│  + - * /         Prefer non-member    T operator+(T, T)         │
│  == != < > <= >= Prefer non-member    bool operator==(T, T)     │
│  << >>           Non-member (required) ostream& operator<<(...)  │
│                                                                 │
│  += -= *= /=     Member               T& operator+=(const T&)   │
│  ++ --           Member               T& operator++() (prefix)  │
│                                        T operator++(int) (post)  │
│                                                                 │
│  unary + - ! ~   Either               T operator-() const       │
│                                                                 │
│  conversion      Member (required)    operator TargetType()     │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**Best Practices**

``` cpp
#include <iostream>
#include <utility>
using namespace std;

// ✓ GOOD: Complete, consistent operator set
class GoodNumber {
    int value;

public:
    GoodNumber(int v = 0) : value(v) {}

    // ✓ Return reference for compound assignment
    GoodNumber& operator+=(const GoodNumber& other) {
        value += other.value;
        return *this;
    }

    // ✓ Implement binary in terms of compound
    friend GoodNumber operator+(GoodNumber lhs, const GoodNumber& rhs) {
        lhs += rhs;
        return lhs;
    }

    // ✓ Symmetric comparison operators
    friend bool operator==(const GoodNumber& lhs, const GoodNumber& rhs) {
        return lhs.value == rhs.value;
    }

    friend bool operator!=(const GoodNumber& lhs, const GoodNumber& rhs) {
        return !(lhs == rhs);
    }

    // ✓ Const correctness for read-only operations
    GoodNumber operator-() const {
        return GoodNumber(-value);
    }

    // ✓ noexcept for move operations
    GoodNumber(GoodNumber&& other) noexcept : value(other.value) {
        other.value = 0;
    }

    GoodNumber& operator=(GoodNumber&& other) noexcept {
        value = other.value;
        other.value = 0;
        return *this;
    }

    // ✓ Stream operators as non-member friends
    friend ostream& operator<<(ostream& os, const GoodNumber& n) {
        os << n.value;
        return os;
    }
};

// ✗ BAD: Common mistakes to avoid
class BadNumber {
    int value;

public:
    // ✗ Returning void from compound assignment
    void operator+=(int x) {  // Should return BadNumber&
        value += x;
    }

    // ✗ Non-const binary operator that modifies operand
    BadNumber operator+(BadNumber other) {  // Should be const
        value += other.value;  // Modifying *this!
        return *this;
    }

    // ✗ Asymmetric comparison (member instead of friend)
    bool operator==(int x) const {
        return value == x;
        // This allows: badNum == 5
        // But not: 5 == badNum (unless non-member)
    }

    // ✗ Missing const on read-only operator
    int operator[](size_t idx) {  // Should have const version too
        return value;
    }
};
```
**Complete Best Practices Checklist**

```
┌─────────────────────────────────────────────────────────────────┐
│            OPERATOR OVERLOADING BEST PRACTICES                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  GENERAL RULES:                                                 │
│  ✓ Maintain intuitive semantics (+ should add, not subtract)   │
│  ✓ Be consistent (if you have +, also have +=)                 │
│  ✓ Return appropriate types:                                   │
│    • Compound assignment: return *this by reference             │
│    • Binary operators: return new object by value               │
│    • Prefix ++/--: return *this by reference                    │
│    • Postfix ++/--: return copy by value                        │
│                                                                 │
│  CONST CORRECTNESS:                                             │
│  ✓ Mark operators const if they don't modify object            │
│  ✓ Provide both const and non-const versions of []             │
│  ✓ Take parameters by const reference when possible            │
│                                                                 │
│  MEMBER VS NON-MEMBER:                                          │
│  ✓ Use member for: = [] () -> and operators that modify        │
│  ✓ Use non-member for: << >> and symmetric binary operators    │
│  ✓ Non-member allows implicit conversion on both operands      │
│                                                                 │
│  IMPLEMENTATION TIPS:                                           │
│  ✓ Implement + in terms of +=                                  │
│  ✓ Implement != in terms of ==                                 │
│  ✓ Implement >, <=, >= in terms of <                           │
│  ✓ Implement postfix in terms of prefix                        │
│  ✓ Use copy-and-swap for exception-safe assignment             │
│                                                                 │
│  MODERN C++ (C++20):                                            │
│  ✓ Use <=> spaceship operator to generate all comparisons      │
│  ✓ Default <=> when possible: auto operator<=>(const T&) const │
│                                                                 │
│  AVOID:                                                         │
│  ✗ Overloading && and || (short-circuit evaluation lost)       │
│  ✗ Overloading , (comma) operator                              │
│  ✗ Overloading & (address-of) for non-proxy classes            │
│  ✗ Making operators do unexpected things                        │
│  ✗ Forgetting self-assignment check in operator=               │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```
**Quick Reference Card**

``` 
┌─────────────────────────────────────────────────────────────────┐
│              OPERATOR OVERLOADING QUICK REFERENCE               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  COPY ASSIGNMENT:                                               │
│  T& operator=(const T& other) {                                 │
│      if (this != &other) { /* copy */ }                         │
│      return *this;                                              │
│  }                                                              │
│                                                                 │
│  MOVE ASSIGNMENT:                                               │
│  T& operator=(T&& other) noexcept {                             │
│      if (this != &other) { /* steal resources */ }              │
│      return *this;                                              │
│  }                                                              │
│                                                                 │
│  BINARY OPERATOR (non-member):                                  │
│  T operator+(T lhs, const T& rhs) {                             │
│      lhs += rhs;                                                │
│      return lhs;                                                │
│  }                                                              │
│                                                                 │
│  STREAM OUTPUT:                                                 │
│  friend ostream& operator<<(ostream& os, const T& obj) {        │
│      os << /* format */;                                        │
│      return os;                                                 │
│  }                                                              │
│                                                                 │
│  SUBSCRIPT:                                                     │
│  T& operator[](size_t i) { return data[i]; }                    │
│  const T& operator[](size_t i) const { return data[i]; }        │
│                                                                 │
│  INCREMENT:                                                     │
│  T& operator++() { /* inc */ return *this; }      // prefix     │
│  T operator++(int) { T t=*this; ++*this; return t; } // postfix │
│                                                                 │
│  CONVERSION:                                                    │
│  explicit operator bool() const { return /* condition */; }     │
│  explicit operator double() const { return /* value */; }       │
│                                                                 │
│  SPACESHIP (C++20):                                             │
│  auto operator<=>(const T&) const = default;                    │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## Copy Assignment & Move Assignment Operators
A comprehensive deep-dive into the two special assignment operators in C++.

### Table of Contents
* Overview: Assignment Operators
* Copy Assignment Operator
* Move Assignment Operator
* Self-Assignment Handling
* Copy-and-Swap Idiom
* Unified Assignment Operator
* Rule of Three/Five/Zero
* Complete Implementation Example
* Best Practices & Common Pitfalls

### 1. Overview: Assignment Operators
### What Are They?

```
┌─────────────────────────────────────────────────────────────────┐
│              SPECIAL ASSIGNMENT OPERATORS                       │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  COPY ASSIGNMENT OPERATOR                                       │
│  ─────────────────────────                                      │
│  • Assigns from an LVALUE (named object)                        │
│  • Signature: T& operator=(const T& other)                      │
│  • Creates a COPY of the source object                          │
│  • Source object remains unchanged                              │
│                                                                 │
│  MOVE ASSIGNMENT OPERATOR (C++11)                               │
│  ────────────────────────────────                               │
│  • Assigns from an RVALUE (temporary/moved object)              │
│  • Signature: T& operator=(T&& other) noexcept                  │
│  • TRANSFERS resources from source                              │
│  • Source object left in valid but unspecified state            │
│                                                                 │
│  KEY DIFFERENCE:                                                │
│  • Copy: Duplicates data (expensive for large objects)          │
│  • Move: Steals data (cheap - just pointer manipulation)        │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**When Each Is Called**
```cpp
#include <iostream>
#include <utility>
using namespace std;

class Demo {
    int id;

public:
    Demo(int i = 0) : id(i) {
        cout << "Constructor: " << id << endl;
    }

    // Copy Assignment
    Demo& operator=(const Demo& other) {
        cout << "Copy Assignment: " << other.id << " -> " << id << endl;
        id = other.id;
        return *this;
    }

    // Move Assignment
    Demo& operator=(Demo&& other) noexcept {
        cout << "Move Assignment: " << other.id << " -> " << id << endl;
        id = other.id;
        other.id = 0;
        return *this;
    }
};

Demo createDemo(int id) {
    return Demo(id);
}

int main() {
    Demo a(1);
    Demo b(2);
    Demo c(3);

    cout << "\n=== Copy Assignment (from lvalue) ===" << endl;
    a = b;  // b is lvalue → Copy Assignment

    cout << "\n=== Move Assignment (from rvalue) ===" << endl;
    a = Demo(4);  // Demo(4) is temporary (rvalue) → Move Assignment

    cout << "\n=== Move Assignment (using std::move) ===" << endl;
    a = std::move(c);  // std::move makes c an rvalue → Move Assignment

    cout << "\n=== Move Assignment (from function return) ===" << endl;
    a = createDemo(5);  // Return value is rvalue → Move Assignment

    return 0;
}
```

**Output:**

```text

Constructor: 1
Constructor: 2
Constructor: 3

=== Copy Assignment (from lvalue) ===
Copy Assignment: 2 -> 1

=== Move Assignment (from rvalue) ===
Constructor: 4
Move Assignment: 4 -> 2

=== Move Assignment (using std::move) ===
Move Assignment: 3 -> 4

=== Move Assignment (from function return) ===
Constructor: 5
Move Assignment: 5 -> 3
```
### 2. Copy Assignment Operator
**Syntax and Structure**
``` cpp
class ClassName {
public:
    // Copy Assignment Operator
    ClassName& operator=(const ClassName& other) {
        // 1. Self-assignment check
        // 2. Release current resources
        // 3. Allocate new resources
        // 4. Copy data
        // 5. Return *this
    }
};
```

**Basic Implementation**
``` cpp
#include <iostream>
#include <cstring>
using namespace std;

class String {
    char* data;
    size_t length;

public:
    // Constructor
    String(const char* str = "") {
        length = strlen(str);
        data = new char[length + 1];
        strcpy(data, str);
        cout << "Constructor: \"" << data << "\"" << endl;
    }

    // Copy Constructor
    String(const String& other) {
        length = other.length;
        data = new char[length + 1];
        strcpy(data, other.data);
        cout << "Copy Constructor: \"" << data << "\"" << endl;
    }

    // Copy Assignment Operator
    String& operator=(const String& other) {
        cout << "Copy Assignment: \"" << other.data << "\" to \"" << data << "\"" << endl;

        // Step 1: Self-assignment check
        if (this == &other) {
            cout << "  (Self-assignment detected, skipping)" << endl;
            return *this;
        }

        // Step 2: Release current resources
        delete[] data;
        cout << "  Released old memory" << endl;

        // Step 3: Allocate new resources
        length = other.length;
        data = new char[length + 1];
        cout << "  Allocated new memory" << endl;

        // Step 4: Copy data
        strcpy(data, other.data);
        cout << "  Copied data" << endl;

        // Step 5: Return *this for chaining
        return *this;
    }

    // Destructor
    ~String() {
        cout << "Destructor: \"" << data << "\"" << endl;
        delete[] data;
    }

    void print() const {
        cout << "String: \"" << data << "\" (length: " << length << ")" << endl;
    }
};

int main() {
    cout << "=== Creating strings ===" << endl;
    String s1("Hello");
    String s2("World");

    cout << "\n=== Copy Assignment ===" << endl;
    s1 = s2;
    s1.print();

    cout << "\n=== Self Assignment ===" << endl;
    s1 = s1;
    s1.print();

    cout << "\n=== Chained Assignment ===" << endl;
    String s3("Test");
    s3 = s2 = s1;
    s3.print();

    cout << "\n=== Cleanup ===" << endl;
    return 0;
}
```
**Output:**

```text

=== Creating strings ===
Constructor: "Hello"
Constructor: "World"

=== Copy Assignment ===
Copy Assignment: "World" to "Hello"
  Released old memory
  Allocated new memory
  Copied data
String: "World" (length: 5)

=== Self Assignment ===
Copy Assignment: "World" to "World"
  (Self-assignment detected, skipping)
String: "World" (length: 5)

=== Chained Assignment ===
Constructor: "Test"
Copy Assignment: "World" to "World"
  (Self-assignment detected, skipping)
Copy Assignment: "World" to "Test"
  Released old memory
  Allocated new memory
  Copied data
String: "World" (length: 5)

=== Cleanup ===
Destructor: "World"
Destructor: "World"
Destructor: "World"
```
**Visual: Copy Assignment**

``` 
═══════════════════════════════════════════════════════════════════
                    COPY ASSIGNMENT OPERATION
═══════════════════════════════════════════════════════════════════

    s1 = s2;    // s1 already exists, s2 is source

    BEFORE:
    ┌─────────────┐         ┌───────────────┐
    │     s1      │         │   "Hello"     │
    ├─────────────┤         │   (old data)  │
    │ data: ──────┼────────►└───────────────┘
    │ length: 5   │
    └─────────────┘

    ┌─────────────┐         ┌───────────────┐
    │     s2      │         │   "World"     │
    ├─────────────┤         │   (source)    │
    │ data: ──────┼────────►└───────────────┘
    │ length: 5   │
    └─────────────┘

    STEP 1: Delete old data
    ┌─────────────┐         ┌ ─ ─ ─ ─ ─ ─ ─┐
    │     s1      │           "Hello"
    ├─────────────┤         │ (DELETED)    │
    │ data: ──────┼────────►└ ─ ─ ─ ─ ─ ─ ─┘
    │ length: 5   │
    └─────────────┘

    STEP 2: Allocate new memory + Copy
    ┌─────────────┐         ┌───────────────┐
    │     s1      │         │   "World"     │
    ├─────────────┤         │   (NEW copy)  │
    │ data: ──────┼────────►└───────────────┘
    │ length: 5   │
    └─────────────┘

    ┌─────────────┐         ┌───────────────┐
    │     s2      │         │   "World"     │
    ├─────────────┤         │  (unchanged)  │
    │ data: ──────┼────────►└───────────────┘
    │ length: 5   │
    └─────────────┘

    RESULT: Two independent copies of "World"

═══════════════════════════════════════════════════════════════════
```

**Compiler-Generated Copy Assignment**

``` cpp
#include <iostream>
#include <string>
#include <vector>
using namespace std;

// Compiler generates copy assignment if:
// - No user-declared copy assignment
// - No user-declared move operations
// - No user-declared destructor (deprecated to generate)

class AutoCopy {
public:
    int x;
    double y;
    string name;
    vector<int> data;

    // Compiler generates:
    // AutoCopy& operator=(const AutoCopy& other) {
    //     x = other.x;           // Member-wise copy
    //     y = other.y;
    //     name = other.name;     // Uses string's operator=
    //     data = other.data;     // Uses vector's operator=
    //     return *this;
    // }
};

class ExplicitDefault {
public:
    int value;
    string text;

    // Explicitly request compiler-generated version
    ExplicitDefault& operator=(const ExplicitDefault&) = default;
};

class Deleted {
public:
    int value;

    // Explicitly delete copy assignment
    Deleted& operator=(const Deleted&) = delete;
};

int main() {
    AutoCopy a1, a2;
    a1.x = 10;
    a1.name = "First";

    a2 = a1;  // Uses compiler-generated copy assignment
    cout << "a2.x = " << a2.x << ", a2.name = " << a2.name << endl;

    ExplicitDefault e1, e2;
    e1.value = 42;
    e2 = e1;  // Uses explicitly defaulted copy assignment
    cout << "e2.value = " << e2.value << endl;

    Deleted d1, d2;
    // d2 = d1;  // ERROR: Copy assignment is deleted

    return 0;
}
```

### 3. Move Assignment Operator
**Syntax and Structure**

``` cpp
class ClassName {
public:
    // Move Assignment Operator
    ClassName& operator=(ClassName&& other) noexcept {
        // 1. Self-assignment check
        // 2. Release current resources
        // 3. Steal resources from other
        // 4. Leave other in valid state
        // 5. Return *this
    }
};
```
**Basic Implementation**
``` cpp
#include <iostream>
#include <utility>
#include <cstring>
using namespace std;

class Buffer {
    int* data;
    size_t size;
    string name;

public:
    // Constructor
    Buffer(size_t sz = 0, const string& n = "unnamed")
        : data(sz ? new int[sz] : nullptr)
        , size(sz)
        , name(n) 
    {
        if (data) {
            for (size_t i = 0; i < size; i++) data[i] = 0;
        }
        cout << "[" << name << "] Constructor: allocated " << size << " ints" << endl;
    }

    // Copy Constructor
    Buffer(const Buffer& other)
        : data(other.size ? new int[other.size] : nullptr)
        , size(other.size)
        , name(other.name + "_copy")
    {
        if (data) {
            for (size_t i = 0; i < size; i++) data[i] = other.data[i];
        }
        cout << "[" << name << "] Copy Constructor" << endl;
    }

    // Move Constructor
    Buffer(Buffer&& other) noexcept
        : data(other.data)
        , size(other.size)
        , name(std::move(other.name))
    {
        other.data = nullptr;
        other.size = 0;
        cout << "[" << name << "] Move Constructor" << endl;
    }

    // Copy Assignment
    Buffer& operator=(const Buffer& other) {
        cout << "[" << name << "] Copy Assignment from [" << other.name << "]" << endl;

        if (this != &other) {
            delete[] data;

            size = other.size;
            data = size ? new int[size] : nullptr;
            if (data) {
                for (size_t i = 0; i < size; i++) data[i] = other.data[i];
            }
            name = other.name + "_assigned";
        }
        return *this;
    }

    // Move Assignment
    Buffer& operator=(Buffer&& other) noexcept {
        cout << "[" << name << "] Move Assignment from [" << other.name << "]" << endl;

        if (this != &other) {
            // Step 1: Release current resources
            delete[] data;
            cout << "  Released old resources" << endl;

            // Step 2: Steal resources from other
            data = other.data;
            size = other.size;
            name = std::move(other.name);
            cout << "  Stole resources" << endl;

            // Step 3: Leave other in valid state
            other.data = nullptr;
            other.size = 0;
            cout << "  Nullified source" << endl;
        }
        return *this;
    }

    // Destructor
    ~Buffer() {
        cout << "[" << (name.empty() ? "moved-from" : name) << "] Destructor" << endl;
        delete[] data;
    }

    void info() const {
        cout << "Buffer \"" << name << "\": size=" << size
             << ", data=" << (data ? "valid" : "null") << endl;
    }

    void fill(int value) {
        for (size_t i = 0; i < size; i++) data[i] = value;
    }
};

int main() {
    cout << "=== Creating buffers ===" << endl;
    Buffer b1(100, "Buffer1");
    Buffer b2(200, "Buffer2");

    b1.fill(42);
    b2.fill(99);

    cout << "\nBefore operations:" << endl;
    b1.info();
    b2.info();

    cout << "\n=== Move Assignment (std::move) ===" << endl;
    b1 = std::move(b2);

    cout << "\nAfter move:" << endl;
    b1.info();
    b2.info();  // b2 is now in moved-from state

    cout << "\n=== Move Assignment (temporary) ===" << endl;
    b1 = Buffer(50, "Temporary");

    cout << "\nAfter temporary assignment:" << endl;
    b1.info();

    cout << "\n=== Cleanup ===" << endl;
    return 0;
}
```

**Output:**

```text

=== Creating buffers ===
[Buffer1] Constructor: allocated 100 ints
[Buffer2] Constructor: allocated 200 ints

Before operations:
Buffer "Buffer1": size=100, data=valid
Buffer "Buffer2": size=200, data=valid

=== Move Assignment (std::move) ===
[Buffer1] Move Assignment from [Buffer2]
  Released old resources
  Stole resources
  Nullified source

After move:
Buffer "Buffer2": size=200, data=valid
Buffer "": size=0, data=null

=== Move Assignment (temporary) ===
[Temporary] Constructor: allocated 50 ints
[Buffer2] Move Assignment from [Temporary]
  Released old resources
  Stole resources
  Nullified source
[moved-from] Destructor

After temporary assignment:
Buffer "Temporary": size=50, data=valid

=== Cleanup ===
[moved-from] Destructor
[Temporary] Destructor
```
**Visual: Move Assignment**


```
═══════════════════════════════════════════════════════════════════
                    MOVE ASSIGNMENT OPERATION
═══════════════════════════════════════════════════════════════════

    b1 = std::move(b2);    // b1 exists, b2 is source (made rvalue)

    BEFORE:
    ┌─────────────┐         ┌───────────────────┐
    │     b1      │         │ [0][0][0]...[0]   │
    ├─────────────┤         │   (100 ints)      │
    │ data: ──────┼────────►└───────────────────┘
    │ size: 100   │
    │ name:"B1"   │
    └─────────────┘

    ┌─────────────┐         ┌───────────────────┐
    │     b2      │         │ [1][2][3]...[n]   │
    ├─────────────┤         │   (200 ints)      │
    │ data: ──────┼────────►└───────────────────┘
    │ size: 200   │
    │ name:"B2"   │
    └─────────────┘

    STEP 1: Release b1's resources
    ┌─────────────┐         ┌ ─ ─ ─ ─ ─ ─ ─ ─ ─┐
    │     b1      │           [0][0][0]...[0]
    ├─────────────┤         │   (DELETED)      │
    │ data: null  │         └ ─ ─ ─ ─ ─ ─ ─ ─ ─┘
    │ size: 100   │
    │ name:"B1"   │
    └─────────────┘

    STEP 2: Steal b2's resources (just copy pointers!)
    ┌─────────────┐
    │     b1      │
    ├─────────────┤         ┌───────────────────┐
    │ data: ──────┼────────►│ [1][2][3]...[n]   │
    │ size: 200   │         │   (200 ints)      │
    │ name:"B2"   │         └───────────────────┘
    └─────────────┘                  ▲
                                     │
    ┌─────────────┐                  │
    │     b2      │                  │
    ├─────────────┤         (b2 no longer owns this!)
    │ data: null  │
    │ size: 0     │
    │ name:""     │
    └─────────────┘

    RESULT:
    • b1 now owns the 200-int buffer
    • b2 is in valid but empty state
    • NO data was copied - just pointers!
    • O(1) operation vs O(n) for copy

═══════════════════════════════════════════════════════════════════
```

**noexcept Importance**

``` cpp
#include <iostream>
#include <vector>
#include <type_traits>
using namespace std;

class WithNoexcept {
    int* data;

public:
    WithNoexcept() : data(new int(0)) {}
    ~WithNoexcept() { delete data; }

    WithNoexcept(WithNoexcept&& other) noexcept : data(other.data) {
        other.data = nullptr;
        cout << "Move ctor (noexcept)" << endl;
    }

    WithNoexcept& operator=(WithNoexcept&& other) noexcept {
        if (this != &other) {
            delete data;
            data = other.data;
            other.data = nullptr;
        }
        cout << "Move assign (noexcept)" << endl;
        return *this;
    }

    // Delete copy operations
    WithNoexcept(const WithNoexcept&) = delete;
    WithNoexcept& operator=(const WithNoexcept&) = delete;
};

class WithoutNoexcept {
    int* data;

public:
    WithoutNoexcept() : data(new int(0)) {}
    ~WithoutNoexcept() { delete data; }

    // NOT noexcept - may throw
    WithoutNoexcept(WithoutNoexcept&& other) : data(other.data) {
        other.data = nullptr;
        cout << "Move ctor (may throw)" << endl;
    }

    WithoutNoexcept& operator=(WithoutNoexcept&& other) {
        if (this != &other) {
            delete data;
            data = other.data;
            other.data = nullptr;
        }
        cout << "Move assign (may throw)" << endl;
        return *this;
    }

    WithoutNoexcept(const WithoutNoexcept& other) : data(new int(*other.data)) {
        cout << "Copy ctor (fallback)" << endl;
    }

    WithoutNoexcept& operator=(const WithoutNoexcept&) = default;
};

int main() {
    cout << "=== Type traits check ===" << endl;
    cout << "WithNoexcept move noexcept: " 
         << boolalpha << is_nothrow_move_assignable_v<WithNoexcept> << endl;
    cout << "WithoutNoexcept move noexcept: " 
         << is_nothrow_move_assignable_v<WithoutNoexcept> << endl;

    cout << "\n=== Vector with noexcept move ===" << endl;
    vector<WithNoexcept> v1;
    v1.reserve(2);
    v1.push_back(WithNoexcept());
    cout << "Adding second element (may cause reallocation):" << endl;
    v1.push_back(WithNoexcept());  // Uses move because noexcept

    cout << "\n=== Vector without noexcept move ===" << endl;
    vector<WithoutNoexcept> v2;
    v2.reserve(2);
    v2.push_back(WithoutNoexcept());
    cout << "Adding second element:" << endl;
    v2.push_back(WithoutNoexcept());  // May use copy as fallback!

    return 0;
}
```

``` 
┌─────────────────────────────────────────────────────────────────┐
│                  WHY noexcept MATTERS                           │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  std::vector REALLOCATION:                                      │
│                                                                 │
│  WITH noexcept:                                                 │
│  ┌─────────────────────────────────────────────────────┐        │
│  │ Old buffer: [A][B][C]                               │        │
│  │                ↓ ↓ ↓  (move each element)           │        │
│  │ New buffer: [A][B][C][ ][ ][ ]                      │        │
│  │                                                     │        │
│  │ Safe: If move throws, we haven't modified old data │        │
│  │ But wait - move is noexcept, so it WON'T throw!    │        │
│  └─────────────────────────────────────────────────────┘        │
│                                                                 │
│  WITHOUT noexcept:                                              │
│  ┌─────────────────────────────────────────────────────┐        │
│  │ Problem: If move throws after moving some elements, │        │
│  │ we can't restore original state (they're gone!)     │        │
│  │                                                     │        │
│  │ Solution: Use COPY instead (safe but slower)        │        │
│  │                                                     │        │
│  │ Old buffer: [A][B][C]  (kept intact)               │        │
│  │                ↓ ↓ ↓  (copy each element)          │        │
│  │ New buffer: [A][B][C][ ][ ][ ]                      │        │
│  └─────────────────────────────────────────────────────┘        │
│                                                                 │
│  CONCLUSION: Always mark move operations noexcept!              │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘

```

### 4. Self-Assignment Handling
**Why It Matters**
``` cpp
#include <iostream>
#include <cstring>
using namespace std;

class UnsafeString {
    char* data;

public:
    UnsafeString(const char* str = "") {
        data = new char[strlen(str) + 1];
        strcpy(data, str);
    }

    ~UnsafeString() { delete[] data; }

    // UNSAFE: No self-assignment check!
    UnsafeString& operator=(const UnsafeString& other) {
        delete[] data;  // Oops! If this == &other, we just deleted our data!
        data = new char[strlen(other.data) + 1];  // other.data is now garbage!
        strcpy(data, other.data);  // Undefined behavior!
        return *this;
    }
};

class SafeString {
    char* data;

public:
    SafeString(const char* str = "") {
        data = new char[strlen(str) + 1];
        strcpy(data, str);
    }

    ~SafeString() { delete[] data; }

    // SAFE: With self-assignment check
    SafeString& operator=(const SafeString& other) {
        if (this == &other) {  // Self-assignment check
            return *this;
        }
        delete[] data;
        data = new char[strlen(other.data) + 1];
        strcpy(data, other.data);
        return *this;
    }
};

int main() {
    SafeString s("Hello");
    s = s;  // Self-assignment - safe!
    cout << "Self-assignment successful" << endl;

    return 0;
}
```

**Visual: Self-Assignment Problem**
```
═══════════════════════════════════════════════════════════════════
            SELF-ASSIGNMENT WITHOUT CHECK (DANGEROUS!)
═══════════════════════════════════════════════════════════════════

    s = s;    // Self-assignment

    BEFORE:
    ┌─────────────┐         ┌───────────────┐
    │      s      │         │   "Hello"     │
    ├─────────────┤         │               │
    │ data: ──────┼────────►└───────────────┘
    └─────────────┘              ▲
          │                      │
          └──────────────────────┘
          (s and &other are SAME!)

    STEP 1: delete[] data (DISASTER!)
    ┌─────────────┐         ┌ ─ ─ ─ ─ ─ ─ ─┐
    │      s      │           DELETED!
    ├─────────────┤         │ GARBAGE      │
    │ data: ──────┼────────►└ ─ ─ ─ ─ ─ ─ ─┘
    └─────────────┘
          │
          └─── other.data ALSO points here (same object!)

    STEP 2: strlen(other.data) - READING GARBAGE!
    → Undefined Behavior
    → Possible crash
    → Memory corruption


═══════════════════════════════════════════════════════════════════
            SELF-ASSIGNMENT WITH CHECK (SAFE!)
═══════════════════════════════════════════════════════════════════

    s = s;    // Self-assignment

    CHECK: if (this == &other)
           ↓
    this = 0x1000
    &other = 0x1000
           ↓
    SAME! Return immediately.

    No deletion, no corruption, no problem!

═══════════════════════════════════════════════════════════════════
```

**Three Approaches to Self-Assignment Safety**

``` cpp
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;

class Approach1 {
    char* data;
    size_t length;

public:
    Approach1(const char* str = "") {
        length = strlen(str);
        data = new char[length + 1];
        strcpy(data, str);
    }

    ~Approach1() { delete[] data; }

    // Approach 1: Explicit self-check
    Approach1& operator=(const Approach1& other) {
        if (this == &other) {
            return *this;
        }
        delete[] data;
        length = other.length;
        data = new char[length + 1];
        strcpy(data, other.data);
        return *this;
    }
};

class Approach2 {
    char* data;
    size_t length;

public:
    Approach2(const char* str = "") {
        length = strlen(str);
        data = new char[length + 1];
        strcpy(data, str);
    }

    Approach2(const Approach2& other) {
        length = other.length;
        data = new char[length + 1];
        strcpy(data, other.data);
    }

    ~Approach2() { delete[] data; }

    void swap(Approach2& other) noexcept {
        std::swap(data, other.data);
        std::swap(length, other.length);
    }

    // Approach 2: Copy-and-swap (inherently safe)
    Approach2& operator=(Approach2 other) {  // By value = copy
        swap(other);
        return *this;
    }
};

class Approach3 {
    char* data;
    size_t length;

public:
    Approach3(const char* str = "") {
        length = strlen(str);
        data = new char[length + 1];
        strcpy(data, str);
    }

    ~Approach3() { delete[] data; }

    // Approach 3: Allocate before delete (exception safe)
    Approach3& operator=(const Approach3& other) {
        // Allocate new memory FIRST
        char* newData = new char[other.length + 1];
        strcpy(newData, other.data);

        // Only then release old memory
        delete[] data;

        data = newData;
        length = other.length;
        return *this;
    }
};

int main() {
    cout << "=== Approach 1: Explicit check ===" << endl;
    Approach1 a1("Hello");
    a1 = a1;
    cout << "Success!" << endl;

    cout << "\n=== Approach 2: Copy-and-swap ===" << endl;
    Approach2 a2("World");
    a2 = a2;
    cout << "Success!" << endl;

    cout << "\n=== Approach 3: Allocate first ===" << endl;
    Approach3 a3("Test");
    a3 = a3;
    cout << "Success!" << endl;

    return 0;
}
```

### 5. Copy-and-Swap Idiom
Complete Implementation

``` cpp
#include <iostream>
#include <algorithm>
#include <cstring>
using namespace std;

class String {
    char* data;
    size_t length;

public:
    // Default Constructor
    String() : data(new char[1]), length(0) {
        data[0] = '\0';
        cout << "Default Constructor" << endl;
    }

    // Parameterized Constructor
    String(const char* str) {
        length = strlen(str);
        data = new char[length + 1];
        strcpy(data, str);
        cout << "Parameterized Constructor: \"" << data << "\"" << endl;
    }

    // Copy Constructor
    String(const String& other) {
        length = other.length;
        data = new char[length + 1];
        strcpy(data, other.data);
        cout << "Copy Constructor: \"" << data << "\"" << endl;
    }

    // Move Constructor
    String(String&& other) noexcept
        : data(other.data)
        , length(other.length) 
    {
        other.data = nullptr;
        other.length = 0;
        cout << "Move Constructor: \"" << data << "\"" << endl;
    }

    // Destructor
    ~String() {
        cout << "Destructor: \"" << (data ? data : "null") << "\"" << endl;
        delete[] data;
    }

    // Swap function (noexcept is crucial!)
    void swap(String& other) noexcept {
        using std::swap;
        swap(data, other.data);
        swap(length, other.length);
    }

    // Unified Assignment Operator (handles both copy and move!)
    String& operator=(String other) noexcept {  // Note: pass by VALUE
        cout << "Assignment (copy-and-swap)" << endl;
        swap(other);
        return *this;
    }  // 'other' destroyed here with old data

    void print() const {
        cout << "String: \"" << (data ? data : "null") << "\"" << endl;
    }
};

// Non-member swap for ADL
void swap(String& a, String& b) noexcept {
    a.swap(b);
}

int main() {
    cout << "=== Creating strings ===" << endl;
    String s1("Hello");
    String s2("World");

    cout << "\n=== Copy Assignment (lvalue) ===" << endl;
    // When assigning from lvalue:
    // 1. Copy constructor creates 'other' parameter
    // 2. swap() exchanges data
    // 3. 'other' (with old s1 data) is destroyed
    s1 = s2;
    s1.print();
    s2.print();

    cout << "\n=== Move Assignment (rvalue) ===" << endl;
    // When assigning from rvalue:
    // 1. Move constructor creates 'other' parameter (cheap!)
    // 2. swap() exchanges data
    // 3. 'other' (with old s1 data) is destroyed
    s1 = String("Temporary");
    s1.print();

    cout << "\n=== Self Assignment ===" << endl;
    // Self-assignment:
    // 1. Copy constructor creates 'other' with copy of s1
    // 2. swap() exchanges (s1 gets copy, 'other' gets original)
    // 3. 'other' destroyed - but that's fine, s1 has valid data
    s1 = s1;
    s1.print();

    cout << "\n=== Cleanup ===" << endl;
    return 0;
}
```

**Output:**

```text

=== Creating strings ===
Parameterized Constructor: "Hello"
Parameterized Constructor: "World"

=== Copy Assignment (lvalue) ===
Copy Constructor: "World"
Assignment (copy-and-swap)
Destructor: "Hello"
String: "World"
String: "World"

=== Move Assignment (rvalue) ===
Parameterized Constructor: "Temporary"
Move Constructor: "Temporary"
Assignment (copy-and-swap)
Destructor: "World"
String: "Temporary"

=== Self Assignment ===
Copy Constructor: "Temporary"
Assignment (copy-and-swap)
Destructor: "Temporary"
String: "Temporary"

=== Cleanup ===
Destructor: "World"
Destructor: "Temporary"
```
**Visual: Copy-and-Swap Flow**

``` 
═══════════════════════════════════════════════════════════════════
                    COPY-AND-SWAP IDIOM
═══════════════════════════════════════════════════════════════════

    String& operator=(String other) noexcept {
        swap(other);        // Parameter is by VALUE
        return *this;
    }

    ═══════════════════════════════════════════════════════════════
    CASE 1: s1 = s2 (copy from lvalue)
    ═══════════════════════════════════════════════════════════════

    Step 1: Parameter 'other' is COPY CONSTRUCTED
    ┌──────────┐     ┌──────────┐     ┌──────────┐
    │    s1    │     │    s2    │     │  other   │
    │ "Hello"  │     │ "World"  │────►│ "World"  │ (copy)
    └──────────┘     └──────────┘     └──────────┘

    Step 2: swap(other)
    ┌──────────┐                      ┌──────────┐
    │    s1    │◄────── SWAP ────────►│  other   │
    │ "World"  │                      │ "Hello"  │
    └──────────┘                      └──────────┘

    Step 3: 'other' destroyed (releases "Hello")
    ┌──────────┐
    │    s1    │
    │ "World"  │  ✓ Done!
    └──────────┘

    ═══════════════════════════════════════════════════════════════
    CASE 2: s1 = String("Temp") (move from rvalue)
    ═══════════════════════════════════════════════════════════════

    Step 1: Parameter 'other' is MOVE CONSTRUCTED (cheap!)
    ┌──────────┐     ┌──────────┐
    │    s1    │     │  other   │
    │ "Hello"  │     │  "Temp"  │ (moved from temporary)
    └──────────┘     └──────────┘

    Step 2: swap(other)
    ┌──────────┐                      ┌──────────┐
    │    s1    │◄────── SWAP ────────►│  other   │
    │  "Temp"  │                      │ "Hello"  │
    └──────────┘                      └──────────┘

    Step 3: 'other' destroyed (releases "Hello")
    ┌──────────┐
    │    s1    │
    │  "Temp"  │  ✓ Done!
    └──────────┘

═══════════════════════════════════════════════════════════════════

    BENEFITS:
    ✓ Exception safe (copy/move happens first, then noexcept swap)
    ✓ Self-assignment safe (works correctly even if s1 = s1)
    ✓ Single function handles both copy and move assignment
    ✓ Clean, minimal code
    ✓ Reuses copy/move constructor logic

═══════════════════════════════════════════════════════════════════
```

### 6. Unified Assignment Operator
**Alternative: Separate Copy and Move**

``` cpp
#include <iostream>
#include <utility>
#include <cstring>
using namespace std;

class SeparateAssignment {
    char* data;
    size_t length;

public:
    SeparateAssignment(const char* str = "") {
        length = strlen(str);
        data = new char[length + 1];
        strcpy(data, str);
    }

    SeparateAssignment(const SeparateAssignment& other) {
        length = other.length;
        data = new char[length + 1];
        strcpy(data, other.data);
    }

    SeparateAssignment(SeparateAssignment&& other) noexcept
        : data(other.data), length(other.length) {
        other.data = nullptr;
        other.length = 0;
    }

    ~SeparateAssignment() { delete[] data; }

    // SEPARATE Copy Assignment
    SeparateAssignment& operator=(const SeparateAssignment& other) {
        cout << "Copy Assignment" << endl;
        if (this != &other) {
            char* newData = new char[other.length + 1];
            strcpy(newData, other.data);
            delete[] data;
            data = newData;
            length = other.length;
        }
        return *this;
    }

    // SEPARATE Move Assignment
    SeparateAssignment& operator=(SeparateAssignment&& other) noexcept {
        cout << "Move Assignment" << endl;
        if (this != &other) {
            delete[] data;
            data = other.data;
            length = other.length;
            other.data = nullptr;
            other.length = 0;
        }
        return *this;
    }

    const char* c_str() const { return data ? data : ""; }
};

class UnifiedAssignment {
    char* data;
    size_t length;

public:
    UnifiedAssignment(const char* str = "") {
        length = strlen(str);
        data = new char[length + 1];
        strcpy(data, str);
    }

    UnifiedAssignment(const UnifiedAssignment& other) {
        length = other.length;
        data = new char[length + 1];
        strcpy(data, other.data);
    }

    UnifiedAssignment(UnifiedAssignment&& other) noexcept
        : data(other.data), length(other.length) {
        other.data = nullptr;
        other.length = 0;
    }

    ~UnifiedAssignment() { delete[] data; }

    void swap(UnifiedAssignment& other) noexcept {
        std::swap(data, other.data);
        std::swap(length, other.length);
    }

    // UNIFIED Assignment (handles both copy and move)
    UnifiedAssignment& operator=(UnifiedAssignment other) noexcept {
        cout << "Unified Assignment" << endl;
        swap(other);
        return *this;
    }

    const char* c_str() const { return data ? data : ""; }
};

int main() {
    cout << "=== Separate Assignment Operators ===" << endl;
    SeparateAssignment s1("Hello");
    SeparateAssignment s2("World");

    s1 = s2;                      // Copy assignment
    s1 = SeparateAssignment("!");  // Move assignment

    cout << "\n=== Unified Assignment Operator ===" << endl;
    UnifiedAssignment u1("Hello");
    UnifiedAssignment u2("World");

    u1 = u2;                      // Copy ctor + unified = copy behavior
    u1 = UnifiedAssignment("!");  // Move ctor + unified = move behavior

    return 0;
}
```
**Comparison Table**

``` 
┌─────────────────────────────────────────────────────────────────┐
│          SEPARATE vs UNIFIED ASSIGNMENT OPERATORS               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  SEPARATE (Two Functions):                                      │
│  ─────────────────────────                                      │
│  T& operator=(const T& other);      // Copy                     │
│  T& operator=(T&& other) noexcept;  // Move                     │
│                                                                 │
│  Pros:                                                          │
│  ✓ More explicit about what's happening                        │
│  ✓ Can optimize each independently                             │
│  ✓ Move assignment can be noexcept                             │
│                                                                 │
│  Cons:                                                          │
│  ✗ More code to write and maintain                             │
│  ✗ Potential for inconsistency                                 │
│                                                                 │
│  ─────────────────────────────────────────────────────────────  │
│                                                                 │
│  UNIFIED (One Function):                                        │
│  ───────────────────────                                        │
│  T& operator=(T other) noexcept;    // By value                 │
│                                                                 │
│  Pros:                                                          │
│  ✓ Single function handles both                                │
│  ✓ Inherently exception safe                                   │
│  ✓ Inherently self-assignment safe                             │
│  ✓ Less code                                                   │
│  ✓ Uses existing copy/move constructors                        │
│                                                                 │
│  Cons:                                                          │
│  ✗ Always creates parameter copy (minor overhead)              │
│  ✗ Less explicit                                               │
│                                                                 │
│  RECOMMENDATION:                                                │
│  • Use unified for simple classes                               │
│  • Use separate for performance-critical code                   │
│  • Use separate when copy/move have very different logic        │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 7. Rule of Three/Five/Zero
**Rule of Three (Pre-C++11)**

``` cpp
#include <iostream>
#include <cstring>
using namespace std;

// If you define ONE, you should define ALL THREE:
// 1. Destructor
// 2. Copy Constructor
// 3. Copy Assignment Operator

class RuleOfThree {
    char* data;

public:
    // Constructor
    RuleOfThree(const char* str = "") {
        data = new char[strlen(str) + 1];
        strcpy(data, str);
    }

    // 1. Destructor
    ~RuleOfThree() {
        delete[] data;
    }

    // 2. Copy Constructor
    RuleOfThree(const RuleOfThree& other) {
        data = new char[strlen(other.data) + 1];
        strcpy(data, other.data);
    }

    // 3. Copy Assignment
    RuleOfThree& operator=(const RuleOfThree& other) {
        if (this != &other) {
            delete[] data;
            data = new char[strlen(other.data) + 1];
            strcpy(data, other.data);
        }
        return *this;
    }
};
```
**Rule of Zero (Modern C++)**

``` cpp
#include <iostream>
#include <string>
#include <vector>
#include <memory>
using namespace std;

// Best practice: Let compiler generate everything
// Use RAII wrappers that handle their own resources

class RuleOfZero {
    string name;                      // Handles own memory
    vector<int> data;                 // Handles own memory
    unique_ptr<int> resource;         // Handles own lifetime

public:
    RuleOfZero(const string& n, size_t size)
        : name(n)
        , data(size)
        , resource(make_unique<int>(42)) 
    {}

    // NO destructor needed
    // NO copy constructor needed (well, unique_ptr prevents copying)
    // NO move constructor needed
    // NO copy assignment needed
    // NO move assignment needed

    // If we want copying, use shared_ptr instead:
};

class CopyableRuleOfZero {
    string name;
    vector<int> data;
    shared_ptr<int> resource;  // Shared ownership allows copying

public:
    CopyableRuleOfZero(const string& n, size_t size)
        : name(n)
        , data(size)
        , resource(make_shared<int>(42)) 
    {}

    // All five special members are auto-generated correctly!
};

int main() {
    cout << "=== Rule of Zero Demo ===" << endl;

    RuleOfZero r1("Object1", 10);
    RuleOfZero r2 = std::move(r1);  // Move works!

    CopyableRuleOfZero c1("Object2", 5);
    CopyableRuleOfZero c2 = c1;  // Copy works!
    CopyableRuleOfZero c3 = std::move(c2);  // Move works!

    cout << "All operations successful!" << endl;

    return 0;
}
```
**Visual Summary**

``` 
┌─────────────────────────────────────────────────────────────────┐
│                    RULE OF THREE/FIVE/ZERO                      │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  RULE OF THREE (Pre-C++11):                                     │
│  ─────────────────────────                                      │
│  If you define any of these, define all three:                  │
│  1. ~T()                     Destructor                         │
│  2. T(const T&)              Copy Constructor                   │
│  3. T& operator=(const T&)   Copy Assignment                    │
│                                                                 │
│  RULE OF FIVE (C++11+):                                         │
│  ────────────────────────                                       │
│  If you define any of these, define all five:                   │
│  1. ~T()                     Destructor                         │
│  2. T(const T&)              Copy Constructor                   │
│  3. T& operator=(const T&)   Copy Assignment                    │
│  4. T(T&&)                   Move Constructor                   │
│  5. T& operator=(T&&)        Move Assignment                    │
│                                                                 │
│  RULE OF ZERO (Modern Best Practice):                           │
│  ───────────────────────────────────                            │
│  • Define NONE of the five special members                      │
│  • Use smart pointers and RAII containers                       │
│  • Let compiler generate correct versions                       │
│  • Simpler, safer, less code                                    │
│                                                                 │
│  ═══════════════════════════════════════════════════════════    │
│                                                                 │
│  DECISION GUIDE:                                                │
│                                                                 │
│  Does your class manage raw resources (new/delete, files, etc)?│
│                     │                                           │
│            ┌────────┴────────┐                                  │
│           YES               NO                                  │
│            │                 │                                  │
│            ▼                 ▼                                  │
│     Consider refactoring     Use Rule of Zero                   │
│     to use RAII wrappers     (let compiler handle it)           │
│            │                                                    │
│            ▼                                                    │
│     Can't refactor?                                             │
│            │                                                    │
│            ▼                                                    │
│     Use Rule of Five                                            │
│     (implement all 5)                                           │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 8. Complete Implementation Example
**Full-Featured String Class**

``` cpp
#include <iostream>
#include <cstring>
#include <utility>
#include <algorithm>
using namespace std;

class String {
    char* data;
    size_t length;
    size_t capacity;

    static constexpr size_t MIN_CAPACITY = 16;

    void log(const char* operation) const {
        cout << "[" << operation << "] "
             << "data=\"" << (data ? data : "null") << "\", "
             << "len=" << length << ", cap=" << capacity << endl;
    }

public:
    // ═══════════════════════════════════════════════════════════
    // CONSTRUCTORS
    // ═══════════════════════════════════════════════════════════

    // Default Constructor
    String() : data(new char[MIN_CAPACITY]), length(0), capacity(MIN_CAPACITY) {
        data[0] = '\0';
        log("Default Constructor");
    }

    // C-string Constructor
    String(const char* str) {
        length = strlen(str);
        capacity = max(length + 1, MIN_CAPACITY);
        data = new char[capacity];
        strcpy(data, str);
        log("C-string Constructor");
    }

    // Fill Constructor
    String(size_t count, char ch) {
        length = count;
        capacity = max(length + 1, MIN_CAPACITY);
        data = new char[capacity];
        for (size_t i = 0; i < length; i++) {
            data[i] = ch;
        }
        data[length] = '\0';
        log("Fill Constructor");
    }

    // ═══════════════════════════════════════════════════════════
    // RULE OF FIVE
    // ═══════════════════════════════════════════════════════════

    // 1. Destructor
    ~String() {
        log("Destructor");
        delete[] data;
    }

    // 2. Copy Constructor
    String(const String& other)
        : length(other.length)
        , capacity(other.capacity)
        , data(new char[other.capacity])
    {
        strcpy(data, other.data);
        log("Copy Constructor");
    }

    // 3. Move Constructor
    String(String&& other) noexcept
        : data(other.data)
        , length(other.length)
        , capacity(other.capacity)
    {
        other.data = nullptr;
        other.length = 0;
        other.capacity = 0;
        log("Move Constructor");
    }

    // 4. Copy Assignment Operator
    String& operator=(const String& other) {
        log("Copy Assignment (start)");

        if (this != &other) {
            // Allocate first for exception safety
            char* newData = new char[other.capacity];
            strcpy(newData, other.data);

            // Release old resources
            delete[] data;

            // Assign new values
            data = newData;
            length = other.length;
            capacity = other.capacity;
        } else {
            cout << "  (Self-assignment detected)" << endl;
        }

        log("Copy Assignment (end)");
        return *this;
    }

    // 5. Move Assignment Operator
    String& operator=(String&& other) noexcept {
        log("Move Assignment (start)");

        if (this != &other) {
            // Release current resources
            delete[] data;

            // Steal from source
            data = other.data;
            length = other.length;
            capacity = other.capacity;

            // Leave source in valid state
            other.data = nullptr;
            other.length = 0;
            other.capacity = 0;
        } else {
            cout << "  (Self-move detected)" << endl;
        }

        log("Move Assignment (end)");
        return *this;
    }

    // ═══════════════════════════════════════════════════════════
    // ALTERNATIVE: Unified Assignment with Copy-and-Swap
    // ═══════════════════════════════════════════════════════════
    
    // Uncomment to use unified assignment instead:
    /*
    void swap(String& other) noexcept {
        using std::swap;
        swap(data, other.data);
        swap(length, other.length);
        swap(capacity, other.capacity);
    }

    String& operator=(String other) noexcept {
        log("Unified Assignment");
        swap(other);
        return *this;
    }
    */

    // ═══════════════════════════════════════════════════════════
    // UTILITY FUNCTIONS
    // ═══════════════════════════════════════════════════════════

    size_t size() const { return length; }
    size_t cap() const { return capacity; }
    const char* c_str() const { return data ? data : ""; }
    bool empty() const { return length == 0; }

    void print() const {
        cout << "\"" << c_str() << "\" (len=" << length << ", cap=" << capacity << ")" << endl;
    }
};

// Non-member swap
void swap(String& a, String& b) noexcept {
    // Implementation would call a.swap(b) if available
}

int main() {
    cout << "════════════════════════════════════════════════════════" << endl;
    cout << "                    STRING CLASS DEMO                    " << endl;
    cout << "════════════════════════════════════════════════════════" << endl;

    cout << "\n>>> Creating strings\n" << endl;
    String s1("Hello");
    String s2("World");
    String s3;

    cout << "\n>>> Copy operations\n" << endl;
    
    cout << "\n-- Copy Construction --" << endl;
    String s4 = s1;
    s4.print();

    cout << "\n-- Copy Assignment --" << endl;
    s3 = s2;
    s3.print();

    cout << "\n>>> Move operations\n" << endl;

    cout << "\n-- Move Construction --" << endl;
    String s5 = std::move(s1);
    cout << "s5: "; s5.print();
    cout << "s1 (moved-from): "; s1.print();

    cout << "\n-- Move Assignment --" << endl;
    s3 = std::move(s2);
    cout << "s3: "; s3.print();
    cout << "s2 (moved-from): "; s2.print();

    cout << "\n>>> Self-assignment tests\n" << endl;

    cout << "\n-- Self Copy Assignment --" << endl;
    s3 = s3;

    cout << "\n-- Self Move Assignment --" << endl;
    s3 = std::move(s3);

    cout << "\n>>> Chained assignment\n" << endl;
    String s6("Chained");
    String s7, s8;
    s8 = s7 = s6;
    cout << "s6: "; s6.print();
    cout << "s7: "; s7.print();
    cout << "s8: "; s8.print();

    cout << "\n>>> Temporary assignment\n" << endl;
    s7 = String("Temporary");
    cout << "s7: "; s7.print();

    cout << "\n>>> Cleanup\n" << endl;
    return 0;
}
```

### 9. Best Practices & Common Pitfalls
**Best Practices**

``` cpp
#include <iostream>
#include <utility>
using namespace std;

class BestPractices {
    int* data;
    size_t size;

public:
    BestPractices(size_t sz = 0) 
        : data(sz ? new int[sz] : nullptr)
        , size(sz) {}

    ~BestPractices() { delete[] data; }

    // ✓ Copy constructor
    BestPractices(const BestPractices& other)
        : data(other.size ? new int[other.size] : nullptr)
        , size(other.size) 
    {
        for (size_t i = 0; i < size; i++) {
            data[i] = other.data[i];
        }
    }

    // ✓ Move constructor - ALWAYS noexcept
    BestPractices(BestPractices&& other) noexcept
        : data(other.data)
        , size(other.size) 
    {
        other.data = nullptr;
        other.size = 0;
    }

    // ✓ Copy assignment - Allocate BEFORE delete
    BestPractices& operator=(const BestPractices& other) {
        if (this != &other) {
            // Allocate new memory FIRST (exception safe)
            int* newData = other.size ? new int[other.size] : nullptr;
            for (size_t i = 0; i < other.size; i++) {
                newData[i] = other.data[i];
            }

            // THEN delete old memory
            delete[] data;

            // Assign
            data = newData;
            size = other.size;
        }
        return *this;
    }

    // ✓ Move assignment - ALWAYS noexcept
    BestPractices& operator=(BestPractices&& other) noexcept {
        if (this != &other) {
            delete[] data;

            data = other.data;
            size = other.size;

            other.data = nullptr;
            other.size = 0;
        }
        return *this;
    }

    // ✓ Swap function for copy-and-swap
    void swap(BestPractices& other) noexcept {
        using std::swap;
        swap(data, other.data);
        swap(size, other.size);
    }
};

// ✓ Non-member swap for ADL
void swap(BestPractices& a, BestPractices& b) noexcept {
    a.swap(b);
}
```

**Common Pitfalls**

``` cpp
#include <iostream>
using namespace std;

class Pitfalls {
    int* data;

public:
    Pitfalls() : data(new int(42)) {}
    ~Pitfalls() { delete data; }

    // ❌ PITFALL 1: Missing self-assignment check
    Pitfalls& bad_copy_1(const Pitfalls& other) {
        delete data;              // If this == &other, we just corrupted ourselves!
        data = new int(*other.data);  // other.data is now garbage
        return *this;
    }

    // ❌ PITFALL 2: Delete before allocate (not exception safe)
    Pitfalls& bad_copy_2(const Pitfalls& other) {
        if (this != &other) {
            delete data;          // Old data is gone
            data = new int(*other.data);  // If this throws, object is corrupted!
        }
        return *this;
    }

    // ❌ PITFALL 3: Returning void instead of reference
    void bad_copy_3(const Pitfalls& other) {
        if (this != &other) {
            delete data;
            data = new int(*other.data);
        }
        // Can't chain: a = b = c; doesn't work!
    }

    // ❌ PITFALL 4: Missing noexcept on move operations
    Pitfalls& bad_move_1(Pitfalls&& other) {  // No noexcept!
        // std::vector won't use this for reallocation!
        delete data;
        data = other.data;
        other.data = nullptr;
        return *this;
    }

    // ❌ PITFALL 5: Not nullifying source in move
    Pitfalls& bad_move_2(Pitfalls&& other) noexcept {
        delete data;
        data = other.data;
        // Forgot: other.data = nullptr;
        // When other is destroyed, it will double-delete!
        return *this;
    }

    // ❌ PITFALL 6: Shallow copy when deep copy needed
    Pitfalls& bad_copy_4(const Pitfalls& other) {
        if (this != &other) {
            data = other.data;  // Just copying pointer!
            // Both objects now point to same memory
            // Double delete on destruction!
        }
        return *this;
    }

    // ✓ CORRECT Implementation
    Pitfalls& operator=(const Pitfalls& other) {
        if (this != &other) {
            int* newData = new int(*other.data);  // Allocate first
            delete data;                          // Then delete old
            data = newData;
        }
        return *this;
    }

    Pitfalls& operator=(Pitfalls&& other) noexcept {
        if (this != &other) {
            delete data;
            data = other.data;
            other.data = nullptr;  // Nullify source
        }
        return *this;
    }
};
```

**Quick Reference Card**

``` 
┌─────────────────────────────────────────────────────────────────┐
│           COPY & MOVE ASSIGNMENT QUICK REFERENCE                │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  COPY ASSIGNMENT:                                               │
│  ────────────────                                               │
│  T& operator=(const T& other) {                                 │
│      if (this != &other) {          // Self-assignment check    │
│          T* temp = new T(...);      // Allocate FIRST           │
│          delete old;                // Then delete              │
│          ptr = temp;                // Assign                   │
│      }                                                          │
│      return *this;                  // Enable chaining          │
│  }                                                              │
│                                                                 │
│  MOVE ASSIGNMENT:                                               │
│  ────────────────                                               │
│  T& operator=(T&& other) noexcept { // ALWAYS noexcept          │
│      if (this != &other) {          // Self-move check          │
│          delete old;                // Release current          │
│          ptr = other.ptr;           // Steal resources          │
│          other.ptr = nullptr;       // Nullify source           │
│      }                                                          │
│      return *this;                                              │
│  }                                                              │
│                                                                 │
│  UNIFIED ASSIGNMENT (Copy-and-Swap):                            │
│  ───────────────────────────────────                            │
│  T& operator=(T other) noexcept {   // By VALUE                 │
│      swap(other);                   // Swap with copy/moved     │
│      return *this;                  // Old data destroyed       │
│  }                                  // with 'other'             │
│                                                                 │
│  CHECKLIST:                                                     │
│  ☐ Self-assignment check                                        │
│  ☐ Release current resources                                    │
│  ☐ Copy/steal new resources                                     │
│  ☐ Leave moved-from object valid                                │
│  ☐ Return *this                                                 │
│  ☐ noexcept on move operations                                  │
│  ☐ Allocate before delete (exception safety)                    │
│                                                                 │
│  WHEN CALLED:                                                   │
│  • Copy: obj = lvalue;                                          │
│  • Move: obj = rvalue;                                          │
│  • Move: obj = std::move(other);                                │
│  • Move: obj = functionReturningByValue();                      │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**Summary Diagram**
```
┌─────────────────────────────────────────────────────────────────┐
│                    ASSIGNMENT OPERATORS                         │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│                        obj = source;                            │
│                             │                                   │
│                             ▼                                   │
│                    ┌─────────────────┐                          │
│                    │ Is source an    │                          │
│                    │ lvalue or rvalue?│                          │
│                    └────────┬────────┘                          │
│                             │                                   │
│              ┌──────────────┴──────────────┐                    │
│              │                             │                    │
│              ▼                             ▼                    │
│        ┌──────────┐                 ┌───────────┐               │
│        │  LVALUE  │                 │  RVALUE   │               │
│        └────┬─────┘                 └─────┬─────┘               │
│             │                             │                     │
│             ▼                             ▼                     │
│    ┌────────────────┐           ┌─────────────────┐             │
│    │ Copy Assignment│           │ Move Assignment │             │
│    │ operator=      │           │ operator=       │             │
│    │ (const T&)     │           │ (T&&) noexcept  │             │
│    └────────┬───────┘           └────────┬────────┘             │
│             │                            │                      │
│             ▼                            ▼                      │
│    ┌────────────────┐           ┌─────────────────┐             │
│    │ • Allocate new │           │ • Delete current│             │
│    │ • Copy data    │           │ • Steal pointers│             │
│    │ • Delete old   │           │ • Nullify source│             │
│    │ • O(n) time    │           │ • O(1) time     │             │
│    └────────────────┘           └─────────────────┘             │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```





