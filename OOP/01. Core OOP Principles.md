# Core OOP Principles

>## Encapsulation:

### What is Encapsulation?

Encapsulation means:

> Bundling data and the functions that work on that data into a single unit (a class),  
> and hiding the internal details from the outside.*

In C++:

- You **hide** data using `private` / `protected`.
- You **expose** a clean interface using `public` functions.
- This lets you:
  - Protect the internal state from invalid use.
  - Change the implementation later without breaking other code.


### Example 1: Bank Account üè¶

**Without Encapsulation (bad design)**  

```cpp
struct BankAccount {
    double balance;  // public!

    // anyone can do this:
    // account.balance = -100000;  // makes no sense
};
```
- `balance` is public:
  - Any code can set it to a negative value
  - Any code can overwrite it accidentally
  - There is no control over how money is added or removed

**With Encapsulation (good design)**

``` cpp
class BankAccount {
private:
    double balance;       // hidden (encapsulated)

public:
    BankAccount(double initialBalance)
        : balance(initialBalance) {}

    void deposit(double amount) {
        if (amount > 0) {
            balance += amount;
        }
    }

    bool withdraw(double amount) {
        if (amount > 0 && amount <= balance) {
            balance -= amount;
            return true;
        }
        return false;  // not enough balance
    }

    double getBalance() const {
        return balance;  // read-only access
    }
};

Usage:
BankAccount acc(100.0);
acc.deposit(50.0);         // OK
acc.withdraw(30.0);        // OK
// acc.balance = -9999;    // ‚ùå not allowed - balance is private

```
- Benefits:
  - Outside code cannot directly change `balance`.
  - All updates go through `deposit` / `withdraw`, which enforces rules:
    - No negative deposits
    - No withdrawing more thanthe  balance
  - Internal representation (`double balance`) can be changed later (e.g., use `int` cents), but the interface stays the same.
  - That‚Äôs encapsulation.

### Example 2: Encapsulating a Dynamic Array üìö

**Without Encapsulation**  
``` cpp
struct BadArray {
    int* data;
    int size;
};
```
- Problems:
  - Anyone can `delete[] data` from outside.
  - `size` can be set to a wrong value.
  - No guarantee `data` is valid: leads to crashes.

**With Encapsulation**  
``` cpp
class IntArray {
private:
    int* data;
    int size;

public:
    IntArray(int n)
        : size(n), data(new int[n]{}) {}

    ~IntArray() {
        delete[] data;
    }

    int getSize() const { return size; }

    int& operator[](int index) {
        // (optionally) add bounds checking
        return data[index];
    }

    // copy/move constructors & assignment operators would be added
    // in a real implementation (Rule of 3/5)
};

Usage:
IntArray arr(5);
arr[0] = 10;
arr[1] = 20;
// arr.size = 1000;     // ‚ùå not allowed
// delete[] arr.data;   // ‚ùå not allowed

```
- Benefits:
  - `data` and `size` are hidden.
  - The class controls allocation/deallocation ‚Üí RAII.
  - Users can work with `IntArray` safely via `operator[]` and `getSize()`.

>[!NOTE] 
>### Key Points to Remember

Encapsulation in C++ is mainly implemented using:
- `private`, `protected`, and `public` access specifiers.
- Private data + public methods = classic encapsulation.

Advantages:
- Protects internal state from invalid external use.
- Makes code easier to reason about and maintain.
- Allows changing implementation without breaking user code.

You can think of a class as a black box:
- Outside code only sees the buttons (public methods),
- Not the wires inside (private data and helper functions).

---

## Abstraction:

### What is Abstraction?

**Abstraction** means:

> Showing only the **essential features** of an object and hiding the **complex internal details**.

- **Encapsulation** = hiding data (using `private`).
- **Abstraction** = hiding **complexity** and exposing a **simple interface**.

You use abstraction when you say:
> ‚ÄúI don‚Äôt care *how* it works inside, I just want to *use* it.‚Äù


### Example 1: Shape Interface üé®

We want different shapes (Circle, Rectangle) to provide an **area**,  
But we don‚Äôt care how each one **calculates** it internally.

### Abstract Class (Interface-like)

```cpp
class Shape {
public:
    virtual double area() const = 0;  // pure virtual function
    virtual ~Shape() = default;       // virtual destructor
};

```
- `Shape` is an abstract class (cannot be instantiated).
- `area()` is a pure virtual function ‚Üí no implementation here.
- It defines what every shape must do, not how.


**Concrete Implementations**

``` cpp
class Circle : public Shape {
private:
    double radius;

public:
    Circle(double r) : radius(r) {}

    double area() const override {
        return 3.14159 * radius * radius;
    }
};

class Rectangle : public Shape {
private:
    double width, height;

public:
    Rectangle(double w, double h) : width(w), height(h) {}

    double area() const override {
        return width * height;
    }
};

// Using the Abstraction
int main() {
    Shape* s1 = new Circle(5.0);
    Shape* s2 = new Rectangle(4.0, 6.0);

    std::cout << "Circle area: " << s1->area() << "\n";
    std::cout << "Rectangle area: " << s2->area() << "\n";

    delete s1;
    delete s2;
}
```
- What happened here?
  - `main` only calls `area()` through the `Shape` interface.
  - `main` does not know or care:
    - that `Circle` uses œÄr¬≤,
    - that `Rectangle` uses w√óh.
  - The details are abstracted away.
  - That‚Äôs **abstraction**: use a simple, common interface and hide different complex implementations behind it.


### Example 2: Database Abstraction

Imagine you have a class that talks to a database. Users of this class:

- Don‚Äôt want to know about:
  - sockets
  - protocols
  - SQL parsing
  - connection pooling
- Just want simple operations:
  - `connect()`
  - `query()`
  - `disconnect()`

This hides complex database details behind a clean, easy-to-use interface ‚Üí **abstraction**.

``` cpp 
class Database {
public:
    void connect(const std::string& url) {
        // Internally: open socket, authenticate, etc.
    }

    std::string query(const std::string& sql) {
        // Internally: send SQL, receive result, parse, handle errors...
        return "result";
    }

    void disconnect() {
        // Internally: close connection, cleanup
    }
};

// Usage:
int main() {
    Database db;
    db.connect("db://localhost:5432");

    std::string res = db.query("SELECT * FROM users;");
    std::cout << "Query result: " << res << "\n";

    db.disconnect();
}
```
- Here:
  - User code sees only a simple high-level API: `connect` / `query` / `disconnect`.
  - All low-level complexity (networking, error handling, buffering, protocols, retries, etc.) is abstracted away.

### Abstraction vs Encapsulation (Quick Comparison)

**Encapsulation:**
- Hides data and implementation details using `private` / `protected`.
- Example: making `balance` private in `BankAccount`.

**Abstraction:**
- Hides complexity behind a simple interface.
- Example: using `Shape::area()` or `Database::query()` without knowing how they‚Äôre implemented.

You often use both together:
- Private data + public abstract behavior ‚Üí clean, powerful class design.  

---

## Inheritance in C++

Inheritance is one of the four pillars of Object-Oriented Programming (OOP) in C++.  
It allows a class (the **Derived** or **Child** class) to acquire the properties and behaviors  
(variables and functions) of another class (the **Base** or **Parent** class).

### Why use Inheritance?

- **Code Reusability**  
  - Write common code once in the Base class and reuse it in multiple Derived classes.

- **Extensibility**  
  - Add new features in Derived classes without modifying the existing Base class.

- **Hierarchical Classification**  
  - Represents **"IS-A" relationships**, e.g.:
    - `Dog` **is an** `Animal`
    - `Car` **is a** `Vehicle`

**Basic Syntax**

``` cpp
class ParentClass {
    // Parent logic
};

// The colon initiates inheritance
class ChildClass : public ParentClass {
    // Child logic
};
```

### Example 1: Single Inheritance (The Basics)
This is the simplest form of inheritance where **one class derives from one base class**.

``` cpp
#include <iostream>
using namespace std;

// Base Class
class Animal {
public:
    void eat() {
        cout << "I can eat!" << endl;
    }
    
    void sleep() {
        cout << "I can sleep!" << endl;
    }
};

// Derived Class
// Dog inherits all public methods from Animal
class Dog : public Animal {
public:
    void bark() {
        cout << "I can bark! Woof woof!" << endl;
    }
};

int main() {
    Dog myDog;
    
    // Calling methods defined in the Base class (Animal)
    myDog.eat();
    myDog.sleep();
    
    // Calling method defined in the Derived class (Dog)
    myDog.bark();
    
    return 0;
}
```
``` text
Output:
I can eat!
I can sleep!
I can bark! Woof woof!
```

### Access Specifiers in Inheritance

Understanding `public`, `private`, and `protected` is crucial.

- **public**
  - Accessible by everyone (both outside code and derived classes).

- **private**
  - Accessible only by the class itself.
  - Not accessible by derived (child) classes.

- **protected**
  - Accessible by the class itself and derived (child) classes.
  - Not accessible from the outside world (e.g., `main`).

### Example 2: Using `protected`.

This allows the child class to access parent data  
while keeping it safe from outside code.

``` cpp
#include <iostream>
using namespace std;

class Vehicle {
protected: 
    int speed; // Accessible by Car, but not by main()

public:
    void setSpeed(int s) {
        speed = s;
    }
};

class Car : public Vehicle {
public:
    void displaySpeed() {
        // We can access 'speed' directly because it is protected
        cout << "Car speed is: " << speed << " km/h" << endl;
    }
};

int main() {
    Car myCar;
    myCar.setSpeed(100); // Public method from Vehicle
    myCar.displaySpeed(); // Public method from Car
    
    // myCar.speed = 200; // ERROR: 'speed' is protected
    
    return 0;
}
```

## Types of Inheritance

C++ supports several types of inheritance. Here are the most common ones besides **Single Inheritance**.

### A. Multilevel Inheritance

A chain of inheritance:

`Grandparent` ‚Üí `Parent` ‚Üí `Child`


``` cpp 
#include <iostream>
using namespace std;

class Fruit {
public:
    void origin() { cout << "I grow on plants." << endl; }
};

class Citrus : public Fruit {
public:
    void type() { cout << "I am a citrus fruit." << endl; }
};

class Orange : public Citrus {
public:
    void color() { cout << "I am orange in color." << endl; }
};

int main() {
    Orange o;
    o.origin(); // From Grandparent
    o.type();   // From Parent
    o.color();  // From Self
    return 0;
}
``` 

### B. Multiple Inheritance
A unique feature in C++ where a class can inherit from **two or more base classes** simultaneously.

``` cpp
#include <iostream>
using namespace std;

class Engine {
public:
    void startEngine() { cout << "Engine started." << endl; }
};

class Wheels {
public:
    void rotateWheels() { cout << "Wheels rolling." << endl; }
};

// Car inherits from BOTH Engine and Wheels
class Car : public Engine, public Wheels {
public:
    void drive() { cout << "Car is moving." << endl; }
};

int main() {
    Car c;
    c.startEngine();   // From Engine class
    c.rotateWheels();  // From Wheels class
    c.drive();         // From Car class
    return 0;
}
```

## Function Overriding

Sometimes, the child class wants to perform a specific action **differently** than the parent.  
In that case, it can **override** the parent's function.

- The base (parent) class marks the function as `virtual`.
- The derived (child) class provides its **own implementation** with the same signature.
- At runtime, the correct function (parent or child) is chosen based on the **actual object type**, not the pointer type.

This is the core of **runtime polymorphism** in C++.

``` cpp
#include <iostream>
using namespace std;

class Animal {
public:
    // 'virtual' allows the child to override this specific function
    virtual void makeSound() {
        cout << "Animal makes a sound" << endl;
    }
};

class Cat : public Animal {
public:
    // Overriding the base function
    void makeSound() {
        cout << "Meow! Meow!" << endl;
    }
};

int main() {
    Animal* a;
    Cat c;
    
    a = &c;
    
    // Calls the Cat's version because of the 'virtual' keyword
    a->makeSound(); 
    
    return 0;
}
```

## Summary of Access Modes

When you inherit (`class Child : mode Parent`), the **mode** determines how `Parent`'s members  
are treated inside `Child` and from outside:

| Parent member | `public` inheritance        | `protected` inheritance       | `private` inheritance        |
|---------------|----------------------------|-------------------------------|------------------------------|
| `public`      | stays `public` in `Child`  | becomes `protected` in `Child`| becomes `private` in `Child` |
| `protected`   | stays `protected` in `Child`| stays `protected` in `Child` | becomes `private` in `Child` |
| `private`     | not accessible in `Child`  | not accessible in `Child`    | not accessible in `Child`    |

- `public` inheritance ‚Üí ‚ÄúIS-A‚Äù relationship, public interface is preserved.
- `protected` / `private` inheritance ‚Üí more restrictive; mainly for implementation reuse, not ‚ÄúIS-A‚Äù.


---

## Polymorphism

Polymorphism (from Greek: *many forms*) allows a single function or operator  
to behave differently depending on the context.

C++ supports two main types of polymorphism:

1. **Compile-time Polymorphism (Static Binding)**
2. **Run-time Polymorphism (Dynamic Binding)**


### 1. Compile-time Polymorphism (Static Binding)

- The compiler decides **which function to call at compile time**.
- Achieved mainly through:
  - **Function overloading**
  - **Operator overloading**
  - **Templates** (generic programming)

#### Function Overloading

You can define **multiple functions with the same name** but different parameters  
(different types and/or different numbers of arguments).

Example idea (conceptually):

- `print(int x)`
- `print(double x)`
- `print(const std::string& s)`

All are called `print`, but the compiler chooses the correct one  
based on the **argument types** at compile time.


``` cpp
#include <iostream>
using namespace std;

class Calculator {
public:
    // Form 1: Adds two integers
    void add(int a, int b) {
        cout << "Integer sum: " << a + b << endl;
    }

    // Form 2: Adds two doubles
    void add(double a, double b) {
        cout << "Double sum: " << a + b << endl;
    }

    // Form 3: Adds three integers
    void add(int a, int b, int c) {
        cout << "Three int sum: " << a + b + c << endl;
    }
};

int main() {
    Calculator calc;
    
    // The compiler knows which function to call based on the arguments
    calc.add(10, 20);         // Calls Form 1
    calc.add(5.5, 2.3);       // Calls Form 2
    calc.add(1, 2, 3);        // Calls Form 3
    
    return 0;
}
```

### 2. Run-time Polymorphism (Dynamic Binding)

- The exact function to be called is decided **while the program is running**.
- Achieved using **inheritance** and **virtual functions**.

This is powerful because it allows you to handle different objects (like `Dog`, `Cat`, or `Cow`)  
through a **generic base pointer or reference** (like `Animal*`), and the correct method runs  
for the actual object type.

#### Key Keywords

- `virtual`
  - Placed in the **base class** to tell the compiler:  
    ‚ÄúWait until **runtime** to decide which function to call.‚Äù
- `override` (optional but recommended)
  - Placed in the **derived class** to ensure you are actually overriding  
    a virtual function from the base class (helps catch mistakes).

#### Example Idea: Virtual Functions (Function Overriding)

- Base class: `class Animal { virtual void speak(); };`
- Derived classes: `class Dog : public Animal { void speak() override; };`  
  `class Cat : public Animal { void speak() override; };`
- When you call `animalPtr->speak();`, the correct `speak()` (Dog‚Äôs, Cat‚Äôs, etc.)  
  is chosen **at runtime** based on the actual object type.


``` cpp
#include <iostream>
using namespace std;

// Base Class
class Animal {
public:
    // 'virtual' ensures the Derived class function is called
    // even when accessed via a Base Class pointer.
    virtual void makeSound() {
        cout << "Generic animal sound" << endl;
    }
};

// Derived Class 1
class Dog : public Animal {
public:
    void makeSound() override {
        cout << "Woof! Woof!" << endl;
    }
};

// Derived Class 2
class Cat : public Animal {
public:
    void makeSound() override {
        cout << "Meow! Meow!" << endl;
    }
};

int main() {
    Animal* animalPtr;
    
    Dog myDog;
    Cat myCat;

    // 1. Pointing to a Dog
    animalPtr = &myDog;
    // Because of 'virtual', this looks at the OBJECT (Dog), not the pointer type (Animal)
    animalPtr->makeSound(); 

    // 2. Pointing to a Cat
    animalPtr = &myCat;
    animalPtr->makeSound(); 

    return 0;
}

```

**Output:**
``` text
Woof! Woof!
Meow! Meow!
```

If you remove `virtual` from `Animal::makeSound()`, calls made through `Animal*` / `Animal&` will use **static binding**, so the base version is always called.  
The output would be:

```text
Animal makes a sound
Animal makes a sound

```
### 3. Abstract Classes (Pure Virtual Functions)

Sometimes, you want to force derived classes to implement a function, and you don't want the Base class to have any implementation at all. This is called a **Pure Virtual Function**.

A class containing a pure virtual function is called an **Abstract Class** (you cannot create an object of it directly).

**Example: Real-world scenario**

``` #include <iostream>
using namespace std;

// Abstract Base Class
class Shape {
public:
    // "= 0" means this function is Pure Virtual.
    // Derived classes MUST implement this function.
    virtual void draw() = 0; 
};

class Circle : public Shape {
public:
    void draw() override {
        cout << "Drawing a Circle" << endl;
    }
};

class Rectangle : public Shape {
public:
    void draw() override {
        cout << "Drawing a Rectangle" << endl;
    }
};

int main() {
    // Shape s; // ERROR: Cannot instantiate abstract class
    
    Shape* s1 = new Circle();
    Shape* s2 = new Rectangle();
    
    s1->draw();
    s2->draw();
    
    return 0;
}
```
Summary Comparison

| Feature      | Compile-time Polymorphism        | Run-time Polymorphism              |
|-------------|-----------------------------------|------------------------------------|
| Common Name | Overloading                       | Overriding                         |
| Binding     | Static (Early) Binding            | Dynamic (Late) Binding             |
| Mechanism   | Different signatures (parameters) | virtual functions + pointers       |
| Speed       | Faster (decided at compile time)  | Slower (lookup happens at run time)|
| Flexibility | Less flexible                     | Highly flexible                    |
