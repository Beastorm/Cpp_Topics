## Abstract Classes & Interfaces in C++
A comprehensive guide covering abstract classes, pure virtual functions, and interface design patterns.

### Table of Contents
* Pure Virtual Functions
* Abstract Base Classes
* Interfaces in C++
* Interfaces vs Abstract Classes
* Design Patterns with Abstract Classes
* Multiple Inheritance & Interfaces
* Best Practices

### 1. Pure Virtual Functions
**What is a Pure Virtual Function?**
A pure virtual function is a virtual function that has no implementation in the base class and must be overridden by derived classes.

```
┌─────────────────────────────────────────────────────────────────┐
│                  PURE VIRTUAL FUNCTION                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  SYNTAX:                                                        │
│  ────────                                                       │
│  virtual ReturnType functionName(parameters) = 0;               │
│                                              ───                │
│                                               │                 │
│                                    "Pure specifier"             │
│                                    Makes it pure virtual        │
│                                                                 │
│  CHARACTERISTICS:                                               │
│  ────────────────                                               │
│  • No implementation in base class (usually)                    │
│  • MUST be overridden in derived class                          │
│  • Makes the containing class abstract                          │
│  • Cannot instantiate class with pure virtual function          │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**Basic Example**
``` cpp
#include <iostream>
#include <string>
using namespace std;

class Shape {
protected:
    string name;

public:
    Shape(const string& n) : name(n) {
        cout << "Shape constructor: " << name << endl;
    }

    virtual ~Shape() {
        cout << "Shape destructor: " << name << endl;
    }

    // Pure virtual functions - NO implementation
    virtual double area() const = 0;
    virtual double perimeter() const = 0;
    virtual void draw() const = 0;

    // Regular virtual function - HAS implementation
    virtual void describe() const {
        cout << "I am a " << name << endl;
    }

    // Non-virtual function
    string getName() const {
        return name;
    }
};

class Circle : public Shape {
    double radius;

public:
    Circle(double r) : Shape("Circle"), radius(r) {}

    // MUST implement all pure virtual functions
    double area() const override {
        return 3.14159 * radius * radius;
    }

    double perimeter() const override {
        return 2 * 3.14159 * radius;
    }

    void draw() const override {
        cout << "Drawing a circle with radius " << radius << endl;
    }
};

class Rectangle : public Shape {
    double width, height;

public:
    Rectangle(double w, double h) : Shape("Rectangle"), width(w), height(h) {}

    double area() const override {
        return width * height;
    }

    double perimeter() const override {
        return 2 * (width + height);
    }

    void draw() const override {
        cout << "Drawing a rectangle " << width << " x " << height << endl;
    }
};

int main() {
    // Shape s("Test");  // ERROR: Cannot instantiate abstract class

    Circle circle(5.0);
    Rectangle rect(4.0, 6.0);

    cout << "\n=== Circle ===" << endl;
    circle.describe();
    circle.draw();
    cout << "Area: " << circle.area() << endl;
    cout << "Perimeter: " << circle.perimeter() << endl;

    cout << "\n=== Rectangle ===" << endl;
    rect.describe();
    rect.draw();
    cout << "Area: " << rect.area() << endl;
    cout << "Perimeter: " << rect.perimeter() << endl;

    cout << "\n=== Polymorphism ===" << endl;
    Shape* shapes[] = {&circle, &rect};
    for (Shape* s : shapes) {
        s->draw();
        cout << "Area: " << s->area() << endl;
    }

    cout << "\n=== Cleanup ===" << endl;
    return 0;
}
```
**Output:**

```text

Shape constructor: Circle
Shape constructor: Rectangle

=== Circle ===
I am a Circle
Drawing a circle with radius 5
Area: 78.5397
Perimeter: 31.4159

=== Rectangle ===
I am a Rectangle
Drawing a rectangle 4 x 6
Area: 24
Perimeter: 20

=== Polymorphism ===
Drawing a circle with radius 5
Area: 78.5397
Drawing a rectangle 4 x 6
Area: 24

=== Cleanup ===
Shape destructor: Rectangle
Shape destructor: Circle
```
**Pure Virtual Function with Implementation**

``` cpp
#include <iostream>
using namespace std;

class Base {
public:
    // Pure virtual function WITH implementation!
    // Class is still abstract, but provides default behavior
    virtual void doSomething() = 0;

    virtual ~Base() = default;
};

// Implementation OUTSIDE the class (required for pure virtual with body)
void Base::doSomething() {
    cout << "Base::doSomething() - Default implementation" << endl;
}

class Derived1 : public Base {
public:
    void doSomething() override {
        // Call base implementation, then add own behavior
        Base::doSomething();
        cout << "Derived1::doSomething() - Additional behavior" << endl;
    }
};

class Derived2 : public Base {
public:
    void doSomething() override {
        // Completely override - don't call base
        cout << "Derived2::doSomething() - Complete override" << endl;
    }
};

int main() {
    // Base b;  // Still ERROR: Cannot instantiate abstract class

    Derived1 d1;
    Derived2 d2;

    cout << "=== Derived1 ===" << endl;
    d1.doSomething();

    cout << "\n=== Derived2 ===" << endl;
    d2.doSomething();

    return 0;
}
```

**Output:**

```text

=== Derived1 ===
Base::doSomething() - Default implementation
Derived1::doSomething() - Additional behavior

=== Derived2 ===
Derived2::doSomething() - Complete override
```
**Visual: Pure Virtual Function**

``` 
═══════════════════════════════════════════════════════════════════
                    PURE VIRTUAL FUNCTION
═══════════════════════════════════════════════════════════════════

                    ┌─────────────────────┐
                    │    Shape (Abstract) │
                    ├─────────────────────┤
                    │ # name: string      │
                    ├─────────────────────┤
                    │ + area() = 0        │◄── Pure virtual (= 0)
                    │ + perimeter() = 0   │◄── Pure virtual (= 0)
                    │ + draw() = 0        │◄── Pure virtual (= 0)
                    │ + describe()        │◄── Regular virtual
                    └──────────┬──────────┘
                               │
            ┌──────────────────┼──────────────────┐
            │                  │                  │
            ▼                  ▼                  ▼
    ┌───────────────┐  ┌───────────────┐  ┌───────────────┐
    │    Circle     │  │   Rectangle   │  │   Triangle    │
    ├───────────────┤  ├───────────────┤  ├───────────────┤
    │ - radius      │  │ - width       │  │ - a, b, c     │
    ├───────────────┤  │ - height      │  ├───────────────┤
    │ + area()  ✓   │  ├───────────────┤  │ + area()  ✓   │
    │ + perimeter()✓│  │ + area()  ✓   │  │ + perimeter()✓│
    │ + draw()  ✓   │  │ + perimeter()✓│  │ + draw()  ✓   │
    └───────────────┘  │ + draw()  ✓   │  └───────────────┘
                       └───────────────┘
                       
    ✓ = MUST implement all pure virtual functions to be concrete

═══════════════════════════════════════════════════════════════════

    Shape* s = new Shape();     // ❌ ERROR: Abstract class
    Shape* s = new Circle(5);   // ✓ OK: Circle is concrete
    
═══════════════════════════════════════════════════════════════════
```

### 2. Abstract Base Classes
**What is an Abstract Class?**
An abstract class is a class that contains at least one pure virtual function. It cannot be instantiated directly and serves as a base for derived classes.

``` ┌─────────────────────────────────────────────────────────────────┐
│                  ABSTRACT CLASS PROPERTIES                      │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  1. Contains at least one pure virtual function (= 0)           │
│  2. Cannot be instantiated directly                             │
│  3. Can have:                                                   │
│     • Pure virtual functions (must override)                    │
│     • Regular virtual functions (can override)                  │
│     • Non-virtual functions                                     │
│     • Data members                                              │
│     • Constructors and destructors                              │
│  4. Can have fully implemented methods                          │
│  5. Derived class must implement ALL pure virtual functions     │
│     to become concrete (instantiable)                           │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**Complete Abstract Class Example**

``` cpp
#include <iostream>
#include <string>
#include <vector>
#include <memory>
using namespace std;

// Abstract Base Class
class Employee {
protected:
    string name;
    int id;
    double baseSalary;

public:
    // Constructor
    Employee(const string& n, int i, double salary)
        : name(n), id(i), baseSalary(salary) {
        cout << "Employee constructor: " << name << endl;
    }

    // Virtual destructor (important for polymorphism!)
    virtual ~Employee() {
        cout << "Employee destructor: " << name << endl;
    }

    // Pure virtual functions - MUST be overridden
    virtual double calculatePay() const = 0;
    virtual string getRole() const = 0;

    // Regular virtual function - CAN be overridden
    virtual void displayInfo() const {
        cout << "ID: " << id << ", Name: " << name << endl;
        cout << "Role: " << getRole() << endl;
        cout << "Pay: $" << calculatePay() << endl;
    }

    // Non-virtual functions
    string getName() const { return name; }
    int getId() const { return id; }
};

// Concrete class - implements ALL pure virtual functions
class FullTimeEmployee : public Employee {
    double bonus;

public:
    FullTimeEmployee(const string& n, int i, double salary, double b)
        : Employee(n, i, salary), bonus(b) {}

    double calculatePay() const override {
        return baseSalary + bonus;
    }

    string getRole() const override {
        return "Full-Time Employee";
    }
};

// Another concrete class
class PartTimeEmployee : public Employee {
    int hoursWorked;
    double hourlyRate;

public:
    PartTimeEmployee(const string& n, int i, int hours, double rate)
        : Employee(n, i, 0), hoursWorked(hours), hourlyRate(rate) {}

    double calculatePay() const override {
        return hoursWorked * hourlyRate;
    }

    string getRole() const override {
        return "Part-Time Employee";
    }

    // Override displayInfo to add more details
    void displayInfo() const override {
        Employee::displayInfo();
        cout << "Hours: " << hoursWorked << " @ $" << hourlyRate << "/hr" << endl;
    }
};

// Another concrete class
class Contractor : public Employee {
    double projectFee;

public:
    Contractor(const string& n, int i, double fee)
        : Employee(n, i, 0), projectFee(fee) {}

    double calculatePay() const override {
        return projectFee;
    }

    string getRole() const override {
        return "Contractor";
    }
};

// Still abstract - doesn't implement all pure virtual functions
class Manager : public Employee {
protected:
    vector<Employee*> team;

public:
    Manager(const string& n, int i, double salary)
        : Employee(n, i, salary) {}

    void addTeamMember(Employee* e) {
        team.push_back(e);
    }

    // Implements getRole but NOT calculatePay
    string getRole() const override {
        return "Manager";
    }

    // Still abstract! calculatePay() not implemented
};

// Concrete Manager class
class DepartmentManager : public Manager {
    double managementBonus;

public:
    DepartmentManager(const string& n, int i, double salary, double bonus)
        : Manager(n, i, salary), managementBonus(bonus) {}

    double calculatePay() const override {
        return baseSalary + managementBonus;
    }

    string getRole() const override {
        return "Department Manager";
    }

    void displayInfo() const override {
        Employee::displayInfo();
        cout << "Team size: " << team.size() << endl;
    }
};

int main() {
    // Employee e("Test", 1, 1000);  // ERROR: Abstract class
    // Manager m("Test", 1, 1000);   // ERROR: Still abstract

    cout << "=== Creating Employees ===" << endl;
    
    FullTimeEmployee ft("Alice", 101, 5000, 1000);
    PartTimeEmployee pt("Bob", 102, 80, 25);
    Contractor con("Charlie", 103, 3000);
    DepartmentManager dm("Diana", 104, 7000, 2000);

    dm.addTeamMember(&ft);
    dm.addTeamMember(&pt);

    cout << "\n=== Employee Information ===" << endl;

    vector<Employee*> employees = {&ft, &pt, &con, &dm};

    for (Employee* e : employees) {
        cout << "\n--- " << e->getName() << " ---" << endl;
        e->displayInfo();
    }

    cout << "\n=== Total Payroll ===" << endl;
    double total = 0;
    for (Employee* e : employees) {
        total += e->calculatePay();
    }
    cout << "Total: $" << total << endl;

    cout << "\n=== Cleanup ===" << endl;
    return 0;
}
```

**Output:**

```text

=== Creating Employees ===
Employee constructor: Alice
Employee constructor: Bob
Employee constructor: Charlie
Employee constructor: Diana

=== Employee Information ===

--- Alice ---
ID: 101, Name: Alice
Role: Full-Time Employee
Pay: $6000

--- Bob ---
ID: 102, Name: Bob
Role: Part-Time Employee
Pay: $2000
Hours: 80 @ $25/hr

--- Charlie ---
ID: 103, Name: Charlie
Role: Contractor
Pay: $3000

--- Diana ---
ID: 104, Name: Diana
Role: Department Manager
Pay: $9000
Team size: 2

=== Total Payroll ===
Total: $20000

=== Cleanup ===
Employee destructor: Diana
Employee destructor: Charlie
Employee destructor: Bob
Employee destructor: Alice
```
**Abstract Class Hierarchy**
``` cpp
#include <iostream>
using namespace std;

// Level 1: Abstract
class Animal {
public:
    virtual ~Animal() = default;
    virtual void makeSound() const = 0;
    virtual void move() const = 0;
    virtual string getType() const = 0;
};

// Level 2: Still Abstract (only partially implements)
class Mammal : public Animal {
protected:
    int numberOfLegs;

public:
    Mammal(int legs) : numberOfLegs(legs) {}

    // Partial implementation - still abstract
    string getType() const override {
        return "Mammal";
    }

    // makeSound() and move() still pure virtual
};

// Level 3: Still Abstract
class Canine : public Mammal {
public:
    Canine() : Mammal(4) {}

    void makeSound() const override {
        cout << "Bark! Bark!" << endl;
    }

    // move() still pure virtual - class is still abstract
};

// Level 4: Concrete (all pure virtuals implemented)
class Dog : public Canine {
    string breed;

public:
    Dog(const string& b) : breed(b) {}

    void move() const override {
        cout << "The " << breed << " runs on " << numberOfLegs << " legs" << endl;
    }

    string getType() const override {
        return "Dog (" + breed + ")";
    }
};

class Wolf : public Canine {
public:
    void move() const override {
        cout << "The wolf runs swiftly through the forest" << endl;
    }

    string getType() const override {
        return "Wolf";
    }
};

int main() {
    // Animal a;      // ERROR: Abstract
    // Mammal m(4);   // ERROR: Abstract
    // Canine c;      // ERROR: Abstract

    Dog dog("Labrador");
    Wolf wolf;

    cout << "=== Dog ===" << endl;
    cout << "Type: " << dog.getType() << endl;
    dog.makeSound();
    dog.move();

    cout << "\n=== Wolf ===" << endl;
    cout << "Type: " << wolf.getType() << endl;
    wolf.makeSound();
    wolf.move();

    cout << "\n=== Polymorphism ===" << endl;
    Animal* animals[] = {&dog, &wolf};
    for (Animal* a : animals) {
        cout << a->getType() << ": ";
        a->makeSound();
    }

    return 0;
}
```
**Visual: Abstract Class Hierarchy**
```
═══════════════════════════════════════════════════════════════════
                    ABSTRACT CLASS HIERARCHY
═══════════════════════════════════════════════════════════════════

    ┌─────────────────────────────────────────────────────────────┐
    │                     Animal (Abstract)                       │
    │  ─────────────────────────────────────────────────────────  │
    │  Pure Virtual: makeSound() = 0                              │
    │  Pure Virtual: move() = 0                                   │
    │  Pure Virtual: getType() = 0                                │
    │  ─────────────────────────────────────────────────────────  │
    │  Unimplemented: 3                    Instantiable: ❌       │
    └─────────────────────────┬───────────────────────────────────┘
                              │
                              ▼
    ┌─────────────────────────────────────────────────────────────┐
    │                    Mammal (Abstract)                        │
    │  ─────────────────────────────────────────────────────────  │
    │  ✓ Implements: getType()                                    │
    │  Pure Virtual: makeSound() = 0  (inherited)                 │
    │  Pure Virtual: move() = 0  (inherited)                      │
    │  ─────────────────────────────────────────────────────────  │
    │  Unimplemented: 2                    Instantiable: ❌       │
    └─────────────────────────┬───────────────────────────────────┘
                              │
                              ▼
    ┌─────────────────────────────────────────────────────────────┐
    │                    Canine (Abstract)                        │
    │  ─────────────────────────────────────────────────────────  │
    │  ✓ Implements: makeSound()                                  │
    │  ✓ Inherits: getType()                                      │
    │  Pure Virtual: move() = 0  (still not implemented)          │
    │  ─────────────────────────────────────────────────────────  │
    │  Unimplemented: 1                    Instantiable: ❌       │
    └─────────────────────────┬───────────────────────────────────┘
                              │
            ┌─────────────────┴─────────────────┐
            ▼                                   ▼
    ┌─────────────────────┐           ┌─────────────────────┐
    │   Dog (Concrete)    │           │   Wolf (Concrete)   │
    │  ─────────────────  │           │  ─────────────────  │
    │  ✓ Implements:      │           │  ✓ Implements:      │
    │    move()           │           │    move()           │
    │    getType()        │           │    getType()        │
    │  ─────────────────  │           │  ─────────────────  │
    │  Unimplemented: 0   │           │  Unimplemented: 0   │
    │  Instantiable: ✓    │           │  Instantiable: ✓    │
    └─────────────────────┘           └─────────────────────┘

═══════════════════════════════════════════════════════════════════
```
### 3. Interfaces in C++
**What is an Interface?**
C++ doesn't have a dedicated interface keyword like Java or C#. Instead, interfaces are implemented as abstract classes with only pure virtual functions and no data members.

``` cpp
┌─────────────────────────────────────────────────────────────────┐
│                    INTERFACE IN C++                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  An interface is typically:                                     │
│                                                                 │
│  1. All member functions are pure virtual                       │
│  2. No data members (or only static const)                      │
│  3. No function implementations (except destructor)             │
│  4. Virtual destructor (usually defaulted)                      │
│  5. No constructors (or only default/deleted)                   │
│                                                                 │
│  NAMING CONVENTION:                                             │
│  • Prefix with 'I' (IDrawable, ISerializable)                   │
│  • Suffix with 'able' (Drawable, Serializable)                  │
│  • Suffix with 'Interface' (DrawingInterface)                   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**Basic Interface Example**
``` cpp
#include <iostream>
#include <string>
#include <vector>
#include <memory>
using namespace std;

// ═══════════════════════════════════════════════════════════════
// INTERFACE: Only pure virtual functions
// ═══════════════════════════════════════════════════════════════

class IDrawable {
public:
    virtual ~IDrawable() = default;

    virtual void draw() const = 0;
    virtual void resize(double factor) = 0;
    virtual string getDescription() const = 0;
};

class IPrintable {
public:
    virtual ~IPrintable() = default;

    virtual void print() const = 0;
    virtual string toString() const = 0;
};

class ISerializable {
public:
    virtual ~ISerializable() = default;

    virtual string serialize() const = 0;
    virtual void deserialize(const string& data) = 0;
};

// ═══════════════════════════════════════════════════════════════
// CLASS IMPLEMENTING MULTIPLE INTERFACES
// ═══════════════════════════════════════════════════════════════

class Circle : public IDrawable, public IPrintable, public ISerializable {
    double radius;
    double x, y;

public:
    Circle(double r, double xPos = 0, double yPos = 0)
        : radius(r), x(xPos), y(yPos) {}

    // IDrawable implementation
    void draw() const override {
        cout << "Drawing circle at (" << x << ", " << y 
             << ") with radius " << radius << endl;
    }

    void resize(double factor) override {
        radius *= factor;
        cout << "Resized circle to radius " << radius << endl;
    }

    string getDescription() const override {
        return "Circle with radius " + to_string(radius);
    }

    // IPrintable implementation
    void print() const override {
        cout << toString() << endl;
    }

    string toString() const override {
        return "Circle(r=" + to_string(radius) + 
               ", x=" + to_string(x) + 
               ", y=" + to_string(y) + ")";
    }

    // ISerializable implementation
    string serialize() const override {
        return "CIRCLE:" + to_string(radius) + "," + 
               to_string(x) + "," + to_string(y);
    }

    void deserialize(const string& data) override {
        // Simple parsing (in real code, use proper parsing)
        cout << "Deserializing: " << data << endl;
    }
};

class Rectangle : public IDrawable, public IPrintable {
    double width, height;

public:
    Rectangle(double w, double h) : width(w), height(h) {}

    // IDrawable
    void draw() const override {
        cout << "Drawing rectangle " << width << " x " << height << endl;
    }

    void resize(double factor) override {
        width *= factor;
        height *= factor;
    }

    string getDescription() const override {
        return "Rectangle " + to_string(width) + "x" + to_string(height);
    }

    // IPrintable
    void print() const override {
        cout << toString() << endl;
    }

    string toString() const override {
        return "Rectangle(w=" + to_string(width) + ", h=" + to_string(height) + ")";
    }
};

// ═══════════════════════════════════════════════════════════════
// FUNCTIONS WORKING WITH INTERFACES
// ═══════════════════════════════════════════════════════════════

void drawAll(const vector<IDrawable*>& drawables) {
    cout << "Drawing all items:" << endl;
    for (const auto* d : drawables) {
        d->draw();
    }
}

void printAll(const vector<IPrintable*>& printables) {
    cout << "Printing all items:" << endl;
    for (const auto* p : printables) {
        p->print();
    }
}

void saveAll(const vector<ISerializable*>& items) {
    cout << "Serializing all items:" << endl;
    for (const auto* s : items) {
        cout << "  " << s->serialize() << endl;
    }
}

int main() {
    Circle circle(5.0, 10, 20);
    Rectangle rect(4.0, 6.0);

    cout << "=== Individual Operations ===" << endl;
    circle.draw();
    circle.print();
    cout << "Serialized: " << circle.serialize() << endl;

    cout << "\n=== Polymorphism via IDrawable ===" << endl;
    vector<IDrawable*> drawables = {&circle, &rect};
    drawAll(drawables);

    cout << "\n=== Polymorphism via IPrintable ===" << endl;
    vector<IPrintable*> printables = {&circle, &rect};
    printAll(printables);

    cout << "\n=== Polymorphism via ISerializable ===" << endl;
    vector<ISerializable*> serializables = {&circle};
    saveAll(serializables);

    cout << "\n=== Resize via IDrawable ===" << endl;
    for (auto* d : drawables) {
        d->resize(2.0);
    }
    drawAll(drawables);

    return 0;
}
```

**Output:**
```text

=== Individual Operations ===
Drawing circle at (10, 20) with radius 5
Circle(r=5.000000, x=10.000000, y=20.000000)
Serialized: CIRCLE:5.000000,10.000000,20.000000

=== Polymorphism via IDrawable ===
Drawing all items:
Drawing circle at (10, 20) with radius 5
Drawing rectangle 4 x 6

=== Polymorphism via IPrintable ===
Printing all items:
Circle(r=5.000000, x=10.000000, y=20.000000)
Rectangle(w=4.000000, h=6.000000)

=== Polymorphism via ISerializable ===
Serializing all items:
  CIRCLE:5.000000,10.000000,20.000000

=== Resize via IDrawable ===
Resized circle to radius 10
Drawing all items:
Drawing circle at (10, 20) with radius 10
Drawing rectangle 8 x 12
```
**Modern C++ Interface (C++20 Concepts)**

``` cpp
#include <iostream>
#include <concepts>
#include <string>
using namespace std;

// C++20: Concepts can define interface requirements at compile time

template<typename T>
concept Drawable = requires(T t, double factor) {
    { t.draw() } -> same_as<void>;
    { t.resize(factor) } -> same_as<void>;
    { t.getDescription() } -> same_as<string>;
};

template<typename T>
concept Printable = requires(T t) {
    { t.print() } -> same_as<void>;
    { t.toString() } -> same_as<string>;
};

// Classes don't need to inherit from anything
class Square {
    double side;

public:
    Square(double s) : side(s) {}

    // Satisfies Drawable concept
    void draw() const {
        cout << "Drawing square with side " << side << endl;
    }

    void resize(double factor) {
        side *= factor;
    }

    string getDescription() const {
        return "Square with side " + to_string(side);
    }

    // Satisfies Printable concept
    void print() const {
        cout << toString() << endl;
    }

    string toString() const {
        return "Square(" + to_string(side) + ")";
    }
};

// Function constrained by concept
template<Drawable T>
void drawShape(const T& shape) {
    cout << "Drawing: " << shape.getDescription() << endl;
    shape.draw();
}

template<Printable T>
void printItem(const T& item) {
    item.print();
}

int main() {
    Square sq(5.0);

    drawShape(sq);   // Works: Square satisfies Drawable
    printItem(sq);   // Works: Square satisfies Printable

    return 0;
}
```

### 4. Interfaces vs Abstract Classes
**Comparison Table**

```
┌─────────────────────────────────────────────────────────────────┐
│              INTERFACE vs ABSTRACT CLASS                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  FEATURE              INTERFACE            ABSTRACT CLASS       │
│  ───────              ─────────            ──────────────       │
│                                                                 │
│  Purpose              Define contract      Provide base +       │
│                       (what to do)         partial impl         │
│                                            (what + how)         │
│                                                                 │
│  Pure Virtual         All functions        Some functions       │
│  Functions                                                      │
│                                                                 │
│  Implementation       None (except dtor)   Can have any         │
│                                                                 │
│  Data Members         None                 Can have any         │
│                                                                 │
│  Constructors         None/deleted         Can have             │
│                                                                 │
│  Multiple             Safe (no state)      Diamond problem      │
│  Inheritance          No diamond problem   possible             │
│                                                                 │
│  State                Stateless            Can have state       │
│                                                                 │
│  Coupling             Loose                Tighter              │
│                                                                 │
│  Use Case             Capabilities         Is-a relationship    │
│                       "Can do X"           with shared code     │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**Side-by-Side Example**

``` cpp
#include <iostream>
#include <string>
using namespace std;

// ═══════════════════════════════════════════════════════════════
// INTERFACE: Pure contract, no implementation
// ═══════════════════════════════════════════════════════════════

class IFlyable {
public:
    virtual ~IFlyable() = default;

    virtual void takeOff() = 0;
    virtual void fly() = 0;
    virtual void land() = 0;
    virtual int getAltitude() const = 0;

    // NO data members
    // NO implementation
    // NO constructors (besides default virtual destructor)
};

class ISwimmable {
public:
    virtual ~ISwimmable() = default;

    virtual void dive() = 0;
    virtual void swim() = 0;
    virtual void surface() = 0;
    virtual int getDepth() const = 0;
};

// ═══════════════════════════════════════════════════════════════
// ABSTRACT CLASS: Partial implementation + shared state
// ═══════════════════════════════════════════════════════════════

class Bird {
protected:
    string name;
    int age;
    double weight;

public:
    Bird(const string& n, int a, double w)
        : name(n), age(a), weight(w) {}

    virtual ~Bird() = default;

    // Pure virtual - must be overridden
    virtual void makeSound() const = 0;
    virtual string getSpecies() const = 0;

    // Virtual with implementation - can be overridden
    virtual void eat() {
        cout << name << " is eating" << endl;
    }

    virtual void sleep() {
        cout << name << " is sleeping" << endl;
    }

    // Non-virtual - shared implementation
    string getName() const { return name; }
    int getAge() const { return age; }

    void displayInfo() const {
        cout << "Name: " << name << ", Species: " << getSpecies()
             << ", Age: " << age << ", Weight: " << weight << "kg" << endl;
    }
};

// ═══════════════════════════════════════════════════════════════
// CONCRETE CLASSES
// ═══════════════════════════════════════════════════════════════

// Duck: Is-a Bird AND can Fly AND can Swim
class Duck : public Bird, public IFlyable, public ISwimmable {
    int currentAltitude = 0;
    int currentDepth = 0;

public:
    Duck(const string& name, int age, double weight)
        : Bird(name, age, weight) {}

    // Bird abstract methods
    void makeSound() const override {
        cout << name << " says: Quack!" << endl;
    }

    string getSpecies() const override {
        return "Duck";
    }

    // IFlyable implementation
    void takeOff() override {
        currentAltitude = 10;
        cout << name << " takes off!" << endl;
    }

    void fly() override {
        currentAltitude = 100;
        cout << name << " is flying at " << currentAltitude << "m" << endl;
    }

    void land() override {
        currentAltitude = 0;
        cout << name << " has landed" << endl;
    }

    int getAltitude() const override {
        return currentAltitude;
    }

    // ISwimmable implementation
    void dive() override {
        currentDepth = 5;
        cout << name << " dives underwater!" << endl;
    }

    void swim() override {
        cout << name << " is swimming at depth " << currentDepth << "m" << endl;
    }

    void surface() override {
        currentDepth = 0;
        cout << name << " surfaces" << endl;
    }

    int getDepth() const override {
        return currentDepth;
    }
};

// Penguin: Is-a Bird AND can Swim (but NOT fly!)
class Penguin : public Bird, public ISwimmable {
    int currentDepth = 0;

public:
    Penguin(const string& name, int age, double weight)
        : Bird(name, age, weight) {}

    // Bird abstract methods
    void makeSound() const override {
        cout << name << " says: Honk!" << endl;
    }

    string getSpecies() const override {
        return "Penguin";
    }

    // ISwimmable implementation
    void dive() override {
        currentDepth = 20;  // Penguins can dive deep!
        cout << name << " dives deep!" << endl;
    }

    void swim() override {
        cout << name << " is swimming expertly at depth " << currentDepth << "m" << endl;
    }

    void surface() override {
        currentDepth = 0;
        cout << name << " surfaces" << endl;
    }

    int getDepth() const override {
        return currentDepth;
    }
};

// Airplane: NOT a Bird, but can Fly
class Airplane : public IFlyable {
    string model;
    int altitude = 0;

public:
    Airplane(const string& m) : model(m) {}

    void takeOff() override {
        altitude = 1000;
        cout << model << " taking off!" << endl;
    }

    void fly() override {
        altitude = 35000;
        cout << model << " cruising at " << altitude << " feet" << endl;
    }

    void land() override {
        altitude = 0;
        cout << model << " has landed" << endl;
    }

    int getAltitude() const override {
        return altitude;
    }
};

// ═══════════════════════════════════════════════════════════════
// FUNCTIONS DEMONSTRATING INTERFACE VS ABSTRACT CLASS USAGE
// ═══════════════════════════════════════════════════════════════

// Works with ANY flyable thing (interface)
void conductFlight(IFlyable& flyer) {
    cout << "\n--- Flight Sequence ---" << endl;
    flyer.takeOff();
    flyer.fly();
    cout << "Current altitude: " << flyer.getAltitude() << endl;
    flyer.land();
}

// Works with ANY swimmable thing (interface)
void conductSwim(ISwimmable& swimmer) {
    cout << "\n--- Swim Sequence ---" << endl;
    swimmer.dive();
    swimmer.swim();
    cout << "Current depth: " << swimmer.getDepth() << endl;
    swimmer.surface();
}

// Works only with Birds (abstract class hierarchy)
void birdRoutine(Bird& bird) {
    cout << "\n--- Bird Routine for " << bird.getName() << " ---" << endl;
    bird.displayInfo();
    bird.makeSound();
    bird.eat();
    bird.sleep();
}

int main() {
    Duck donald("Donald", 5, 3.5);
    Penguin pingu("Pingu", 3, 25.0);
    Airplane boeing("Boeing 747");

    cout << "========== INTERFACE USAGE ==========" << endl;
    
    cout << "\n[Flying things - Duck and Airplane]" << endl;
    conductFlight(donald);
    conductFlight(boeing);
    // conductFlight(pingu);  // ERROR: Penguin doesn't implement IFlyable

    cout << "\n[Swimming things - Duck and Penguin]" << endl;
    conductSwim(donald);
    conductSwim(pingu);
    // conductSwim(boeing);  // ERROR: Airplane doesn't implement ISwimmable

    cout << "\n========== ABSTRACT CLASS USAGE ==========" << endl;
    birdRoutine(donald);
    birdRoutine(pingu);
    // birdRoutine(boeing);  // ERROR: Airplane is not a Bird

    return 0;
}
```

**Visual Comparison**

```
═══════════════════════════════════════════════════════════════════
                    INTERFACE vs ABSTRACT CLASS
═══════════════════════════════════════════════════════════════════

    INTERFACE (Capability-based)          ABSTRACT CLASS (Hierarchy-based)
    ─────────────────────────────         ─────────────────────────────────

    ┌───────────────────┐                 ┌───────────────────────────┐
    │    IFlyable       │                 │       Bird                │
    ├───────────────────┤                 ├───────────────────────────┤
    │ (no data)         │                 │ # name: string            │
    ├───────────────────┤                 │ # age: int                │
    │ + takeOff() = 0   │                 │ # weight: double          │
    │ + fly() = 0       │                 ├───────────────────────────┤
    │ + land() = 0      │                 │ + makeSound() = 0         │
    └───────────────────┘                 │ + getSpecies() = 0        │
            ▲                             │ + eat() { impl }          │
            │                             │ + sleep() { impl }        │
    "I CAN fly"                           │ + displayInfo() { impl }  │
                                          └───────────────────────────┘
                                                      ▲
                                                      │
                                                 "I AM a Bird"


    Multiple interfaces:                  Single inheritance + interfaces:

       ┌─────────┐   ┌─────────────┐           ┌─────────────────┐
       │IFlyable │   │ ISwimmable  │           │      Bird       │
       └────┬────┘   └──────┬──────┘           └────────┬────────┘
            │               │                           │
            └───────┬───────┘            ┌──────────────┼──────────────┐
                    │                    │              │              │
                    ▼                    ▼              ▼              ▼
              ┌──────────┐         ┌──────────┐  ┌──────────┐  ┌──────────┐
              │   Duck   │         │  Eagle   │  │  Penguin │  │   Duck   │
              └──────────┘         └──────────┘  └──────────┘  └──────────┘
    
    Duck can fly AND swim          All share Bird's implementation

═══════════════════════════════════════════════════════════════════

    WHEN TO USE INTERFACE:                WHEN TO USE ABSTRACT CLASS:
    ──────────────────────                ────────────────────────────
    
    ✓ Define capability/behavior          ✓ Define "is-a" relationship
    ✓ Unrelated classes share behavior    ✓ Share code among related classes
    ✓ Multiple inheritance needed         ✓ Need protected members
    ✓ Loose coupling desired              ✓ Need constructors/state
    ✓ Dependency injection                ✓ Template method pattern
    ✓ Mocking in unit tests              ✓ Partial implementation

═══════════════════════════════════════════════════════════════════
```

### 5. Design Patterns with Abstract Classes
**Strategy Pattern**

``` cpp
#include <iostream>
#include <memory>
using namespace std;

// Strategy Interface
class ISortStrategy {
public:
    virtual ~ISortStrategy() = default;
    virtual void sort(int arr[], int size) = 0;
    virtual string getName() const = 0;
};

// Concrete Strategies
class BubbleSort : public ISortStrategy {
public:
    void sort(int arr[], int size) override {
        cout << "Sorting with Bubble Sort..." << endl;
        for (int i = 0; i < size - 1; i++) {
            for (int j = 0; j < size - i - 1; j++) {
                if (arr[j] > arr[j + 1]) {
                    swap(arr[j], arr[j + 1]);
                }
            }
        }
    }

    string getName() const override { return "Bubble Sort"; }
};

class QuickSort : public ISortStrategy {
    void quickSort(int arr[], int low, int high) {
        if (low < high) {
            int pivot = arr[high];
            int i = low - 1;
            for (int j = low; j < high; j++) {
                if (arr[j] < pivot) {
                    i++;
                    swap(arr[i], arr[j]);
                }
            }
            swap(arr[i + 1], arr[high]);
            int pi = i + 1;
            quickSort(arr, low, pi - 1);
            quickSort(arr, pi + 1, high);
        }
    }

public:
    void sort(int arr[], int size) override {
        cout << "Sorting with Quick Sort..." << endl;
        quickSort(arr, 0, size - 1);
    }

    string getName() const override { return "Quick Sort"; }
};

// Context
class Sorter {
    unique_ptr<ISortStrategy> strategy;

public:
    void setStrategy(unique_ptr<ISortStrategy> s) {
        strategy = move(s);
    }

    void performSort(int arr[], int size) {
        if (strategy) {
            cout << "Using: " << strategy->getName() << endl;
            strategy->sort(arr, size);
        }
    }
};

void printArray(int arr[], int size) {
    for (int i = 0; i < size; i++) {
        cout << arr[i] << " ";
    }
    cout << endl;
}

int main() {
    int arr1[] = {64, 34, 25, 12, 22, 11, 90};
    int arr2[] = {64, 34, 25, 12, 22, 11, 90};
    int size = 7;

    Sorter sorter;

    cout << "Original array: ";
    printArray(arr1, size);

    cout << "\n=== Using Bubble Sort ===" << endl;
    sorter.setStrategy(make_unique<BubbleSort>());
    sorter.performSort(arr1, size);
    cout << "Sorted: ";
    printArray(arr1, size);

    cout << "\n=== Using Quick Sort ===" << endl;
    sorter.setStrategy(make_unique<QuickSort>());
    sorter.performSort(arr2, size);
    cout << "Sorted: ";
    printArray(arr2, size);

    return 0;
}
```
**Template Method Pattern**
``` cpp
#include <iostream>
#include <string>
using namespace std;

// Abstract class with Template Method
class DataProcessor {
public:
    virtual ~DataProcessor() = default;

    // Template method - defines the algorithm skeleton
    void process() {
        cout << "=== Starting Data Processing ===" << endl;
        readData();
        validateData();
        transformData();
        saveData();
        cout << "=== Processing Complete ===" << endl;
    }

protected:
    // Abstract steps - MUST be implemented
    virtual void readData() = 0;
    virtual void transformData() = 0;

    // Hook methods - CAN be overridden (have default implementation)
    virtual void validateData() {
        cout << "Performing standard validation..." << endl;
    }

    virtual void saveData() {
        cout << "Saving to default location..." << endl;
    }
};

class CSVProcessor : public DataProcessor {
protected:
    void readData() override {
        cout << "Reading data from CSV file..." << endl;
    }

    void transformData() override {
        cout << "Parsing CSV and converting to objects..." << endl;
    }

    // Using default validateData and saveData
};

class JSONProcessor : public DataProcessor {
protected:
    void readData() override {
        cout << "Reading data from JSON API..." << endl;
    }

    void transformData() override {
        cout << "Parsing JSON and mapping to schema..." << endl;
    }

    void validateData() override {
        cout << "Validating JSON schema..." << endl;
        cout << "Checking required fields..." << endl;
    }

    void saveData() override {
        cout << "Saving to MongoDB database..." << endl;
    }
};

class XMLProcessor : public DataProcessor {
protected:
    void readData() override {
        cout << "Reading data from XML document..." << endl;
    }

    void transformData() override {
        cout << "Parsing XML nodes and attributes..." << endl;
    }

    void validateData() override {
        cout << "Validating against XSD schema..." << endl;
    }
};

int main() {
    cout << ">>> CSV Processing" << endl;
    CSVProcessor csv;
    csv.process();

    cout << "\n>>> JSON Processing" << endl;
    JSONProcessor json;
    json.process();

    cout << "\n>>> XML Processing" << endl;
    XMLProcessor xml;
    xml.process();

    return 0;
}
```
**Factory Method Pattern**

``` cpp
#include <iostream>
#include <memory>
#include <string>
using namespace std;

// Product interface
class IDocument {
public:
    virtual ~IDocument() = default;
    virtual void open() = 0;
    virtual void close() = 0;
    virtual void save() = 0;
    virtual string getType() const = 0;
};

// Concrete products
class PDFDocument : public IDocument {
public:
    void open() override { cout << "Opening PDF document..." << endl; }
    void close() override { cout << "Closing PDF document..." << endl; }
    void save() override { cout << "Saving PDF document..." << endl; }
    string getType() const override { return "PDF"; }
};

class WordDocument : public IDocument {
public:
    void open() override { cout << "Opening Word document..." << endl; }
    void close() override { cout << "Closing Word document..." << endl; }
    void save() override { cout << "Saving Word document..." << endl; }
    string getType() const override { return "Word"; }
};

class SpreadsheetDocument : public IDocument {
public:
    void open() override { cout << "Opening Spreadsheet..." << endl; }
    void close() override { cout << "Closing Spreadsheet..." << endl; }
    void save() override { cout << "Saving Spreadsheet..." << endl; }
    string getType() const override { return "Spreadsheet"; }
};

// Creator abstract class
class Application {
public:
    virtual ~Application() = default;

    // Factory method - abstract
    virtual unique_ptr<IDocument> createDocument() = 0;

    // Common operation using factory method
    void newDocument() {
        auto doc = createDocument();
        cout << "Created new " << doc->getType() << " document" << endl;
        doc->open();
        documents.push_back(move(doc));
    }

    void saveAll() {
        for (auto& doc : documents) {
            doc->save();
        }
    }

    void closeAll() {
        for (auto& doc : documents) {
            doc->close();
        }
        documents.clear();
    }

protected:
    vector<unique_ptr<IDocument>> documents;
};

// Concrete creators
class PDFApplication : public Application {
public:
    unique_ptr<IDocument> createDocument() override {
        return make_unique<PDFDocument>();
    }
};

class WordApplication : public Application {
public:
    unique_ptr<IDocument> createDocument() override {
        return make_unique<WordDocument>();
    }
};

class SpreadsheetApplication : public Application {
public:
    unique_ptr<IDocument> createDocument() override {
        return make_unique<SpreadsheetDocument>();
    }
};

int main() {
    cout << "=== PDF Application ===" << endl;
    PDFApplication pdfApp;
    pdfApp.newDocument();
    pdfApp.newDocument();
    pdfApp.saveAll();
    pdfApp.closeAll();

    cout << "\n=== Word Application ===" << endl;
    WordApplication wordApp;
    wordApp.newDocument();
    wordApp.saveAll();
    wordApp.closeAll();

    return 0;
}
```

### 6. Multiple Inheritance & Interfaces
**Safe Multiple Inheritance with Interfaces**

``` cpp
#include <iostream>
#include <string>
using namespace std;

// Pure interfaces - safe for multiple inheritance
class IPlayable {
public:
    virtual ~IPlayable() = default;
    virtual void play() = 0;
    virtual void pause() = 0;
    virtual void stop() = 0;
};

class IRecordable {
public:
    virtual ~IRecordable() = default;
    virtual void startRecording() = 0;
    virtual void stopRecording() = 0;
};

class IStreamable {
public:
    virtual ~IStreamable() = default;
    virtual void stream(const string& url) = 0;
    virtual void stopStream() = 0;
};

class IVolumeControl {
public:
    virtual ~IVolumeControl() = default;
    virtual void setVolume(int level) = 0;
    virtual int getVolume() const = 0;
    virtual void mute() = 0;
    virtual void unmute() = 0;
};

// Concrete class implementing multiple interfaces
class SmartMediaPlayer : public IPlayable, public IRecordable, 
                         public IStreamable, public IVolumeControl {
    string currentMedia;
    bool isPlaying = false;
    bool isRecording = false;
    bool isStreaming = false;
    int volume = 50;
    bool isMuted = false;

public:
    // IPlayable
    void play() override {
        isPlaying = true;
        cout << "▶ Playing media..." << endl;
    }

    void pause() override {
        isPlaying = false;
        cout << "⏸ Paused" << endl;
    }

    void stop() override {
        isPlaying = false;
        cout << "⏹ Stopped" << endl;
    }

    // IRecordable
    void startRecording() override {
        isRecording = true;
        cout << "⏺ Recording started..." << endl;
    }

    void stopRecording() override {
        isRecording = false;
        cout << "⏹ Recording stopped" << endl;
    }

    // IStreamable
    void stream(const string& url) override {
        isStreaming = true;
        cout << "📡 Streaming from: " << url << endl;
    }

    void stopStream() override {
        isStreaming = false;
        cout << "📡 Stream stopped" << endl;
    }

    // IVolumeControl
    void setVolume(int level) override {
        volume = max(0, min(100, level));
        cout << "🔊 Volume: " << volume << "%" << endl;
    }

    int getVolume() const override {
        return isMuted ? 0 : volume;
    }

    void mute() override {
        isMuted = true;
        cout << "🔇 Muted" << endl;
    }

    void unmute() override {
        isMuted = false;
        cout << "🔊 Unmuted" << endl;
    }

    void status() const {
        cout << "\n--- Status ---" << endl;
        cout << "Playing: " << (isPlaying ? "Yes" : "No") << endl;
        cout << "Recording: " << (isRecording ? "Yes" : "No") << endl;
        cout << "Streaming: " << (isStreaming ? "Yes" : "No") << endl;
        cout << "Volume: " << getVolume() << "%" << endl;
    }
};

// Functions that work with specific interfaces
void playMedia(IPlayable& player) {
    player.play();
}

void recordSession(IRecordable& recorder) {
    recorder.startRecording();
}

void adjustVolume(IVolumeControl& vc, int level) {
    vc.setVolume(level);
}

int main() {
    SmartMediaPlayer player;

    cout << "=== Using SmartMediaPlayer ===" << endl;
    
    // Can use through any interface
    playMedia(player);
    recordSession(player);
    adjustVolume(player, 75);
    
    player.stream("https://example.com/stream");
    
    player.status();
    
    cout << "\n=== Controlling playback ===" << endl;
    player.pause();
    player.mute();
    player.stopRecording();
    player.stopStream();
    
    player.status();

    return 0;
}
```

**Diamond Problem and Virtual Inheritance**
``` cpp
#include <iostream>
using namespace std;

// ═══════════════════════════════════════════════════════════════
// PROBLEM: Diamond inheritance with abstract classes
// ═══════════════════════════════════════════════════════════════

class Animal {
protected:
    string name;

public:
    Animal(const string& n) : name(n) {
        cout << "Animal constructor: " << name << endl;
    }

    virtual ~Animal() {
        cout << "Animal destructor: " << name << endl;
    }

    virtual void eat() = 0;
    virtual void sleep() {
        cout << name << " is sleeping" << endl;
    }
};

// Virtual inheritance to solve diamond problem
class Mammal : virtual public Animal {
protected:
    bool hasFur;

public:
    Mammal(const string& n, bool fur) : Animal(n), hasFur(fur) {
        cout << "Mammal constructor" << endl;
    }

    void eat() override {
        cout << name << " (mammal) is eating" << endl;
    }
};

class WingedAnimal : virtual public Animal {
protected:
    double wingspan;

public:
    WingedAnimal(const string& n, double ws) : Animal(n), wingspan(ws) {
        cout << "WingedAnimal constructor" << endl;
    }

    virtual void fly() {
        cout << name << " is flying with wingspan " << wingspan << endl;
    }

    void eat() override {
        cout << name << " (winged) is eating" << endl;
    }
};

// Bat inherits from both Mammal and WingedAnimal
class Bat : public Mammal, public WingedAnimal {
public:
    // Must explicitly initialize virtual base class
    Bat(const string& n) 
        : Animal(n)              // Virtual base initialized first
        , Mammal(n, true)        // Then Mammal
        , WingedAnimal(n, 0.5)   // Then WingedAnimal
    {
        cout << "Bat constructor" << endl;
    }

    // Must resolve ambiguity
    void eat() override {
        cout << name << " (bat) is eating insects" << endl;
    }
};

int main() {
    cout << "=== Creating Bat ===" << endl;
    Bat bat("Bruce");

    cout << "\n=== Bat behaviors ===" << endl;
    bat.eat();      // Bat's version
    bat.sleep();    // From Animal
    bat.fly();      // From WingedAnimal

    cout << "\n=== Cleanup ===" << endl;
    return 0;
}
```

**Visual: Diamond Problem**

```
═══════════════════════════════════════════════════════════════════
                    DIAMOND PROBLEM
═══════════════════════════════════════════════════════════════════

    WITHOUT virtual inheritance:        WITH virtual inheritance:
    ─────────────────────────────       ─────────────────────────────

           ┌────────┐                          ┌────────┐
           │ Animal │                          │ Animal │
           └───┬────┘                          └───┬────┘
               │                                   │
        ┌──────┴──────┐                     ┌──────┴──────┐
        │             │                     │  (virtual)  │
        ▼             ▼                     ▼             ▼
    ┌────────┐   ┌────────────┐        ┌────────┐   ┌────────────┐
    │ Mammal │   │WingedAnimal│        │ Mammal │   │WingedAnimal│
    │(Animal)│   │  (Animal)  │        │        │   │            │
    └───┬────┘   └─────┬──────┘        └───┬────┘   └─────┬──────┘
        │              │                   │              │
        └──────┬───────┘                   └──────┬───────┘
               │                                  │
               ▼                                  ▼
           ┌───────┐                          ┌───────┐
           │  Bat  │                          │  Bat  │
           │       │                          │       │
           │Animal?│ ← TWO copies!            │ ONE   │ ← Single copy
           │Animal?│                          │Animal │
           └───────┘                          └───────┘

    PROBLEM:                             SOLUTION:
    • Bat has TWO Animal subobjects      • Bat has ONE Animal subobject
    • Ambiguous: which name?             • No ambiguity
    • Wastes memory                      • Efficient
    • Confusing behavior                 • Clear behavior

═══════════════════════════════════════════════════════════════════
```

### 7. Best Practices
**Guidelines for Abstract Classes**

``` cpp
#include <iostream>
#include <memory>
using namespace std;

// ═══════════════════════════════════════════════════════════════
// ✓ GOOD: Well-designed interface
// ═══════════════════════════════════════════════════════════════

class ILogger {
public:
    // ✓ Virtual destructor
    virtual ~ILogger() = default;

    // ✓ Pure virtual functions define contract
    virtual void log(const string& message) = 0;
    virtual void error(const string& message) = 0;
    virtual void warning(const string& message) = 0;

    // ✓ No data members
    // ✓ No implementation (except destructor)
};

// ═══════════════════════════════════════════════════════════════
// ✓ GOOD: Well-designed abstract class
// ═══════════════════════════════════════════════════════════════

class AbstractLogger {
protected:
    string loggerName;
    int logLevel;

    // ✓ Protected constructor - only for derived classes
    AbstractLogger(const string& name, int level)
        : loggerName(name), logLevel(level) {}

public:
    // ✓ Virtual destructor
    virtual ~AbstractLogger() = default;

    // ✓ Pure virtual - must implement
    virtual void writeLog(const string& message) = 0;

    // ✓ Virtual with implementation - can override
    virtual string formatMessage(const string& message) {
        return "[" + loggerName + "] " + message;
    }

    // ✓ Non-virtual - shared implementation
    void log(const string& message) {
        if (shouldLog()) {
            writeLog(formatMessage(message));
        }
    }

    // ✓ Protected helper
protected:
    bool shouldLog() const {
        return logLevel > 0;
    }
};

// ═══════════════════════════════════════════════════════════════
// ✗ BAD: Poorly designed abstract class
// ═══════════════════════════════════════════════════════════════

class BadAbstractClass {
public:
    // ✗ Missing virtual destructor!
    ~BadAbstractClass() {}

    // ✗ Public data members in abstract class
    int publicData;

    // ✗ Mixed pure virtual and regular functions without clear purpose
    virtual void doSomething() = 0;
    void otherThing() { /* ... */ }

    // ✗ No protection for internal state
};

// ═══════════════════════════════════════════════════════════════
// EXAMPLE: Proper implementation
// ═══════════════════════════════════════════════════════════════

class ConsoleLogger : public AbstractLogger {
public:
    ConsoleLogger(const string& name)
        : AbstractLogger(name, 1) {}

    void writeLog(const string& message) override {
        cout << message << endl;
    }
};

class FileLogger : public AbstractLogger {
    string filename;

public:
    FileLogger(const string& name, const string& file)
        : AbstractLogger(name, 1), filename(file) {}

    void writeLog(const string& message) override {
        cout << "[FILE: " << filename << "] " << message << endl;
    }

    string formatMessage(const string& message) override {
        return "[" + loggerName + "][FILE] " + message;
    }
};

int main() {
    ConsoleLogger console("Console");
    FileLogger file("File", "app.log");

    console.log("Hello from console");
    file.log("Hello from file");

    // Polymorphism
    AbstractLogger* loggers[] = {&console, &file};
    for (auto* logger : loggers) {
        logger->log("Polymorphic message");
    }

    return 0;
}
```

**Complete Best Practices Checklist**
```
┌─────────────────────────────────────────────────────────────────┐
│           ABSTRACT CLASS & INTERFACE BEST PRACTICES             │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  INTERFACE DESIGN:                                              │
│  ─────────────────                                              │
│  ✓ All functions pure virtual (= 0)                            │
│  ✓ Virtual destructor (= default)                              │
│  ✓ No data members                                             │
│  ✓ No constructors (or deleted)                                │
│  ✓ Clear naming (IDrawable, ISerializable)                     │
│  ✓ Single responsibility                                       │
│  ✓ Small, focused interfaces                                   │
│                                                                 │
│  ABSTRACT CLASS DESIGN:                                         │
│  ──────────────────────                                         │
│  ✓ Virtual destructor                                          │
│  ✓ Protected constructor (not public)                          │
│  ✓ At least one pure virtual function                          │
│  ✓ Clear separation: pure virtual vs implemented               │
│  ✓ Protected data, not public                                  │
│  ✓ Use non-virtual interface (NVI) pattern when appropriate    │
│                                                                 │
│  GENERAL RULES:                                                 │
│  ──────────────                                                 │
│  ✓ Prefer interface for capabilities (can-do)                  │
│  ✓ Prefer abstract class for hierarchies (is-a)                │
│  ✓ Prefer interface when multiple inheritance needed           │
│  ✓ Use virtual inheritance for diamond problems                │
│  ✓ Document which functions must be overridden                 │
│  ✓ Use override keyword in derived classes                     │
│  ✓ Consider final for classes not meant to be derived          │
│                                                                 │
│  AVOID:                                                         │
│  ──────                                                         │
│  ✗ Public data members in abstract classes                     │
│  ✗ Missing virtual destructor                                  │
│  ✗ Too many pure virtual functions (split interface)           │
│  ✗ Abstract class with no pure virtual functions               │
│  ✗ Deep inheritance hierarchies                                │
│  ✗ Mixing unrelated interfaces                                 │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**Decision Flowchart**
``` 
┌─────────────────────────────────────────────────────────────────┐
│              INTERFACE vs ABSTRACT CLASS DECISION               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│                    Need shared implementation?                  │
│                             │                                   │
│                    ┌────────┴────────┐                          │
│                   YES               NO                          │
│                    │                 │                          │
│                    ▼                 ▼                          │
│             Need shared          Need multiple                  │
│             state/data?          inheritance?                   │
│                 │                    │                          │
│           ┌─────┴─────┐        ┌─────┴─────┐                    │
│          YES         NO       YES         NO                    │
│           │           │        │           │                    │
│           ▼           ▼        ▼           ▼                    │
│     ┌──────────┐  ┌──────────┐  │      Consider                │
│     │ ABSTRACT │  │ ABSTRACT │  │      either                  │
│     │  CLASS   │  │  CLASS   │  │                              │
│     │ (with    │  │(no data) │  │                              │
│     │  data)   │  └──────────┘  │                              │
│     └──────────┘                ▼                              │
│                           ┌──────────┐                          │
│                           │INTERFACE │                          │
│                           └──────────┘                          │
│                                                                 │
│  SUMMARY:                                                       │
│  • Interface: Contract only, no implementation, safe MI         │
│  • Abstract Class: Contract + partial impl + state              │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘

```
**Quick Reference Card**
``` 
┌─────────────────────────────────────────────────────────────────┐
│            ABSTRACT CLASSES & INTERFACES SUMMARY                │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  PURE VIRTUAL FUNCTION:                                         │
│  ───────────────────────                                        │
│  virtual void func() = 0;  // Must be overridden                │
│                                                                 │
│  INTERFACE PATTERN:                                             │
│  ──────────────────                                             │
│  class IInterface {                                             │
│  public:                                                        │
│      virtual ~IInterface() = default;                           │
│      virtual void method1() = 0;                                │
│      virtual void method2() = 0;                                │
│  };                                                             │
│                                                                 │
│  ABSTRACT CLASS PATTERN:                                        │
│  ───────────────────────                                        │
│  class AbstractBase {                                           │
│  protected:                                                     │
│      SomeType data;                                             │
│      AbstractBase(args) : data(args) {}                         │
│  public:                                                        │
│      virtual ~AbstractBase() = default;                         │
│      virtual void mustOverride() = 0;                           │
│      virtual void canOverride() { /* default impl */ }          │
│      void sharedBehavior() { /* common code */ }                │
│  };                                                             │
│                                                                 │
│  KEY DIFFERENCES:                                               │
│  ────────────────                                               │
│  Interface:                                                     │
│    • All pure virtual                                           │
│    • No data/state                                              │
│    • "Can do" relationship                                      │
│    • Safe for multiple inheritance                              │
│                                                                 │
│  Abstract Class:                                                │
│    • Some pure virtual                                          │
│    • Can have data/state                                        │
│    • "Is a" relationship                                        │
│    • Diamond problem possible                                   │
│                                                                 │
│  REMEMBER:                                                      │
│  ─────────                                                      │
│  • Cannot instantiate abstract class                            │
│  • Must implement ALL pure virtuals to be concrete              │
│  • Virtual destructor is essential                              │
│  • Use override keyword                                         │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```












