## Value Categories in C++
A comprehensive guide covering lvalues, rvalues, and their references.

### Table of Contents
* Introduction to Value Categories
* Lvalues
* Rvalues
* Extended Value Categories (C++11)
* Lvalue References
* Rvalue References
* Reference Collapsing
* std::move and std::forward
* Practical Applications
* Best Practices

### 1. Introduction to Value Categories
**What Are Value Categories?**
Every expression in C++ has two independent properties:

* **Type** - What kind of data it represents (int, string, etc.)
* **Value Category** - How the expression can be used

``` cpp
┌─────────────────────────────────────────────────────────────────┐
│                    VALUE CATEGORIES                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  VALUE CATEGORY determines:                                     │
│  ──────────────────────────                                     │
│  • Can it appear on LEFT side of assignment?                    │
│  • Can we take its ADDRESS?                                     │
│  • Does it have IDENTITY (name/location)?                       │
│  • Can it be MOVED from?                                        │
│                                                                 │
│  HISTORICAL VIEW (Pre-C++11):                                   │
│  ────────────────────────────                                   │
│                                                                 │
│                    expression                                   │
│                        │                                        │
│              ┌─────────┴─────────┐                              │
│              │                   │                              │
│           lvalue              rvalue                            │
│         (left value)        (right value)                       │
│         (locator)           (read only)                         │
│                                                                 │
│  MODERN VIEW (C++11 and later):                                 │
│  ──────────────────────────────                                 │
│                                                                 │
│                    expression                                   │
│                        │                                        │
│              ┌─────────┴─────────┐                              │
│              │                   │                              │
│           glvalue             rvalue                            │
│              │                   │                              │
│        ┌─────┴─────┐       ┌─────┴─────┐                        │
│        │           │       │           │                        │
│     lvalue      xvalue  xvalue     prvalue                      │
│                    └───┬───┘                                    │
│                        │                                        │
│                     (shared)                                    │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**Quick Classification**
``` cpp
#include <iostream>
#include <string>
using namespace std;

int getValue() { return 42; }
int& getRef(int& x) { return x; }
int&& getRvalueRef() { static int x = 10; return std::move(x); }

int main() {
    int x = 10;
    int y = 20;
    int* ptr = &x;
    
    // ═══════════════════════════════════════════════════════════
    // LVALUES - Have identity, can take address
    // ═══════════════════════════════════════════════════════════
    
    x;              // lvalue: named variable
    y;              // lvalue: named variable
    *ptr;           // lvalue: dereferenced pointer
    ptr[0];         // lvalue: array subscript
    getRef(x);      // lvalue: function returning lvalue reference
    ++x;            // lvalue: pre-increment returns reference
    "hello";        // lvalue: string literal (special case!)
    
    // ═══════════════════════════════════════════════════════════
    // RVALUES - Temporary, cannot take address (usually)
    // ═══════════════════════════════════════════════════════════
    
    42;             // rvalue (prvalue): integer literal
    3.14;           // rvalue (prvalue): floating literal
    x + y;          // rvalue (prvalue): arithmetic expression
    getValue();     // rvalue (prvalue): function returning by value
    x++;            // rvalue (prvalue): post-increment returns copy
    int(x);         // rvalue (prvalue): explicit cast
    string("hi");   // rvalue (prvalue): temporary object
    std::move(x);   // rvalue (xvalue): moved-from expression
    getRvalueRef(); // rvalue (xvalue): function returning rvalue ref
    
    return 0;
}
```

### 2. Lvalues
**What is an Lvalue?**
An lvalue (locator value) is an expression that:

Has a persistent identity (occupies memory location)
Can have its address taken with &
Can appear on the left side of assignment (if modifiable)
Persists beyond the expression

``` 
┌─────────────────────────────────────────────────────────────────┐
│                      LVALUE PROPERTIES                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ✓ Has identity (name or memory location)                       │
│  ✓ Can take address with & operator                             │
│  ✓ Persists beyond single expression                            │
│  ✓ Can be on left side of = (if not const)                      │
│  ✓ Can bind to lvalue reference (T&)                            │
│  ✓ Can bind to const lvalue reference (const T&)                │
│                                                                 │
│  MEMORY VISUALIZATION:                                          │
│  ─────────────────────                                          │
│                                                                 │
│      int x = 42;                                                │
│                                                                 │
│      ┌──────────────────────────────────┐                       │
│      │           MEMORY                 │                       │
│      ├──────────────────────────────────┤                       │
│      │ Address: 0x1000                  │                       │
│      │ Name: x                          │ ◄── LVALUE            │
│      │ Value: 42                        │     Has identity      │
│      │ Lifetime: until scope ends       │     Has address       │
│      └──────────────────────────────────┘     Persists          │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**Lvalue Examples**
``` cpp
#include <iostream>
#include <string>
using namespace std;

int globalVar = 100;

int& getGlobalRef() {
    return globalVar;
}

class MyClass {
public:
    int member;
    static int staticMember;
    
    int& getMember() { return member; }
};

int MyClass::staticMember = 50;

int main() {
    // ═══════════════════════════════════════════════════════════
    // NAMED VARIABLES - Always lvalues
    // ═══════════════════════════════════════════════════════════
    
    int x = 10;                      // x is lvalue
    const int y = 20;                // y is lvalue (but not modifiable)
    int& ref = x;                    // ref is lvalue
    int* ptr = &x;                   // ptr is lvalue
    int arr[5] = {1,2,3,4,5};        // arr is lvalue
    
    cout << "Address of x: " << &x << endl;         // ✓ OK
    cout << "Address of y: " << &y << endl;         // ✓ OK
    cout << "Address of ref: " << &ref << endl;     // ✓ OK
    cout << "Address of ptr: " << &ptr << endl;     // ✓ OK
    
    // ═══════════════════════════════════════════════════════════
    // DEREFERENCED POINTERS - Lvalues
    // ═══════════════════════════════════════════════════════════
    
    *ptr = 100;                      // *ptr is lvalue
    cout << "Address of *ptr: " << &(*ptr) << endl; // ✓ OK
    
    // ═══════════════════════════════════════════════════════════
    // ARRAY SUBSCRIPTS - Lvalues
    // ═══════════════════════════════════════════════════════════
    
    arr[0] = 10;                     // arr[0] is lvalue
    ptr[0] = 20;                     // ptr[0] is lvalue
    cout << "Address of arr[0]: " << &arr[0] << endl; // ✓ OK
    
    // ═══════════════════════════════════════════════════════════
    // FUNCTION RETURNING LVALUE REFERENCE - Lvalue
    // ═══════════════════════════════════════════════════════════
    
    getGlobalRef() = 200;            // getGlobalRef() is lvalue
    cout << "globalVar: " << globalVar << endl;      // 200
    cout << "Address: " << &getGlobalRef() << endl;  // ✓ OK
    
    // ═══════════════════════════════════════════════════════════
    // PRE-INCREMENT/DECREMENT - Lvalues
    // ═══════════════════════════════════════════════════════════
    
    ++x;                             // ++x is lvalue (returns reference)
    --x;                             // --x is lvalue
    ++(++x);                         // Can chain - both are lvalues
    cout << "Address of ++x: " << &(++x) << endl;    // ✓ OK
    
    // ═══════════════════════════════════════════════════════════
    // CLASS MEMBERS - Lvalues
    // ═══════════════════════════════════════════════════════════
    
    MyClass obj;
    obj.member = 10;                 // obj.member is lvalue
    MyClass::staticMember = 60;      // staticMember is lvalue
    obj.getMember() = 30;            // getMember() returns lvalue
    
    // ═══════════════════════════════════════════════════════════
    // STRING LITERALS - Lvalues (special case!)
    // ═══════════════════════════════════════════════════════════
    
    // String literals are lvalues (arrays of const char)
    const char* str = "hello";
    cout << "Address of literal: " << (void*)"hello" << endl; // ✓ OK
    
    // ═══════════════════════════════════════════════════════════
    // COMMA OPERATOR - Result is lvalue if right operand is
    // ═══════════════════════════════════════════════════════════
    
    (x, y);                          // Result is lvalue (y)
    
    return 0;
}
```

**Modifiable vs Non-Modifiable Lvalues**
``` cpp
#include <iostream>
using namespace std;

int main() {
    // ═══════════════════════════════════════════════════════════
    // MODIFIABLE LVALUES - Can appear on left of assignment
    // ═══════════════════════════════════════════════════════════
    
    int x = 10;
    x = 20;              // ✓ OK: x is modifiable lvalue
    
    int arr[5];
    arr[0] = 1;          // ✓ OK: arr[0] is modifiable lvalue
    
    int* ptr = &x;
    *ptr = 30;           // ✓ OK: *ptr is modifiable lvalue
    
    // ═══════════════════════════════════════════════════════════
    // NON-MODIFIABLE LVALUES - Cannot appear on left of assignment
    // ═══════════════════════════════════════════════════════════
    
    const int y = 10;
    // y = 20;           // ✗ ERROR: y is const (non-modifiable lvalue)
    
    const int& ref = x;
    // ref = 30;         // ✗ ERROR: ref is const reference
    
    const int arr2[5] = {1,2,3,4,5};
    // arr2[0] = 10;     // ✗ ERROR: arr2 elements are const
    
    // String literals are const
    // "hello"[0] = 'H'; // ✗ ERROR: string literal is const
    
    // ═══════════════════════════════════════════════════════════
    // KEY POINT: Being an lvalue ≠ Being modifiable
    // ═══════════════════════════════════════════════════════════
    
    // Both are lvalues:
    cout << "Address of x: " << &x << endl;    // Modifiable lvalue
    cout << "Address of y: " << &y << endl;    // Non-modifiable lvalue
    
    return 0;
}
```

### 3. Rvalues
**What is an Rvalue?**
An rvalue is an expression that:
- Is temporary (exists only in expression)
- Does not have a persistent identity
- Cannot have its address taken (usually)
- Can only appear on the right side of the assignment

```
┌─────────────────────────────────────────────────────────────────┐
│                      RVALUE PROPERTIES                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ✓ Temporary value                                              │
│  ✓ No persistent identity (usually no name)                     │
│  ✗ Cannot take address with & (usually)                         │
│  ✗ Cannot appear on left side of =                              │
│  ✓ Can bind to rvalue reference (T&&)                           │
│  ✓ Can bind to const lvalue reference (const T&)                │
│  ✓ CAN BE MOVED FROM (key for move semantics!)                  │
│                                                                 │
│  MEMORY VISUALIZATION:                                          │
│  ─────────────────────                                          │
│                                                                 │
│      x + y    (where x=10, y=20)                                │
│                                                                 │
│      ┌──────────────────────────────────┐                       │
│      │      TEMPORARY REGISTER/STACK    │                       │
│      ├──────────────────────────────────┤                       │
│      │ Value: 30                        │ ◄── RVALUE            │
│      │ Lifetime: this expression only   │     No identity       │
│      │ Address: ??? (not accessible)    │     Temporary         │
│      └──────────────────────────────────┘     Can move from     │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**Rvalue Examples**
``` cpp
#include <iostream>
#include <string>
#include <vector>
using namespace std;

int getValue() { return 42; }
string getString() { return "hello"; }
vector<int> getVector() { return {1, 2, 3}; }

int main() {
    int x = 10;
    int y = 20;
    
    // ═══════════════════════════════════════════════════════════
    // LITERALS (except string literals) - Rvalues
    // ═══════════════════════════════════════════════════════════
    
    42;                      // rvalue: integer literal
    3.14;                    // rvalue: floating literal
    'a';                     // rvalue: character literal
    true;                    // rvalue: boolean literal
    nullptr;                 // rvalue: null pointer literal
    
    // &42;                  // ✗ ERROR: cannot take address of rvalue
    // 42 = x;               // ✗ ERROR: cannot assign to rvalue
    
    // ═══════════════════════════════════════════════════════════
    // ARITHMETIC/LOGICAL EXPRESSIONS - Rvalues
    // ═══════════════════════════════════════════════════════════
    
    x + y;                   // rvalue: result of addition
    x - y;                   // rvalue: result of subtraction
    x * y;                   // rvalue: result of multiplication
    x / y;                   // rvalue: result of division
    x % y;                   // rvalue: result of modulo
    x & y;                   // rvalue: result of bitwise AND
    x | y;                   // rvalue: result of bitwise OR
    x < y;                   // rvalue: result of comparison
    x && y;                  // rvalue: result of logical AND
    !x;                      // rvalue: result of logical NOT
    -x;                      // rvalue: result of unary minus
    +x;                      // rvalue: result of unary plus
    
    // &(x + y);             // ✗ ERROR: cannot take address
    // (x + y) = 30;         // ✗ ERROR: cannot assign to rvalue
    
    // ═══════════════════════════════════════════════════════════
    // FUNCTION CALLS RETURNING BY VALUE - Rvalues
    // ═══════════════════════════════════════════════════════════
    
    getValue();              // rvalue: function returning int
    getString();             // rvalue: function returning string
    getVector();             // rvalue: function returning vector
    
    // &getValue();          // ✗ ERROR: cannot take address
    // getValue() = 10;      // ✗ ERROR: cannot assign
    
    // ═══════════════════════════════════════════════════════════
    // POST-INCREMENT/DECREMENT - Rvalues
    // ═══════════════════════════════════════════════════════════
    
    x++;                     // rvalue: returns COPY of old value
    y--;                     // rvalue: returns COPY of old value
    
    // &(x++);               // ✗ ERROR: cannot take address
    // (x++) = 10;           // ✗ ERROR: cannot assign
    
    // Compare with pre-increment (lvalue):
    // &(++x);               // ✓ OK: ++x is lvalue
    
    // ═══════════════════════════════════════════════════════════
    // TEMPORARY OBJECTS - Rvalues
    // ═══════════════════════════════════════════════════════════
    
    int(42);                 // rvalue: temporary int
    string("hello");         // rvalue: temporary string
    vector<int>{1,2,3};      // rvalue: temporary vector
    MyClass();               // rvalue: temporary object (if MyClass exists)
    
    // ═══════════════════════════════════════════════════════════
    // CASTS TO NON-REFERENCE TYPES - Rvalues
    // ═══════════════════════════════════════════════════════════
    
    static_cast<int>(3.14);  // rvalue
    (int)3.14;               // rvalue: C-style cast
    int(3.14);               // rvalue: functional cast
    
    // ═══════════════════════════════════════════════════════════
    // LAMBDA EXPRESSIONS - Rvalues
    // ═══════════════════════════════════════════════════════════
    
    []{ return 42; };        // rvalue: lambda is temporary
    [](int a){ return a*2; };// rvalue
    
    // ═══════════════════════════════════════════════════════════
    // this POINTER - Rvalue
    // ═══════════════════════════════════════════════════════════
    
    // Inside a member function:
    // this;                 // rvalue (but *this is lvalue!)
    
    // ═══════════════════════════════════════════════════════════
    // ENUMERATOR - Rvalue
    // ═══════════════════════════════════════════════════════════
    
    enum Color { Red, Green, Blue };
    Red;                     // rvalue
    
    return 0;
}
```

**Why Rvalues Matter**
``` CPP
#include <iostream>
#include <string>
#include <utility>
using namespace std;

class HeavyObject {
    int* data;
    size_t size;

public:
    HeavyObject(size_t s) : size(s), data(new int[s]) {
        cout << "Constructor: allocated " << size << " ints" << endl;
    }

    // Copy constructor (expensive)
    HeavyObject(const HeavyObject& other) : size(other.size), data(new int[other.size]) {
        for (size_t i = 0; i < size; i++) {
            data[i] = other.data[i];
        }
        cout << "Copy Constructor: copied " << size << " ints (EXPENSIVE)" << endl;
    }

    // Move constructor (cheap)
    HeavyObject(HeavyObject&& other) noexcept : size(other.size), data(other.data) {
        other.data = nullptr;
        other.size = 0;
        cout << "Move Constructor: stolen pointer (CHEAP)" << endl;
    }

    ~HeavyObject() {
        delete[] data;
    }
};

HeavyObject createObject() {
    return HeavyObject(1000000);  // Returns rvalue
}

int main() {
    cout << "=== Copying from lvalue ===" << endl;
    HeavyObject obj1(1000000);
    HeavyObject obj2 = obj1;      // obj1 is LVALUE → Copy constructor
    
    cout << "\n=== Moving from rvalue ===" << endl;
    HeavyObject obj3 = createObject();  // createObject() returns RVALUE → Move
    
    cout << "\n=== Forcing move with std::move ===" << endl;
    HeavyObject obj4 = std::move(obj1); // std::move makes it RVALUE → Move
    
    return 0;
}
```

**Output:**

```text

=== Copying from lvalue ===
Constructor: allocated 1000000 ints
Copy Constructor: copied 1000000 ints (EXPENSIVE)

=== Moving from rvalue ===
Constructor: allocated 1000000 ints
Move Constructor: stolen pointer (CHEAP)

=== Forcing move with std::move ===
Move Constructor: stolen pointer (CHEAP)

```

### 4. Extended Value Categories (C++11)
**The Complete Picture**
``` 
┌─────────────────────────────────────────────────────────────────┐
│              C++11 EXTENDED VALUE CATEGORIES                    │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│                       expression                                │
│                           │                                     │
│              ┌────────────┴────────────┐                        │
│              │                         │                        │
│           glvalue                   rvalue                      │
│     (generalized lvalue)     (can be moved from)                │
│              │                         │                        │
│        ┌─────┴─────┐             ┌─────┴─────┐                  │
│        │           │             │           │                  │
│     lvalue      xvalue        xvalue      prvalue               │
│                    │             │                              │
│                    └──────┬──────┘                              │
│                           │                                     │
│                    xvalue is BOTH                               │
│                   glvalue AND rvalue                            │
│                                                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  PROPERTIES:                                                    │
│  ───────────                                                    │
│                         │ Has Identity │ Can Move From │        │
│  ───────────────────────┼──────────────┼───────────────│        │
│  lvalue                 │     YES      │      NO       │        │
│  xvalue                 │     YES      │     YES       │        │
│  prvalue                │      NO      │     YES       │        │
│  ───────────────────────┼──────────────┼───────────────│        │
│  glvalue (l + x)        │     YES      │    maybe      │        │
│  rvalue  (x + pr)       │    maybe     │     YES       │        │
│                                                                 │
│  SIMPLE RULE:                                                   │
│  • glvalue = has identity                                       │
│  • rvalue = can be moved from                                   │
│  • xvalue = both (eXpiring value)                               │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**Detailed Breakdown**
``` CPP
#include <iostream>
#include <string>
#include <utility>
using namespace std;

string createString() { return "hello"; }
string& getStringRef(string& s) { return s; }
string&& getStringRvalueRef(string& s) { return std::move(s); }

int main() {
    string s = "world";
    
    // ═══════════════════════════════════════════════════════════
    // LVALUE: Has identity, cannot be moved from implicitly
    // ═══════════════════════════════════════════════════════════
    
    s;                       // lvalue: named variable
    getStringRef(s);         // lvalue: function returning lvalue ref
    
    // Properties:
    // - Has identity: YES (has name 's')
    // - Can move from: NO (unless explicitly with std::move)
    // - Can take address: YES
    
    // ═══════════════════════════════════════════════════════════
    // PRVALUE (Pure Rvalue): No identity, can be moved from
    // ═══════════════════════════════════════════════════════════
    
    42;                      // prvalue: literal
    s + "!";                 // prvalue: temporary from concatenation
    createString();          // prvalue: function returning by value
    string("temp");          // prvalue: temporary object
    
    // Properties:
    // - Has identity: NO (no name, no address)
    // - Can move from: YES
    // - Can take address: NO
    
    // ═══════════════════════════════════════════════════════════
    // XVALUE (eXpiring Value): Has identity AND can be moved from
    // ═══════════════════════════════════════════════════════════
    
    std::move(s);            // xvalue: result of std::move
    getStringRvalueRef(s);   // xvalue: function returning rvalue ref
    static_cast<string&&>(s);// xvalue: cast to rvalue reference
    
    // Properties:
    // - Has identity: YES (refers to existing object)
    // - Can move from: YES (that's the point!)
    // - Can take address: technically yes (of the referred object)
    
    // ═══════════════════════════════════════════════════════════
    // GLVALUE (Generalized Lvalue): lvalue OR xvalue
    // ═══════════════════════════════════════════════════════════
    
    // glvalue = anything with identity
    s;                       // glvalue (lvalue)
    std::move(s);            // glvalue (xvalue)
    
    // ═══════════════════════════════════════════════════════════
    // RVALUE: prvalue OR xvalue
    // ═══════════════════════════════════════════════════════════
    
    // rvalue = anything that can be moved from
    42;                      // rvalue (prvalue)
    std::move(s);            // rvalue (xvalue)
    
    return 0;
}
```
**Visual: Value Category Examples**

``` 
═══════════════════════════════════════════════════════════════════
                    VALUE CATEGORY EXAMPLES
═══════════════════════════════════════════════════════════════════

    EXPRESSION                      CATEGORY    IDENTITY  MOVEABLE
    ──────────                      ────────    ────────  ────────
    
    int x = 10;
    x                               lvalue       YES       NO*
    
    x + 1                           prvalue      NO        YES
    
    std::move(x)                    xvalue       YES       YES
    
    42                              prvalue      NO        YES
    
    "hello"                         lvalue       YES       NO
    
    int& r = x;
    r                               lvalue       YES       NO*
    
    int&& rr = 42;
    rr                              lvalue!      YES       NO*
    (The NAME rr is an lvalue, even though it's an rvalue reference)
    
    std::move(rr)                   xvalue       YES       YES
    
    
    * Can be moved with explicit std::move()

═══════════════════════════════════════════════════════════════════

    FUNCTION RETURN TYPES:
    ──────────────────────
    
    int getValue();                 → prvalue
    int& getRef();                  → lvalue
    int&& getRvalueRef();           → xvalue
    const int& getConstRef();       → lvalue

═══════════════════════════════════════════════════════════════════
```
**Value Category Test**
``` CPP
#include <iostream>
#include <type_traits>
using namespace std;

// Helper to determine value category
template<typename T>
struct value_category {
    static constexpr const char* value = "prvalue";
};

template<typename T>
struct value_category<T&> {
    static constexpr const char* value = "lvalue";
};

template<typename T>
struct value_category<T&&> {
    static constexpr const char* value = "xvalue";
};

// Macro to test and print value category
#define VALUE_CATEGORY(expr) \
    value_category<decltype((expr))>::value

int getInt() { return 42; }
int& getIntRef() { static int x = 10; return x; }
int&& getIntRvalueRef() { static int x = 20; return std::move(x); }

int main() {
    int x = 10;
    int& ref = x;
    int&& rref = 42;
    
    cout << "Value Categories:" << endl;
    cout << "─────────────────" << endl;
    
    cout << "x:                " << VALUE_CATEGORY(x) << endl;
    cout << "42:               " << VALUE_CATEGORY(42) << endl;
    cout << "x + 1:            " << VALUE_CATEGORY(x + 1) << endl;
    cout << "std::move(x):     " << VALUE_CATEGORY(std::move(x)) << endl;
    cout << "ref:              " << VALUE_CATEGORY(ref) << endl;
    cout << "rref:             " << VALUE_CATEGORY(rref) << endl;
    cout << "std::move(rref):  " << VALUE_CATEGORY(std::move(rref)) << endl;
    cout << "getInt():         " << VALUE_CATEGORY(getInt()) << endl;
    cout << "getIntRef():      " << VALUE_CATEGORY(getIntRef()) << endl;
    cout << "getIntRvalueRef():" << VALUE_CATEGORY(getIntRvalueRef()) << endl;
    cout << "++x:              " << VALUE_CATEGORY(++x) << endl;
    cout << "x++:              " << VALUE_CATEGORY(x++) << endl;
    
    return 0;
}
```

**Output:**

```text

Value Categories:
─────────────────
x:                lvalue
42:               prvalue
x + 1:            prvalue
std::move(x):     xvalue
ref:              lvalue
rref:             lvalue
std::move(rref):  xvalue
getInt():         prvalue
getIntRef():      lvalue
getIntRvalueRef():xvalue
++x:              lvalue
x++:              prvalue
```

### 5. Lvalue References
**What is an Lvalue Reference?**
An lvalue reference (T&) is an alias for an existing object. It must be initialized and cannot be reseated.

``` 
┌─────────────────────────────────────────────────────────────────┐
│                    LVALUE REFERENCE                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  SYNTAX: T& ref = lvalue;                                       │
│                                                                 │
│  BINDING RULES:                                                 │
│  ──────────────                                                 │
│  T&        → binds to: modifiable lvalue of type T              │
│  const T&  → binds to: any lvalue or rvalue of type T           │
│                                                                 │
│  PROPERTIES:                                                    │
│  ───────────                                                    │
│  • Must be initialized at declaration                           │
│  • Cannot be null (unlike pointers)                             │
│  • Cannot be reseated (always refers to same object)            │
│  • Reference is the object (not a separate entity)              │
│                                                                 │
│  MEMORY MODEL:                                                  │
│  ─────────────                                                  │
│                                                                 │
│      int x = 42;                                                │
│      int& ref = x;                                              │
│                                                                 │
│      ┌─────────────────────────────────────┐                    │
│      │            MEMORY                   │                    │
│      ├─────────────────────────────────────┤                    │
│      │ Address: 0x1000                     │                    │
│      │ Names: x, ref (SAME location)       │                    │
│      │ Value: 42                           │                    │
│      └─────────────────────────────────────┘                    │
│                                                                 │
│      ref IS x, just another name for the same memory            │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```
**Lvalue Reference Examples**

``` CPP
#include <iostream>
#include <string>
using namespace std;

void modifyByRef(int& x) {
    x *= 2;
}

void printByConstRef(const string& s) {
    cout << s << endl;
}

int main() {
    // ═══════════════════════════════════════════════════════════
    // BASIC LVALUE REFERENCE
    // ═══════════════════════════════════════════════════════════
    
    int x = 10;
    int& ref = x;           // ref is alias for x
    
    cout << "x = " << x << ", ref = " << ref << endl;
    
    ref = 20;               // Modifies x through ref
    cout << "After ref = 20: x = " << x << endl;
    
    x = 30;                 // Modifies x directly
    cout << "After x = 30: ref = " << ref << endl;
    
    cout << "Address of x:   " << &x << endl;
    cout << "Address of ref: " << &ref << endl;  // Same address!
    
    // ═══════════════════════════════════════════════════════════
    // LVALUE REFERENCE BINDING RULES
    // ═══════════════════════════════════════════════════════════
    
    int a = 10;
    
    // T& binds to modifiable lvalue
    int& ref1 = a;          // ✓ OK: a is modifiable lvalue
    
    // int& ref2 = 42;      // ✗ ERROR: 42 is rvalue
    // int& ref3 = a + 1;   // ✗ ERROR: a + 1 is rvalue
    
    // const T& binds to anything!
    const int& cref1 = a;       // ✓ OK: lvalue
    const int& cref2 = 42;      // ✓ OK: rvalue (lifetime extended!)
    const int& cref3 = a + 1;   // ✓ OK: rvalue (lifetime extended!)
    
    cout << "\ncref2 = " << cref2 << endl;  // 42
    cout << "cref3 = " << cref3 << endl;    // 11
    
    // ═══════════════════════════════════════════════════════════
    // REFERENCES IN FUNCTION PARAMETERS
    // ═══════════════════════════════════════════════════════════
    
    int value = 5;
    cout << "\nBefore modifyByRef: " << value << endl;
    modifyByRef(value);
    cout << "After modifyByRef: " << value << endl;
    
    // modifyByRef(10);     // ✗ ERROR: cannot bind non-const ref to rvalue
    
    printByConstRef("Hello");   // ✓ OK: const ref can bind to rvalue
    printByConstRef(string("World")); // ✓ OK
    
    // ═══════════════════════════════════════════════════════════
    // REFERENCES CANNOT BE RESEATED
    // ═══════════════════════════════════════════════════════════
    
    int y = 100;
    int& refX = x;
    
    refX = y;               // This COPIES y's value to x!
                            // refX still refers to x, not y
    
    cout << "\nAfter refX = y:" << endl;
    cout << "x = " << x << ", y = " << y << ", refX = " << refX << endl;
    cout << "&x = " << &x << ", &refX = " << &refX << endl;  // Still same!
    
    // ═══════════════════════════════════════════════════════════
    // REFERENCE TO REFERENCE (not possible directly)
    // ═══════════════════════════════════════════════════════════
    
    int& ref2 = ref1;       // ref2 refers to 'a', not to ref1
                            // There's no "reference to reference"
    
    return 0;
}
```

**const Lvalue Reference - Special Case**

``` CPP
#include <iostream>
using namespace std;

class Heavy {
public:
    Heavy() { cout << "Heavy constructed" << endl; }
    ~Heavy() { cout << "Heavy destroyed" << endl; }
    Heavy(const Heavy&) { cout << "Heavy copied" << endl; }
};

Heavy createHeavy() {
    return Heavy();
}

int main() {
    cout << "=== Const reference extends lifetime ===" << endl;
    
    {
        // const reference can bind to rvalue and EXTENDS its lifetime!
        const Heavy& ref = createHeavy();
        cout << "Using ref..." << endl;
        // Heavy object lives until ref goes out of scope
    }
    cout << "After block" << endl;
    
    cout << "\n=== Without const reference ===" << endl;
    
    {
        // Heavy& ref = createHeavy();  // ERROR: can't bind to rvalue
        
        Heavy obj = createHeavy();  // Creates and possibly copies
        cout << "Using obj..." << endl;
    }
    cout << "After block" << endl;
    
    return 0;
}
```

**Output:**

```text

=== Const reference extends lifetime ===
Heavy constructed
Using ref...
Heavy destroyed
After block

=== Without const reference ===
Heavy constructed
Using obj...
Heavy destroyed
After block
```
### 6. Rvalue References
**What is an Rvalue Reference?**
An rvalue reference (T&&) is a reference that binds to rvalues. It enables move semantics and perfect forwarding.
