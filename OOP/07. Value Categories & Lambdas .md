## Value Categories in C++
A comprehensive guide covering lvalues, rvalues, and their references.

### Table of Contents
* Introduction to Value Categories
* Lvalues
* Rvalues
* Extended Value Categories (C++11)
* Lvalue References
* Rvalue References
* Reference Collapsing
* std::move and std::forward
* Practical Applications
* Best Practices

### 1. Introduction to Value Categories
**What Are Value Categories?**
Every expression in C++ has two independent properties:

* **Type** - What kind of data it represents (int, string, etc.)
* **Value Category** - How the expression can be used

``` cpp
┌─────────────────────────────────────────────────────────────────┐
│                    VALUE CATEGORIES                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  VALUE CATEGORY determines:                                     │
│  ──────────────────────────                                     │
│  • Can it appear on LEFT side of assignment?                    │
│  • Can we take its ADDRESS?                                     │
│  • Does it have IDENTITY (name/location)?                       │
│  • Can it be MOVED from?                                        │
│                                                                 │
│  HISTORICAL VIEW (Pre-C++11):                                   │
│  ────────────────────────────                                   │
│                                                                 │
│                    expression                                   │
│                        │                                        │
│              ┌─────────┴─────────┐                              │
│              │                   │                              │
│           lvalue              rvalue                            │
│         (left value)        (right value)                       │
│         (locator)           (read only)                         │
│                                                                 │
│  MODERN VIEW (C++11 and later):                                 │
│  ──────────────────────────────                                 │
│                                                                 │
│                    expression                                   │
│                        │                                        │
│              ┌─────────┴─────────┐                              │
│              │                   │                              │
│           glvalue             rvalue                            │
│              │                   │                              │
│        ┌─────┴─────┐       ┌─────┴─────┐                        │
│        │           │       │           │                        │
│     lvalue      xvalue  xvalue     prvalue                      │
│                    └───┬───┘                                    │
│                        │                                        │
│                     (shared)                                    │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**Quick Classification**
``` cpp
#include <iostream>
#include <string>
using namespace std;

int getValue() { return 42; }
int& getRef(int& x) { return x; }
int&& getRvalueRef() { static int x = 10; return std::move(x); }

int main() {
    int x = 10;
    int y = 20;
    int* ptr = &x;
    
    // ═══════════════════════════════════════════════════════════
    // LVALUES - Have identity, can take address
    // ═══════════════════════════════════════════════════════════
    
    x;              // lvalue: named variable
    y;              // lvalue: named variable
    *ptr;           // lvalue: dereferenced pointer
    ptr[0];         // lvalue: array subscript
    getRef(x);      // lvalue: function returning lvalue reference
    ++x;            // lvalue: pre-increment returns reference
    "hello";        // lvalue: string literal (special case!)
    
    // ═══════════════════════════════════════════════════════════
    // RVALUES - Temporary, cannot take address (usually)
    // ═══════════════════════════════════════════════════════════
    
    42;             // rvalue (prvalue): integer literal
    3.14;           // rvalue (prvalue): floating literal
    x + y;          // rvalue (prvalue): arithmetic expression
    getValue();     // rvalue (prvalue): function returning by value
    x++;            // rvalue (prvalue): post-increment returns copy
    int(x);         // rvalue (prvalue): explicit cast
    string("hi");   // rvalue (prvalue): temporary object
    std::move(x);   // rvalue (xvalue): moved-from expression
    getRvalueRef(); // rvalue (xvalue): function returning rvalue ref
    
    return 0;
}
```

### 2. Lvalues
**What is an Lvalue?**
An lvalue (locator value) is an expression that:

Has a persistent identity (occupies memory location)
Can have its address taken with &
Can appear on the left side of assignment (if modifiable)
Persists beyond the expression

``` 
┌─────────────────────────────────────────────────────────────────┐
│                      LVALUE PROPERTIES                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ✓ Has identity (name or memory location)                       │
│  ✓ Can take address with & operator                             │
│  ✓ Persists beyond single expression                            │
│  ✓ Can be on left side of = (if not const)                      │
│  ✓ Can bind to lvalue reference (T&)                            │
│  ✓ Can bind to const lvalue reference (const T&)                │
│                                                                 │
│  MEMORY VISUALIZATION:                                          │
│  ─────────────────────                                          │
│                                                                 │
│      int x = 42;                                                │
│                                                                 │
│      ┌──────────────────────────────────┐                       │
│      │           MEMORY                 │                       │
│      ├──────────────────────────────────┤                       │
│      │ Address: 0x1000                  │                       │
│      │ Name: x                          │ ◄── LVALUE            │
│      │ Value: 42                        │     Has identity      │
│      │ Lifetime: until scope ends       │     Has address       │
│      └──────────────────────────────────┘     Persists          │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**Lvalue Examples**
``` cpp
#include <iostream>
#include <string>
using namespace std;

int globalVar = 100;

int& getGlobalRef() {
    return globalVar;
}

class MyClass {
public:
    int member;
    static int staticMember;
    
    int& getMember() { return member; }
};

int MyClass::staticMember = 50;

int main() {
    // ═══════════════════════════════════════════════════════════
    // NAMED VARIABLES - Always lvalues
    // ═══════════════════════════════════════════════════════════
    
    int x = 10;                      // x is lvalue
    const int y = 20;                // y is lvalue (but not modifiable)
    int& ref = x;                    // ref is lvalue
    int* ptr = &x;                   // ptr is lvalue
    int arr[5] = {1,2,3,4,5};        // arr is lvalue
    
    cout << "Address of x: " << &x << endl;         // ✓ OK
    cout << "Address of y: " << &y << endl;         // ✓ OK
    cout << "Address of ref: " << &ref << endl;     // ✓ OK
    cout << "Address of ptr: " << &ptr << endl;     // ✓ OK
    
    // ═══════════════════════════════════════════════════════════
    // DEREFERENCED POINTERS - Lvalues
    // ═══════════════════════════════════════════════════════════
    
    *ptr = 100;                      // *ptr is lvalue
    cout << "Address of *ptr: " << &(*ptr) << endl; // ✓ OK
    
    // ═══════════════════════════════════════════════════════════
    // ARRAY SUBSCRIPTS - Lvalues
    // ═══════════════════════════════════════════════════════════
    
    arr[0] = 10;                     // arr[0] is lvalue
    ptr[0] = 20;                     // ptr[0] is lvalue
    cout << "Address of arr[0]: " << &arr[0] << endl; // ✓ OK
    
    // ═══════════════════════════════════════════════════════════
    // FUNCTION RETURNING LVALUE REFERENCE - Lvalue
    // ═══════════════════════════════════════════════════════════
    
    getGlobalRef() = 200;            // getGlobalRef() is lvalue
    cout << "globalVar: " << globalVar << endl;      // 200
    cout << "Address: " << &getGlobalRef() << endl;  // ✓ OK
    
    // ═══════════════════════════════════════════════════════════
    // PRE-INCREMENT/DECREMENT - Lvalues
    // ═══════════════════════════════════════════════════════════
    
    ++x;                             // ++x is lvalue (returns reference)
    --x;                             // --x is lvalue
    ++(++x);                         // Can chain - both are lvalues
    cout << "Address of ++x: " << &(++x) << endl;    // ✓ OK
    
    // ═══════════════════════════════════════════════════════════
    // CLASS MEMBERS - Lvalues
    // ═══════════════════════════════════════════════════════════
    
    MyClass obj;
    obj.member = 10;                 // obj.member is lvalue
    MyClass::staticMember = 60;      // staticMember is lvalue
    obj.getMember() = 30;            // getMember() returns lvalue
    
    // ═══════════════════════════════════════════════════════════
    // STRING LITERALS - Lvalues (special case!)
    // ═══════════════════════════════════════════════════════════
    
    // String literals are lvalues (arrays of const char)
    const char* str = "hello";
    cout << "Address of literal: " << (void*)"hello" << endl; // ✓ OK
    
    // ═══════════════════════════════════════════════════════════
    // COMMA OPERATOR - Result is lvalue if right operand is
    // ═══════════════════════════════════════════════════════════
    
    (x, y);                          // Result is lvalue (y)
    
    return 0;
}
```

**Modifiable vs Non-Modifiable Lvalues**
``` cpp
#include <iostream>
using namespace std;

int main() {
    // ═══════════════════════════════════════════════════════════
    // MODIFIABLE LVALUES - Can appear on left of assignment
    // ═══════════════════════════════════════════════════════════
    
    int x = 10;
    x = 20;              // ✓ OK: x is modifiable lvalue
    
    int arr[5];
    arr[0] = 1;          // ✓ OK: arr[0] is modifiable lvalue
    
    int* ptr = &x;
    *ptr = 30;           // ✓ OK: *ptr is modifiable lvalue
    
    // ═══════════════════════════════════════════════════════════
    // NON-MODIFIABLE LVALUES - Cannot appear on left of assignment
    // ═══════════════════════════════════════════════════════════
    
    const int y = 10;
    // y = 20;           // ✗ ERROR: y is const (non-modifiable lvalue)
    
    const int& ref = x;
    // ref = 30;         // ✗ ERROR: ref is const reference
    
    const int arr2[5] = {1,2,3,4,5};
    // arr2[0] = 10;     // ✗ ERROR: arr2 elements are const
    
    // String literals are const
    // "hello"[0] = 'H'; // ✗ ERROR: string literal is const
    
    // ═══════════════════════════════════════════════════════════
    // KEY POINT: Being an lvalue ≠ Being modifiable
    // ═══════════════════════════════════════════════════════════
    
    // Both are lvalues:
    cout << "Address of x: " << &x << endl;    // Modifiable lvalue
    cout << "Address of y: " << &y << endl;    // Non-modifiable lvalue
    
    return 0;
}
```

### 3. Rvalues
**What is an Rvalue?**
An rvalue is an expression that:
- Is temporary (exists only in expression)
- Does not have a persistent identity
- Cannot have its address taken (usually)
- Can only appear on the right side of the assignment

```
┌─────────────────────────────────────────────────────────────────┐
│                      RVALUE PROPERTIES                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ✓ Temporary value                                              │
│  ✓ No persistent identity (usually no name)                     │
│  ✗ Cannot take address with & (usually)                         │
│  ✗ Cannot appear on left side of =                              │
│  ✓ Can bind to rvalue reference (T&&)                           │
│  ✓ Can bind to const lvalue reference (const T&)                │
│  ✓ CAN BE MOVED FROM (key for move semantics!)                  │
│                                                                 │
│  MEMORY VISUALIZATION:                                          │
│  ─────────────────────                                          │
│                                                                 │
│      x + y    (where x=10, y=20)                                │
│                                                                 │
│      ┌──────────────────────────────────┐                       │
│      │      TEMPORARY REGISTER/STACK    │                       │
│      ├──────────────────────────────────┤                       │
│      │ Value: 30                        │ ◄── RVALUE            │
│      │ Lifetime: this expression only   │     No identity       │
│      │ Address: ??? (not accessible)    │     Temporary         │
│      └──────────────────────────────────┘     Can move from     │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**Rvalue Examples**
``` cpp
#include <iostream>
#include <string>
#include <vector>
using namespace std;

int getValue() { return 42; }
string getString() { return "hello"; }
vector<int> getVector() { return {1, 2, 3}; }

int main() {
    int x = 10;
    int y = 20;
    
    // ═══════════════════════════════════════════════════════════
    // LITERALS (except string literals) - Rvalues
    // ═══════════════════════════════════════════════════════════
    
    42;                      // rvalue: integer literal
    3.14;                    // rvalue: floating literal
    'a';                     // rvalue: character literal
    true;                    // rvalue: boolean literal
    nullptr;                 // rvalue: null pointer literal
    
    // &42;                  // ✗ ERROR: cannot take address of rvalue
    // 42 = x;               // ✗ ERROR: cannot assign to rvalue
    
    // ═══════════════════════════════════════════════════════════
    // ARITHMETIC/LOGICAL EXPRESSIONS - Rvalues
    // ═══════════════════════════════════════════════════════════
    
    x + y;                   // rvalue: result of addition
    x - y;                   // rvalue: result of subtraction
    x * y;                   // rvalue: result of multiplication
    x / y;                   // rvalue: result of division
    x % y;                   // rvalue: result of modulo
    x & y;                   // rvalue: result of bitwise AND
    x | y;                   // rvalue: result of bitwise OR
    x < y;                   // rvalue: result of comparison
    x && y;                  // rvalue: result of logical AND
    !x;                      // rvalue: result of logical NOT
    -x;                      // rvalue: result of unary minus
    +x;                      // rvalue: result of unary plus
    
    // &(x + y);             // ✗ ERROR: cannot take address
    // (x + y) = 30;         // ✗ ERROR: cannot assign to rvalue
    
    // ═══════════════════════════════════════════════════════════
    // FUNCTION CALLS RETURNING BY VALUE - Rvalues
    // ═══════════════════════════════════════════════════════════
    
    getValue();              // rvalue: function returning int
    getString();             // rvalue: function returning string
    getVector();             // rvalue: function returning vector
    
    // &getValue();          // ✗ ERROR: cannot take address
    // getValue() = 10;      // ✗ ERROR: cannot assign
    
    // ═══════════════════════════════════════════════════════════
    // POST-INCREMENT/DECREMENT - Rvalues
    // ═══════════════════════════════════════════════════════════
    
    x++;                     // rvalue: returns COPY of old value
    y--;                     // rvalue: returns COPY of old value
    
    // &(x++);               // ✗ ERROR: cannot take address
    // (x++) = 10;           // ✗ ERROR: cannot assign
    
    // Compare with pre-increment (lvalue):
    // &(++x);               // ✓ OK: ++x is lvalue
    
    // ═══════════════════════════════════════════════════════════
    // TEMPORARY OBJECTS - Rvalues
    // ═══════════════════════════════════════════════════════════
    
    int(42);                 // rvalue: temporary int
    string("hello");         // rvalue: temporary string
    vector<int>{1,2,3};      // rvalue: temporary vector
    MyClass();               // rvalue: temporary object (if MyClass exists)
    
    // ═══════════════════════════════════════════════════════════
    // CASTS TO NON-REFERENCE TYPES - Rvalues
    // ═══════════════════════════════════════════════════════════
    
    static_cast<int>(3.14);  // rvalue
    (int)3.14;               // rvalue: C-style cast
    int(3.14);               // rvalue: functional cast
    
    // ═══════════════════════════════════════════════════════════
    // LAMBDA EXPRESSIONS - Rvalues
    // ═══════════════════════════════════════════════════════════
    
    []{ return 42; };        // rvalue: lambda is temporary
    [](int a){ return a*2; };// rvalue
    
    // ═══════════════════════════════════════════════════════════
    // this POINTER - Rvalue
    // ═══════════════════════════════════════════════════════════
    
    // Inside a member function:
    // this;                 // rvalue (but *this is lvalue!)
    
    // ═══════════════════════════════════════════════════════════
    // ENUMERATOR - Rvalue
    // ═══════════════════════════════════════════════════════════
    
    enum Color { Red, Green, Blue };
    Red;                     // rvalue
    
    return 0;
}
```

**Why Rvalues Matter**
``` CPP
#include <iostream>
#include <string>
#include <utility>
using namespace std;

class HeavyObject {
    int* data;
    size_t size;

public:
    HeavyObject(size_t s) : size(s), data(new int[s]) {
        cout << "Constructor: allocated " << size << " ints" << endl;
    }

    // Copy constructor (expensive)
    HeavyObject(const HeavyObject& other) : size(other.size), data(new int[other.size]) {
        for (size_t i = 0; i < size; i++) {
            data[i] = other.data[i];
        }
        cout << "Copy Constructor: copied " << size << " ints (EXPENSIVE)" << endl;
    }

    // Move constructor (cheap)
    HeavyObject(HeavyObject&& other) noexcept : size(other.size), data(other.data) {
        other.data = nullptr;
        other.size = 0;
        cout << "Move Constructor: stolen pointer (CHEAP)" << endl;
    }

    ~HeavyObject() {
        delete[] data;
    }
};

HeavyObject createObject() {
    return HeavyObject(1000000);  // Returns rvalue
}

int main() {
    cout << "=== Copying from lvalue ===" << endl;
    HeavyObject obj1(1000000);
    HeavyObject obj2 = obj1;      // obj1 is LVALUE → Copy constructor
    
    cout << "\n=== Moving from rvalue ===" << endl;
    HeavyObject obj3 = createObject();  // createObject() returns RVALUE → Move
    
    cout << "\n=== Forcing move with std::move ===" << endl;
    HeavyObject obj4 = std::move(obj1); // std::move makes it RVALUE → Move
    
    return 0;
}
```

**Output:**

```text

=== Copying from lvalue ===
Constructor: allocated 1000000 ints
Copy Constructor: copied 1000000 ints (EXPENSIVE)

=== Moving from rvalue ===
Constructor: allocated 1000000 ints
Move Constructor: stolen pointer (CHEAP)

=== Forcing move with std::move ===
Move Constructor: stolen pointer (CHEAP)

```

### 4. Extended Value Categories (C++11)
**The Complete Picture**
``` 
┌─────────────────────────────────────────────────────────────────┐
│              C++11 EXTENDED VALUE CATEGORIES                    │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│                       expression                                │
│                           │                                     │
│              ┌────────────┴────────────┐                        │
│              │                         │                        │
│           glvalue                   rvalue                      │
│     (generalized lvalue)     (can be moved from)                │
│              │                         │                        │
│        ┌─────┴─────┐             ┌─────┴─────┐                  │
│        │           │             │           │                  │
│     lvalue      xvalue        xvalue      prvalue               │
│                    │             │                              │
│                    └──────┬──────┘                              │
│                           │                                     │
│                    xvalue is BOTH                               │
│                   glvalue AND rvalue                            │
│                                                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  PROPERTIES:                                                    │
│  ───────────                                                    │
│                         │ Has Identity │ Can Move From │        │
│  ───────────────────────┼──────────────┼───────────────│        │
│  lvalue                 │     YES      │      NO       │        │
│  xvalue                 │     YES      │     YES       │        │
│  prvalue                │      NO      │     YES       │        │
│  ───────────────────────┼──────────────┼───────────────│        │
│  glvalue (l + x)        │     YES      │    maybe      │        │
│  rvalue  (x + pr)       │    maybe     │     YES       │        │
│                                                                 │
│  SIMPLE RULE:                                                   │
│  • glvalue = has identity                                       │
│  • rvalue = can be moved from                                   │
│  • xvalue = both (eXpiring value)                               │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**Detailed Breakdown**
``` CPP
#include <iostream>
#include <string>
#include <utility>
using namespace std;

string createString() { return "hello"; }
string& getStringRef(string& s) { return s; }
string&& getStringRvalueRef(string& s) { return std::move(s); }

int main() {
    string s = "world";
    
    // ═══════════════════════════════════════════════════════════
    // LVALUE: Has identity, cannot be moved from implicitly
    // ═══════════════════════════════════════════════════════════
    
    s;                       // lvalue: named variable
    getStringRef(s);         // lvalue: function returning lvalue ref
    
    // Properties:
    // - Has identity: YES (has name 's')
    // - Can move from: NO (unless explicitly with std::move)
    // - Can take address: YES
    
    // ═══════════════════════════════════════════════════════════
    // PRVALUE (Pure Rvalue): No identity, can be moved from
    // ═══════════════════════════════════════════════════════════
    
    42;                      // prvalue: literal
    s + "!";                 // prvalue: temporary from concatenation
    createString();          // prvalue: function returning by value
    string("temp");          // prvalue: temporary object
    
    // Properties:
    // - Has identity: NO (no name, no address)
    // - Can move from: YES
    // - Can take address: NO
    
    // ═══════════════════════════════════════════════════════════
    // XVALUE (eXpiring Value): Has identity AND can be moved from
    // ═══════════════════════════════════════════════════════════
    
    std::move(s);            // xvalue: result of std::move
    getStringRvalueRef(s);   // xvalue: function returning rvalue ref
    static_cast<string&&>(s);// xvalue: cast to rvalue reference
    
    // Properties:
    // - Has identity: YES (refers to existing object)
    // - Can move from: YES (that's the point!)
    // - Can take address: technically yes (of the referred object)
    
    // ═══════════════════════════════════════════════════════════
    // GLVALUE (Generalized Lvalue): lvalue OR xvalue
    // ═══════════════════════════════════════════════════════════
    
    // glvalue = anything with identity
    s;                       // glvalue (lvalue)
    std::move(s);            // glvalue (xvalue)
    
    // ═══════════════════════════════════════════════════════════
    // RVALUE: prvalue OR xvalue
    // ═══════════════════════════════════════════════════════════
    
    // rvalue = anything that can be moved from
    42;                      // rvalue (prvalue)
    std::move(s);            // rvalue (xvalue)
    
    return 0;
}
```
**Visual: Value Category Examples**

``` 
═══════════════════════════════════════════════════════════════════
                    VALUE CATEGORY EXAMPLES
═══════════════════════════════════════════════════════════════════

    EXPRESSION                      CATEGORY    IDENTITY  MOVEABLE
    ──────────                      ────────    ────────  ────────
    
    int x = 10;
    x                               lvalue       YES       NO*
    
    x + 1                           prvalue      NO        YES
    
    std::move(x)                    xvalue       YES       YES
    
    42                              prvalue      NO        YES
    
    "hello"                         lvalue       YES       NO
    
    int& r = x;
    r                               lvalue       YES       NO*
    
    int&& rr = 42;
    rr                              lvalue!      YES       NO*
    (The NAME rr is an lvalue, even though it's an rvalue reference)
    
    std::move(rr)                   xvalue       YES       YES
    
    
    * Can be moved with explicit std::move()

═══════════════════════════════════════════════════════════════════

    FUNCTION RETURN TYPES:
    ──────────────────────
    
    int getValue();                 → prvalue
    int& getRef();                  → lvalue
    int&& getRvalueRef();           → xvalue
    const int& getConstRef();       → lvalue

═══════════════════════════════════════════════════════════════════
```
**Value Category Test**
``` CPP
#include <iostream>
#include <type_traits>
using namespace std;

// Helper to determine value category
template<typename T>
struct value_category {
    static constexpr const char* value = "prvalue";
};

template<typename T>
struct value_category<T&> {
    static constexpr const char* value = "lvalue";
};

template<typename T>
struct value_category<T&&> {
    static constexpr const char* value = "xvalue";
};

// Macro to test and print value category
#define VALUE_CATEGORY(expr) \
    value_category<decltype((expr))>::value

int getInt() { return 42; }
int& getIntRef() { static int x = 10; return x; }
int&& getIntRvalueRef() { static int x = 20; return std::move(x); }

int main() {
    int x = 10;
    int& ref = x;
    int&& rref = 42;
    
    cout << "Value Categories:" << endl;
    cout << "─────────────────" << endl;
    
    cout << "x:                " << VALUE_CATEGORY(x) << endl;
    cout << "42:               " << VALUE_CATEGORY(42) << endl;
    cout << "x + 1:            " << VALUE_CATEGORY(x + 1) << endl;
    cout << "std::move(x):     " << VALUE_CATEGORY(std::move(x)) << endl;
    cout << "ref:              " << VALUE_CATEGORY(ref) << endl;
    cout << "rref:             " << VALUE_CATEGORY(rref) << endl;
    cout << "std::move(rref):  " << VALUE_CATEGORY(std::move(rref)) << endl;
    cout << "getInt():         " << VALUE_CATEGORY(getInt()) << endl;
    cout << "getIntRef():      " << VALUE_CATEGORY(getIntRef()) << endl;
    cout << "getIntRvalueRef():" << VALUE_CATEGORY(getIntRvalueRef()) << endl;
    cout << "++x:              " << VALUE_CATEGORY(++x) << endl;
    cout << "x++:              " << VALUE_CATEGORY(x++) << endl;
    
    return 0;
}
```

**Output:**

```text

Value Categories:
─────────────────
x:                lvalue
42:               prvalue
x + 1:            prvalue
std::move(x):     xvalue
ref:              lvalue
rref:             lvalue
std::move(rref):  xvalue
getInt():         prvalue
getIntRef():      lvalue
getIntRvalueRef():xvalue
++x:              lvalue
x++:              prvalue
```

### 5. Lvalue References
**What is an Lvalue Reference?**
An lvalue reference (T&) is an alias for an existing object. It must be initialized and cannot be reseated.

``` 
┌─────────────────────────────────────────────────────────────────┐
│                    LVALUE REFERENCE                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  SYNTAX: T& ref = lvalue;                                       │
│                                                                 │
│  BINDING RULES:                                                 │
│  ──────────────                                                 │
│  T&        → binds to: modifiable lvalue of type T              │
│  const T&  → binds to: any lvalue or rvalue of type T           │
│                                                                 │
│  PROPERTIES:                                                    │
│  ───────────                                                    │
│  • Must be initialized at declaration                           │
│  • Cannot be null (unlike pointers)                             │
│  • Cannot be reseated (always refers to same object)            │
│  • Reference is the object (not a separate entity)              │
│                                                                 │
│  MEMORY MODEL:                                                  │
│  ─────────────                                                  │
│                                                                 │
│      int x = 42;                                                │
│      int& ref = x;                                              │
│                                                                 │
│      ┌─────────────────────────────────────┐                    │
│      │            MEMORY                   │                    │
│      ├─────────────────────────────────────┤                    │
│      │ Address: 0x1000                     │                    │
│      │ Names: x, ref (SAME location)       │                    │
│      │ Value: 42                           │                    │
│      └─────────────────────────────────────┘                    │
│                                                                 │
│      ref IS x, just another name for the same memory            │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```
**Lvalue Reference Examples**

``` CPP
#include <iostream>
#include <string>
using namespace std;

void modifyByRef(int& x) {
    x *= 2;
}

void printByConstRef(const string& s) {
    cout << s << endl;
}

int main() {
    // ═══════════════════════════════════════════════════════════
    // BASIC LVALUE REFERENCE
    // ═══════════════════════════════════════════════════════════
    
    int x = 10;
    int& ref = x;           // ref is alias for x
    
    cout << "x = " << x << ", ref = " << ref << endl;
    
    ref = 20;               // Modifies x through ref
    cout << "After ref = 20: x = " << x << endl;
    
    x = 30;                 // Modifies x directly
    cout << "After x = 30: ref = " << ref << endl;
    
    cout << "Address of x:   " << &x << endl;
    cout << "Address of ref: " << &ref << endl;  // Same address!
    
    // ═══════════════════════════════════════════════════════════
    // LVALUE REFERENCE BINDING RULES
    // ═══════════════════════════════════════════════════════════
    
    int a = 10;
    
    // T& binds to modifiable lvalue
    int& ref1 = a;          // ✓ OK: a is modifiable lvalue
    
    // int& ref2 = 42;      // ✗ ERROR: 42 is rvalue
    // int& ref3 = a + 1;   // ✗ ERROR: a + 1 is rvalue
    
    // const T& binds to anything!
    const int& cref1 = a;       // ✓ OK: lvalue
    const int& cref2 = 42;      // ✓ OK: rvalue (lifetime extended!)
    const int& cref3 = a + 1;   // ✓ OK: rvalue (lifetime extended!)
    
    cout << "\ncref2 = " << cref2 << endl;  // 42
    cout << "cref3 = " << cref3 << endl;    // 11
    
    // ═══════════════════════════════════════════════════════════
    // REFERENCES IN FUNCTION PARAMETERS
    // ═══════════════════════════════════════════════════════════
    
    int value = 5;
    cout << "\nBefore modifyByRef: " << value << endl;
    modifyByRef(value);
    cout << "After modifyByRef: " << value << endl;
    
    // modifyByRef(10);     // ✗ ERROR: cannot bind non-const ref to rvalue
    
    printByConstRef("Hello");   // ✓ OK: const ref can bind to rvalue
    printByConstRef(string("World")); // ✓ OK
    
    // ═══════════════════════════════════════════════════════════
    // REFERENCES CANNOT BE RESEATED
    // ═══════════════════════════════════════════════════════════
    
    int y = 100;
    int& refX = x;
    
    refX = y;               // This COPIES y's value to x!
                            // refX still refers to x, not y
    
    cout << "\nAfter refX = y:" << endl;
    cout << "x = " << x << ", y = " << y << ", refX = " << refX << endl;
    cout << "&x = " << &x << ", &refX = " << &refX << endl;  // Still same!
    
    // ═══════════════════════════════════════════════════════════
    // REFERENCE TO REFERENCE (not possible directly)
    // ═══════════════════════════════════════════════════════════
    
    int& ref2 = ref1;       // ref2 refers to 'a', not to ref1
                            // There's no "reference to reference"
    
    return 0;
}
```

**const Lvalue Reference - Special Case**

``` CPP
#include <iostream>
using namespace std;

class Heavy {
public:
    Heavy() { cout << "Heavy constructed" << endl; }
    ~Heavy() { cout << "Heavy destroyed" << endl; }
    Heavy(const Heavy&) { cout << "Heavy copied" << endl; }
};

Heavy createHeavy() {
    return Heavy();
}

int main() {
    cout << "=== Const reference extends lifetime ===" << endl;
    
    {
        // const reference can bind to rvalue and EXTENDS its lifetime!
        const Heavy& ref = createHeavy();
        cout << "Using ref..." << endl;
        // Heavy object lives until ref goes out of scope
    }
    cout << "After block" << endl;
    
    cout << "\n=== Without const reference ===" << endl;
    
    {
        // Heavy& ref = createHeavy();  // ERROR: can't bind to rvalue
        
        Heavy obj = createHeavy();  // Creates and possibly copies
        cout << "Using obj..." << endl;
    }
    cout << "After block" << endl;
    
    return 0;
}
```

**Output:**

```text

=== Const reference extends lifetime ===
Heavy constructed
Using ref...
Heavy destroyed
After block

=== Without const reference ===
Heavy constructed
Using obj...
Heavy destroyed
After block
```
### 6. Rvalue References
**What is an Rvalue Reference?**
An rvalue reference (T&&) is a reference that binds to rvalues. It enables move semantics and perfect forwarding.

```
┌─────────────────────────────────────────────────────────────────┐
│                    RVALUE REFERENCE                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  SYNTAX: T&& ref = rvalue;                                      │
│                                                                 │
│  BINDING RULES:                                                 │
│  ──────────────                                                 │
│  T&&        → binds to: rvalues of type T                       │
│  const T&&  → binds to: rvalues (rarely used)                   │
│                                                                 │
│  PURPOSE:                                                       │
│  ────────                                                       │
│  1. Enable MOVE SEMANTICS (steal resources from temporaries)    │
│  2. Enable PERFECT FORWARDING (preserve value category)         │
│  3. Distinguish between "can copy" and "can steal"              │
│                                                                 │
│  KEY INSIGHT:                                                   │
│  ────────────                                                   │
│  An rvalue reference VARIABLE is itself an LVALUE!              │
│  The variable has a name, so it has identity.                   │
│                                                                 │
│      int&& rref = 42;     // rref binds to rvalue 42            │
│      rref;                // But 'rref' itself is an LVALUE!    │
│      std::move(rref);     // Need this to treat as rvalue again │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**Rvalue Reference Basics:**

``` cpp
#include <iostream>
#include <string>
#include <utility>
using namespace std;

int main() {
    // ═══════════════════════════════════════════════════════════
    // BASIC RVALUE REFERENCE
    // ═══════════════════════════════════════════════════════════
    
    int&& rref = 42;            // Binds to rvalue literal
    cout << "rref = " << rref << endl;
    
    rref = 100;                 // Can modify through rvalue reference!
    cout << "After rref = 100: " << rref << endl;
    
    // ═══════════════════════════════════════════════════════════
    // RVALUE REFERENCE BINDING RULES
    // ═══════════════════════════════════════════════════════════
    
    int x = 10;
    
    // int&& rref1 = x;         // ✗ ERROR: x is lvalue
    int&& rref2 = 42;           // ✓ OK: 42 is rvalue
    int&& rref3 = x + 1;        // ✓ OK: x + 1 is rvalue
    int&& rref4 = std::move(x); // ✓ OK: std::move makes it rvalue
    
    // ═══════════════════════════════════════════════════════════
    // IMPORTANT: RVALUE REFERENCE VARIABLE IS AN LVALUE!
    // ═══════════════════════════════════════════════════════════
    
    int&& rr = 42;
    
    // rr is a NAMED variable, so it's an LVALUE
    int& ref = rr;              // ✓ OK: rr is lvalue!
    // int&& rr2 = rr;          // ✗ ERROR: rr is lvalue!
    int&& rr2 = std::move(rr);  // ✓ OK: std::move makes it rvalue
    
    cout << "\n&rr = " << &rr << endl;  // Can take address (it's lvalue)
    
    // ═══════════════════════════════════════════════════════════
    // RVALUE REFERENCE TO STRING
    // ═══════════════════════════════════════════════════════════
    
    string&& strRef = string("Hello");
    cout << "\nstrRef = " << strRef << endl;
    
    strRef += " World";         // Can modify
    cout << "After modification: " << strRef << endl;
    
    return 0;
}
```

**Move Semantics with Rvalue References:**
``` cpp
#include <iostream>
#include <cstring>
#include <utility>
using namespace std;

class String {
    char* data;
    size_t length;

public:
    // Constructor
    String(const char* str = "") {
        length = strlen(str);
        data = new char[length + 1];
        strcpy(data, str);
        cout << "Constructor: \"" << data << "\"" << endl;
    }

    // Copy Constructor (lvalue reference parameter)
    String(const String& other) {
        length = other.length;
        data = new char[length + 1];
        strcpy(data, other.data);
        cout << "Copy Constructor: \"" << data << "\" (DEEP COPY)" << endl;
    }

    // Move Constructor (rvalue reference parameter)
    String(String&& other) noexcept {
        length = other.length;
        data = other.data;          // Steal the pointer!
        other.data = nullptr;       // Leave source in valid state
        other.length = 0;
        cout << "Move Constructor: \"" << data << "\" (POINTER STEAL)" << endl;
    }

    // Copy Assignment
    String& operator=(const String& other) {
        cout << "Copy Assignment" << endl;
        if (this != &other) {
            delete[] data;
            length = other.length;
            data = new char[length + 1];
            strcpy(data, other.data);
        }
        return *this;
    }

    // Move Assignment
    String& operator=(String&& other) noexcept {
        cout << "Move Assignment" << endl;
        if (this != &other) {
            delete[] data;
            data = other.data;
            length = other.length;
            other.data = nullptr;
            other.length = 0;
        }
        return *this;
    }

    ~String() {
        cout << "Destructor: \"" << (data ? data : "null") << "\"" << endl;
        delete[] data;
    }

    const char* c_str() const { return data ? data : ""; }
};

String createString() {
    return String("Created");
}

int main() {
    cout << "=== Copy from lvalue ===" << endl;
    String s1("Hello");
    String s2 = s1;           // s1 is LVALUE → Copy constructor
    
    cout << "\n=== Move from rvalue ===" << endl;
    String s3 = String("World");  // Temporary is RVALUE → Move constructor
    
    cout << "\n=== Move from function return ===" << endl;
    String s4 = createString();   // Return value is RVALUE → Move
    
    cout << "\n=== Explicit move with std::move ===" << endl;
    String s5 = std::move(s1);    // std::move makes RVALUE → Move
    cout << "s1 after move: \"" << s1.c_str() << "\"" << endl;
    
    cout << "\n=== Assignment ===" << endl;
    s2 = s3;                      // Copy assignment (s3 is lvalue)
    s2 = String("Temp");          // Move assignment (temporary is rvalue)
    
    cout << "\n=== Cleanup ===" << endl;
    return 0;
}
```

**Function Overloading with References:**
``` cpp
#include <iostream>
#include <string>
using namespace std;

class Processor {
public:
    // Overload 1: Takes lvalue reference
    void process(const string& s) {
        cout << "process(const string&): Copying \"" << s << "\"" << endl;
    }

    // Overload 2: Takes rvalue reference
    void process(string&& s) {
        cout << "process(string&&): Moving \"" << s << "\"" << endl;
        // Can safely modify/move from s
    }
};

int main() {
    Processor proc;
    
    string s = "Hello";
    
    cout << "=== Calling with lvalue ===" << endl;
    proc.process(s);              // Calls const string& version
    
    cout << "\n=== Calling with rvalue ===" << endl;
    proc.process(string("World")); // Calls string&& version
    proc.process("Literal");       // Calls string&& version (converts to temp string)
    
    cout << "\n=== Calling with std::move ===" << endl;
    proc.process(std::move(s));   // Calls string&& version
    
    cout << "\n=== s after move: \"" << s << "\"" << endl;
    
    return 0;
}
```

**Output:**

```text

=== Calling with lvalue ===
process(const string&): Copying "Hello"

=== Calling with rvalue ===
process(string&&): Moving "World"
process(string&&): Moving "Literal"

=== Calling with std::move ===
process(string&&): Moving "Hello"

=== s after move: ""
```

### 7. Reference Collapsing
**What is Reference Collapsing?**
When you have references to references (through templates or typedef), C++ collapses them according to specific rules.

``` 
┌─────────────────────────────────────────────────────────────────┐
│                 REFERENCE COLLAPSING RULES                      │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  T& &   →  T&      (lvalue ref to lvalue ref = lvalue ref)      │
│  T& &&  →  T&      (rvalue ref to lvalue ref = lvalue ref)      │
│  T&& &  →  T&      (lvalue ref to rvalue ref = lvalue ref)      │
│  T&& && →  T&&     (rvalue ref to rvalue ref = rvalue ref)      │
│                                                                 │
│  SIMPLE RULE:                                                   │
│  ────────────                                                   │
│  If EITHER reference is lvalue reference (&), result is &       │
│  Only if BOTH are rvalue references (&&), result is &&          │
│                                                                 │
│  VISUAL:                                                        │
│                                                                 │
│       &  + &  = &                                               │
│       &  + && = &                                               │
│       && + &  = &                                               │
│       && + && = &&                                              │
│                                                                 │
│  Think of & as "sticky" - it always wins!                       │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**Reference Collapsing in Action**

``` cpp
#include <iostream>
#include <type_traits>
using namespace std;

// Helper to print type
template<typename T>
void printType() {
    if constexpr (is_lvalue_reference_v<T>) {
        cout << "lvalue reference (&)" << endl;
    } else if constexpr (is_rvalue_reference_v<T>) {
        cout << "rvalue reference (&&)" << endl;
    } else {
        cout << "not a reference" << endl;
    }
}

template<typename T>
void demonstrateCollapsing() {
    using LRef = T&;
    using RRef = T&&;
    
    cout << "T = ";
    if constexpr (is_lvalue_reference_v<T>) {
        cout << "U&" << endl;
    } else if constexpr (is_rvalue_reference_v<T>) {
        cout << "U&&" << endl;
    } else {
        cout << "U (no reference)" << endl;
    }
    
    cout << "  T&  = "; printType<LRef>();
    cout << "  T&& = "; printType<RRef>();
    cout << endl;
}

int main() {
    cout << "=== Reference Collapsing Rules ===" << endl << endl;
    
    cout << "When T is plain type (int):" << endl;
    demonstrateCollapsing<int>();
    
    cout << "When T is lvalue reference (int&):" << endl;
    demonstrateCollapsing<int&>();
    
    cout << "When T is rvalue reference (int&&):" << endl;
    demonstrateCollapsing<int&&>();
    
    return 0;
}
```

**Output:**

```text

=== Reference Collapsing Rules ===

When T is plain type (int):
T = U (no reference)
  T&  = lvalue reference (&)
  T&& = rvalue reference (&&)

When T is lvalue reference (int&):
T = U&
  T&  = lvalue reference (&)
  T&& = lvalue reference (&)

When T is rvalue reference (int&&):
T = U&&
  T&  = lvalue reference (&)
  T&& = rvalue reference (&&)
```  

**Forwarding References (Universal References)**

``` cpp
#include <iostream>
#include <type_traits>
using namespace std;

// T&& in template context is a FORWARDING REFERENCE (Universal Reference)
// NOT a regular rvalue reference!

template<typename T>
void forwardingRef(T&& arg) {
    cout << "T = ";
    if constexpr (is_lvalue_reference_v<T>) {
        cout << "deduced as lvalue reference" << endl;
    } else {
        cout << "deduced as non-reference" << endl;
    }
    
    cout << "arg is ";
    if constexpr (is_lvalue_reference_v<decltype(arg)>) {
        cout << "lvalue reference" << endl;
    } else {
        cout << "rvalue reference" << endl;
    }
}

// This is a REGULAR rvalue reference (not forwarding)
void regularRvalueRef(int&& arg) {
    cout << "regularRvalueRef called" << endl;
}

int main() {
    int x = 10;
    
    cout << "=== Forwarding Reference ===" << endl;
    
    cout << "\nCalling with lvalue (x):" << endl;
    forwardingRef(x);        // T deduced as int&, arg is int& (T& && = T&)
    
    cout << "\nCalling with rvalue (42):" << endl;
    forwardingRef(42);       // T deduced as int, arg is int&& (T&&)
    
    cout << "\nCalling with std::move(x):" << endl;
    forwardingRef(std::move(x)); // T deduced as int, arg is int&&
    
    cout << "\n=== Regular Rvalue Reference ===" << endl;
    
    // regularRvalueRef(x);  // ERROR: cannot bind lvalue to rvalue ref
    regularRvalueRef(42);    // OK: 42 is rvalue
    regularRvalueRef(std::move(x)); // OK: std::move makes it rvalue
    
    return 0;
}
```

**Output:**

```text

=== Forwarding Reference ===

Calling with lvalue (x):
T = deduced as lvalue reference
arg is lvalue reference

Calling with rvalue (42):
T = deduced as non-reference
arg is rvalue reference

Calling with std::move(x):
T = deduced as non-reference
arg is rvalue reference

=== Regular Rvalue Reference ===
regularRvalueRef called
regularRvalueRef called
```
**Visual: Forwarding Reference Deduction**

```
═══════════════════════════════════════════════════════════════════
              FORWARDING REFERENCE DEDUCTION
═══════════════════════════════════════════════════════════════════

    template<typename T>
    void func(T&& arg);

    ═══════════════════════════════════════════════════════════════
    
    CALLED WITH LVALUE:
    ───────────────────
    
    int x = 10;
    func(x);
    
    Step 1: x is lvalue
    Step 2: T deduced as int& (lvalue reference)
    Step 3: T&& = int& && = int& (reference collapsing)
    
    Result: func(int& arg)  ← arg is lvalue reference
    
    ═══════════════════════════════════════════════════════════════
    
    CALLED WITH RVALUE:
    ───────────────────
    
    func(42);
    
    Step 1: 42 is rvalue
    Step 2: T deduced as int (no reference)
    Step 3: T&& = int&& (no collapsing needed)
    
    Result: func(int&& arg)  ← arg is rvalue reference
    
    ═══════════════════════════════════════════════════════════════
    
    CALLED WITH std::move(x):
    ─────────────────────────
    
    func(std::move(x));
    
    Step 1: std::move(x) is xvalue (rvalue)
    Step 2: T deduced as int (no reference)
    Step 3: T&& = int&&
    
    Result: func(int&& arg)  ← arg is rvalue reference

═══════════════════════════════════════════════════════════════════
```

### 8. std::move and std::forward
**std::move - Cast to Rvalue**

``` cpp
#include <iostream>
#include <utility>
#include <type_traits>
using namespace std;

// Simplified implementation of std::move
template<typename T>
constexpr remove_reference_t<T>&& my_move(T&& t) noexcept {
    return static_cast<remove_reference_t<T>&&>(t);
}

int main() {
    cout << "=== std::move Explained ===" << endl;
    
    int x = 42;
    
    // std::move doesn't actually MOVE anything!
    // It just CASTS to rvalue reference
    
    cout << "\nBefore move:" << endl;
    cout << "x = " << x << endl;
    cout << "x is lvalue: " << is_lvalue_reference_v<decltype((x))> << endl;
    
    // This is what std::move does:
    auto&& moved = std::move(x);
    
    cout << "\nAfter std::move(x):" << endl;
    cout << "x = " << x << endl;  // x is UNCHANGED!
    cout << "moved = " << moved << endl;
    cout << "std::move(x) is rvalue: " << is_rvalue_reference_v<decltype(std::move(x))> << endl;
    
    // The actual move happens when you USE the result
    string s1 = "Hello";
    cout << "\ns1 before: \"" << s1 << "\"" << endl;
    
    string s2 = std::move(s1);  // Move constructor called
    cout << "s1 after: \"" << s1 << "\" (moved-from state)" << endl;
    cout << "s2 after: \"" << s2 << "\"" << endl;
    
    return 0;
}
```
**std::forward - Perfect Forwarding**

``` cpp
#include <iostream>
#include <utility>
#include <string>
using namespace std;

// Target functions
void process(const string& s) {
    cout << "  process(const string&): lvalue \"" << s << "\"" << endl;
}

void process(string&& s) {
    cout << "  process(string&&): rvalue \"" << s << "\"" << endl;
}

// WITHOUT std::forward - Always calls lvalue version!
template<typename T>
void wrapperBad(T&& arg) {
    cout << "wrapperBad: ";
    process(arg);  // arg is always lvalue (it has a name!)
}

// WITH std::forward - Preserves value category!
template<typename T>
void wrapperGood(T&& arg) {
    cout << "wrapperGood: ";
    process(std::forward<T>(arg));  // Forwards as lvalue or rvalue
}

int main() {
    string s = "Hello";
    
    cout << "=== Without std::forward (BAD) ===" << endl;
    wrapperBad(s);              // Should call lvalue version ✓
    wrapperBad(string("World")); // Should call rvalue version ✗ (calls lvalue!)
    
    cout << "\n=== With std::forward (GOOD) ===" << endl;
    wrapperGood(s);              // Calls lvalue version ✓
    wrapperGood(string("World")); // Calls rvalue version ✓
    
    cout << "\n=== With std::move ===" << endl;
    wrapperGood(std::move(s));   // Calls rvalue version ✓
    
    return 0;
}
```

**Output:**

```text

=== Without std::forward (BAD) ===
wrapperBad:   process(const string&): lvalue "Hello"
wrapperBad:   process(const string&): lvalue "World"

=== With std::forward (GOOD) ===
wrapperGood:   process(const string&): lvalue "Hello"
wrapperGood:   process(string&&): rvalue "World"

=== With std::move ===
wrapperGood:   process(string&&): rvalue "Hello"
```

**How std::forward Works**

``` cpp
#include <iostream>
#include <type_traits>
using namespace std;

// Simplified std::forward implementation
template<typename T>
constexpr T&& my_forward(remove_reference_t<T>& t) noexcept {
    return static_cast<T&&>(t);
}

template<typename T>
constexpr T&& my_forward(remove_reference_t<T>&& t) noexcept {
    static_assert(!is_lvalue_reference_v<T>, "Cannot forward rvalue as lvalue");
    return static_cast<T&&>(t);
}

/*
═══════════════════════════════════════════════════════════════════
                   HOW std::forward WORKS
═══════════════════════════════════════════════════════════════════

When called with LVALUE:
────────────────────────
    template<typename T>  // T = int&
    void wrapper(T&& arg) {
        target(std::forward<T>(arg));  // std::forward<int&>(arg)
    }
    
    std::forward<int&>(arg) returns:
        static_cast<int& &&>(arg) = static_cast<int&>(arg)
        → lvalue reference (passed to lvalue overload)

When called with RVALUE:
────────────────────────
    template<typename T>  // T = int
    void wrapper(T&& arg) {
        target(std::forward<T>(arg));  // std::forward<int>(arg)
    }
    
    std::forward<int>(arg) returns:
        static_cast<int&&>(arg)
        → rvalue reference (passed to rvalue overload)

═══════════════════════════════════════════════════════════════════
*/

void targetFunc(int& x) { cout << "lvalue: " << x << endl; }
void targetFunc(int&& x) { cout << "rvalue: " << x << endl; }

template<typename T>
void forwardDemo(T&& arg) {
    cout << "  Without forward: "; targetFunc(arg);
    cout << "  With forward:    "; targetFunc(std::forward<T>(arg));
}

int main() {
    int x = 42;
    
    cout << "Passing lvalue:" << endl;
    forwardDemo(x);
    
    cout << "\nPassing rvalue:" << endl;
    forwardDemo(100);
    
    return 0;
}
```

**Visual: std::move vs std::forward**
```
═══════════════════════════════════════════════════════════════════
                std::move vs std::forward
═══════════════════════════════════════════════════════════════════

    std::move(x)                    std::forward<T>(x)
    ────────────                    ──────────────────
    
    ALWAYS casts to rvalue          CONDITIONALLY casts based on T
    
    ┌──────────┐                    ┌──────────┐
    │  lvalue  │                    │  lvalue  │
    │    x     │                    │    x     │
    └────┬─────┘                    └────┬─────┘
         │                               │
         ▼                        T=U&   │   T=U
    ┌──────────┐               ┌────────┴────────┐
    │  rvalue  │               │                 │
    │   (x)    │               ▼                 ▼
    └──────────┘          ┌──────────┐     ┌──────────┐
                          │  lvalue  │     │  rvalue  │
    USE: When you KNOW    │   (x)    │     │   (x)    │
    you want to move      └──────────┘     └──────────┘
    
                          USE: In templates to preserve
                          original value category

═══════════════════════════════════════════════════════════════════

    RULE OF THUMB:
    ──────────────
    • std::move: Use when you OWN the object and want to transfer
    • std::forward: Use in templates to forward arguments
    
    DON'T:
    ──────
    • Don't use std::move on return values (prevents RVO)
    • Don't use std::move on const objects (will copy anyway)
    • Don't use std::forward outside template forwarding context

═══════════════════════════════════════════════════════════════════
```

### 9. Practical Applications
**Perfect Forwarding Factory**

``` cpp
#include <iostream>
#include <memory>
#include <utility>
using namespace std;

class Widget {
    int id;
    string name;
    double value;

public:
    // Multiple constructors
    Widget() : id(0), name("default"), value(0.0) {
        cout << "Default constructor" << endl;
    }

    Widget(int i) : id(i), name("id-only"), value(0.0) {
        cout << "Int constructor: " << id << endl;
    }

    Widget(int i, string n) : id(i), name(std::move(n)), value(0.0) {
        cout << "Int+String constructor: " << id << ", " << name << endl;
    }

    Widget(int i, string n, double v) : id(i), name(std::move(n)), value(v) {
        cout << "Full constructor: " << id << ", " << name << ", " << value << endl;
    }

    void print() const {
        cout << "Widget(" << id << ", " << name << ", " << value << ")" << endl;
    }
};

// Perfect forwarding factory function
template<typename T, typename... Args>
unique_ptr<T> makeObject(Args&&... args) {
    return make_unique<T>(std::forward<Args>(args)...);
}

// Emplacement wrapper
template<typename Container, typename... Args>
void emplaceBack(Container& c, Args&&... args) {
    c.emplace_back(std::forward<Args>(args)...);
}

int main() {
    cout << "=== Using makeObject factory ===" << endl;
    
    auto w1 = makeObject<Widget>();
    auto w2 = makeObject<Widget>(42);
    auto w3 = makeObject<Widget>(100, "test");
    auto w4 = makeObject<Widget>(200, string("named"), 3.14);
    
    cout << "\n=== Widgets created ===" << endl;
    w1->print();
    w2->print();
    w3->print();
    w4->print();
    
    cout << "\n=== Using emplaceBack ===" << endl;
    vector<Widget> widgets;
    widgets.reserve(3);
    
    emplaceBack(widgets, 1, "first", 1.1);
    emplaceBack(widgets, 2, "second", 2.2);
    emplaceBack(widgets, 3, "third", 3.3);
    
    return 0;
}
```

**Efficient String Builder**

``` cpp
#include <iostream>
#include <string>
#include <vector>
#include <utility>
using namespace std;

class StringBuilder {
    vector<string> parts;

public:
    // Accept both lvalues and rvalues efficiently
    template<typename T>
    StringBuilder& append(T&& str) {
        parts.push_back(std::forward<T>(str));
        return *this;
    }

    // Multiple arguments
    template<typename T, typename... Args>
    StringBuilder& append(T&& first, Args&&... rest) {
        append(std::forward<T>(first));
        return append(std::forward<Args>(rest)...);
    }

    string build() const {
        size_t totalSize = 0;
        for (const auto& s : parts) {
            totalSize += s.size();
        }

        string result;
        result.reserve(totalSize);

        for (const auto& s : parts) {
            result += s;
        }

        return result;
    }
};

int main() {
    StringBuilder builder;
    
    string name = "World";
    
    // Mixing lvalues and rvalues
    builder.append("Hello, ")           // rvalue
           .append(name)                // lvalue (copied)
           .append("! ")                // rvalue
           .append(string("How "))      // rvalue (moved)
           .append("are you?");         // rvalue
    
    cout << builder.build() << endl;
    
    // Using variadic append
    StringBuilder builder2;
    builder2.append("One", " Two", " Three");
    cout << builder2.build() << endl;
    
    return 0;
}
```

**Move-Only Type**

``` cpp
#include <iostream>
#include <memory>
#include <vector>
#include <utility>
using namespace std;

// Resource that can only be moved, not copied
class UniqueResource {
    int* data;
    string name;

public:
    UniqueResource(const string& n, int value)
        : data(new int(value)), name(n) {
        cout << "Created: " << name << " = " << *data << endl;
    }

    // Delete copy operations
    UniqueResource(const UniqueResource&) = delete;
    UniqueResource& operator=(const UniqueResource&) = delete;

    // Move constructor
    UniqueResource(UniqueResource&& other) noexcept
        : data(other.data), name(std::move(other.name)) {
        other.data = nullptr;
        cout << "Moved: " << name << endl;
    }

    // Move assignment
    UniqueResource& operator=(UniqueResource&& other) noexcept {
        if (this != &other) {
            delete data;
            data = other.data;
            name = std::move(other.name);
            other.data = nullptr;
        }
        cout << "Move assigned: " << name << endl;
        return *this;
    }

    ~UniqueResource() {
        if (data) {
            cout << "Destroyed: " << name << endl;
        }
        delete data;
    }

    void print() const {
        cout << name << " = " << (data ? to_string(*data) : "null") << endl;
    }
};

UniqueResource createResource(const string& name, int value) {
    return UniqueResource(name, value);
}

int main() {
    cout << "=== Creating resources ===" << endl;
    UniqueResource r1("Resource1", 100);
    
    // UniqueResource r2 = r1;  // ERROR: Copy deleted
    
    cout << "\n=== Moving resource ===" << endl;
    UniqueResource r2 = std::move(r1);  // Must use std::move
    
    cout << "\n=== After move ===" << endl;
    r1.print();  // null
    r2.print();  // Resource1 = 100
    
    cout << "\n=== Vector of move-only types ===" << endl;
    vector<UniqueResource> resources;
    resources.reserve(3);
    
    // Must move into vector
    resources.push_back(UniqueResource("R1", 1));
    resources.push_back(createResource("R2", 2));
    resources.emplace_back("R3", 3);  // In-place construction
    
    cout << "\n=== Cleanup ===" << endl;
    return 0;
}
```

### 10. Best Practices
**Summary Table**

``` 
┌─────────────────────────────────────────────────────────────────┐
│                    VALUE CATEGORIES SUMMARY                     │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  EXPRESSION TYPE              VALUE CATEGORY                    │
│  ───────────────              ──────────────                    │
│  Variable name (x)            lvalue                            │
│  Dereferenced ptr (*p)        lvalue                            │
│  Array subscript (a[i])       lvalue                            │
│  Prefix ++/-- (++x)           lvalue                            │
│  Lvalue ref return (f())      lvalue                            │
│  String literal ("hi")        lvalue                            │
│  ───────────────              ──────────────                    │
│  Literal (42)                 prvalue                           │
│  Arithmetic (x + y)           prvalue                           │
│  Postfix ++/-- (x++)          prvalue                           │
│  Value return (f())           prvalue                           │
│  Temporary (Type())           prvalue                           │
│  Lambda ([](){})              prvalue                           │
│  ───────────────              ──────────────                    │
│  std::move(x)                 xvalue                            │
│  Rvalue ref return (f())      xvalue                            │
│  Cast to rvalue ref           xvalue                            │
│                                                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  REFERENCE TYPE               BINDS TO                          │
│  ──────────────               ────────                          │
│  T&                           lvalue of T only                  │
│  const T&                     lvalue or rvalue of T             │
│  T&&                          rvalue of T only                  │
│  const T&&                    rvalue of T (rare)                │
│                                                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  REFERENCE COLLAPSING:                                          │
│  T& &   = T&                                                    │
│  T& &&  = T&                                                    │
│  T&& &  = T&                                                    │
│  T&& && = T&&                                                   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**Best Practices Checklist**

``` cpp
#include <iostream>
#include <string>
#include <utility>
using namespace std;

// ═══════════════════════════════════════════════════════════════
// ✓ GOOD PRACTICES
// ═══════════════════════════════════════════════════════════════

class Good {
    string data;

public:
    // ✓ Take by value and move for sink parameters
    Good(string s) : data(std::move(s)) {}

    // ✓ Use const& for read-only access
    void display(const string& s) const {
        cout << s << endl;
    }

    // ✓ Overload for lvalue and rvalue if different handling needed
    void process(const string& s) {
        data = s;  // Copy
    }

    void process(string&& s) {
        data = std::move(s);  // Move
    }

    // ✓ Perfect forwarding in templates
    template<typename T>
    void emplace(T&& value) {
        data = std::forward<T>(value);
    }

    // ✓ noexcept for move operations
    Good(Good&& other) noexcept : data(std::move(other.data)) {}
    Good& operator=(Good&& other) noexcept {
        data = std::move(other.data);
        return *this;
    }
};

// ═══════════════════════════════════════════════════════════════
// ✗ BAD PRACTICES
// ═══════════════════════════════════════════════════════════════

class Bad {
    string data;

public:
    // ✗ Don't use std::move on return (prevents RVO)
    string getData() {
        return std::move(data);  // BAD!
        // Should be: return data;
    }

    // ✗ Don't std::move const objects (will copy anyway)
    void processConst(const string& s) {
        data = std::move(s);  // BAD! Still copies
    }

    // ✗ Don't use object after moving from it (except assign/destroy)
    void badMove() {
        string s = "hello";
        string t = std::move(s);
        cout << s.size();  // BAD! s is in unspecified state
    }
};

// ═══════════════════════════════════════════════════════════════
// WHEN TO USE WHAT
// ═══════════════════════════════════════════════════════════════

/*
┌─────────────────────────────────────────────────────────────────┐
│                    DECISION GUIDE                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  FOR FUNCTION PARAMETERS:                                       │
│  ─────────────────────────                                      │
│                                                                 │
│  Read-only access?                                              │
│    → Use const T&                                               │
│                                                                 │
│  Will store/own the value?                                      │
│    → Use T (by value) and std::move internally                  │
│    → OR overload with const T& and T&&                          │
│                                                                 │
│  Perfect forwarding in template?                                │
│    → Use T&& with std::forward<T>                               │
│                                                                 │
│  FOR RETURN VALUES:                                             │
│  ──────────────────                                             │
│                                                                 │
│  Returning local variable?                                      │
│    → Return by value (RVO will optimize)                        │
│    → DON'T use std::move                                        │
│                                                                 │
│  Returning member?                                              │
│    → Use const T& for read access                               │
│    → Use T for copy/move                                        │
│                                                                 │
│  FOR MOVE OPERATIONS:                                           │
│  ────────────────────                                           │
│                                                                 │
│  Want to transfer ownership?                                    │
│    → Use std::move(obj)                                         │
│                                                                 │
│  In template, preserve category?                                │
│    → Use std::forward<T>(arg)                                   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
*/
```
**Quick Reference Card**
```
┌─────────────────────────────────────────────────────────────────┐
│              VALUE CATEGORIES QUICK REFERENCE                   │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  LVALUE:                                                        │
│  • Has identity (name/address)                                  │
│  • Persists beyond expression                                   │
│  • Examples: x, *ptr, arr[i], ++x, "string literal"             │
│                                                                 │
│  RVALUE:                                                        │
│  • Temporary/expiring value                                     │
│  • Can be moved from                                            │
│  • Examples: 42, x+y, x++, function(), Type()                   │
│                                                                 │
│  XVALUE (eXpiring):                                             │
│  • Has identity AND can be moved                                │
│  • Examples: std::move(x), static_cast<T&&>(x)                  │
│                                                                 │
│  ─────────────────────────────────────────────────────────────  │
│                                                                 │
│  T&    →  Binds to lvalue only                                  │
│  const T& →  Binds to lvalue OR rvalue                          │
│  T&&   →  Binds to rvalue only                                  │
│                                                                 │
│  ─────────────────────────────────────────────────────────────  │
│                                                                 │
│  std::move(x)       →  Cast x to rvalue (enable moving)         │
│  std::forward<T>(x) →  Preserve x's value category              │
│                                                                 │
│  ─────────────────────────────────────────────────────────────  │
│                                                                 │
│  REMEMBER:                                                      │
│  • An rvalue reference VARIABLE is an lvalue!                   │
│  • std::move doesn't move, it just casts                        │
│  • const objects can't be moved (will copy)                     │
│  • Don't std::move return values                                │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```







