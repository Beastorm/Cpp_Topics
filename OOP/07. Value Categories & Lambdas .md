## Value Categories in C++
A comprehensive guide covering lvalues, rvalues, and their references.

### Table of Contents
* Introduction to Value Categories
* Lvalues
* Rvalues
* Extended Value Categories (C++11)
* Lvalue References
* Rvalue References
* Reference Collapsing
* std::move and std::forward
* Practical Applications
* Best Practices

### 1. Introduction to Value Categories
**What Are Value Categories?**
Every expression in C++ has two independent properties:

* **Type** - What kind of data it represents (int, string, etc.)
* **Value Category** - How the expression can be used

``` cpp
┌─────────────────────────────────────────────────────────────────┐
│                    VALUE CATEGORIES                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  VALUE CATEGORY determines:                                     │
│  ──────────────────────────                                     │
│  • Can it appear on LEFT side of assignment?                    │
│  • Can we take its ADDRESS?                                     │
│  • Does it have IDENTITY (name/location)?                       │
│  • Can it be MOVED from?                                        │
│                                                                 │
│  HISTORICAL VIEW (Pre-C++11):                                   │
│  ────────────────────────────                                   │
│                                                                 │
│                    expression                                   │
│                        │                                        │
│              ┌─────────┴─────────┐                              │
│              │                   │                              │
│           lvalue              rvalue                            │
│         (left value)        (right value)                       │
│         (locator)           (read only)                         │
│                                                                 │
│  MODERN VIEW (C++11 and later):                                 │
│  ──────────────────────────────                                 │
│                                                                 │
│                    expression                                   │
│                        │                                        │
│              ┌─────────┴─────────┐                              │
│              │                   │                              │
│           glvalue             rvalue                            │
│              │                   │                              │
│        ┌─────┴─────┐       ┌─────┴─────┐                        │
│        │           │       │           │                        │
│     lvalue      xvalue  xvalue     prvalue                      │
│                    └───┬───┘                                    │
│                        │                                        │
│                     (shared)                                    │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**Quick Classification**
``` cpp
#include <iostream>
#include <string>
using namespace std;

int getValue() { return 42; }
int& getRef(int& x) { return x; }
int&& getRvalueRef() { static int x = 10; return std::move(x); }

int main() {
    int x = 10;
    int y = 20;
    int* ptr = &x;
    
    // ═══════════════════════════════════════════════════════════
    // LVALUES - Have identity, can take address
    // ═══════════════════════════════════════════════════════════
    
    x;              // lvalue: named variable
    y;              // lvalue: named variable
    *ptr;           // lvalue: dereferenced pointer
    ptr[0];         // lvalue: array subscript
    getRef(x);      // lvalue: function returning lvalue reference
    ++x;            // lvalue: pre-increment returns reference
    "hello";        // lvalue: string literal (special case!)
    
    // ═══════════════════════════════════════════════════════════
    // RVALUES - Temporary, cannot take address (usually)
    // ═══════════════════════════════════════════════════════════
    
    42;             // rvalue (prvalue): integer literal
    3.14;           // rvalue (prvalue): floating literal
    x + y;          // rvalue (prvalue): arithmetic expression
    getValue();     // rvalue (prvalue): function returning by value
    x++;            // rvalue (prvalue): post-increment returns copy
    int(x);         // rvalue (prvalue): explicit cast
    string("hi");   // rvalue (prvalue): temporary object
    std::move(x);   // rvalue (xvalue): moved-from expression
    getRvalueRef(); // rvalue (xvalue): function returning rvalue ref
    
    return 0;
}
```

### 2. Lvalues
**What is an Lvalue?**
An lvalue (locator value) is an expression that:

Has a persistent identity (occupies memory location)
Can have its address taken with &
Can appear on the left side of assignment (if modifiable)
Persists beyond the expression

``` 
┌─────────────────────────────────────────────────────────────────┐
│                      LVALUE PROPERTIES                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ✓ Has identity (name or memory location)                       │
│  ✓ Can take address with & operator                             │
│  ✓ Persists beyond single expression                            │
│  ✓ Can be on left side of = (if not const)                      │
│  ✓ Can bind to lvalue reference (T&)                            │
│  ✓ Can bind to const lvalue reference (const T&)                │
│                                                                 │
│  MEMORY VISUALIZATION:                                          │
│  ─────────────────────                                          │
│                                                                 │
│      int x = 42;                                                │
│                                                                 │
│      ┌──────────────────────────────────┐                       │
│      │           MEMORY                 │                       │
│      ├──────────────────────────────────┤                       │
│      │ Address: 0x1000                  │                       │
│      │ Name: x                          │ ◄── LVALUE            │
│      │ Value: 42                        │     Has identity      │
│      │ Lifetime: until scope ends       │     Has address       │
│      └──────────────────────────────────┘     Persists          │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**Lvalue Examples**
``` cpp
#include <iostream>
#include <string>
using namespace std;

int globalVar = 100;

int& getGlobalRef() {
    return globalVar;
}

class MyClass {
public:
    int member;
    static int staticMember;
    
    int& getMember() { return member; }
};

int MyClass::staticMember = 50;

int main() {
    // ═══════════════════════════════════════════════════════════
    // NAMED VARIABLES - Always lvalues
    // ═══════════════════════════════════════════════════════════
    
    int x = 10;                      // x is lvalue
    const int y = 20;                // y is lvalue (but not modifiable)
    int& ref = x;                    // ref is lvalue
    int* ptr = &x;                   // ptr is lvalue
    int arr[5] = {1,2,3,4,5};        // arr is lvalue
    
    cout << "Address of x: " << &x << endl;         // ✓ OK
    cout << "Address of y: " << &y << endl;         // ✓ OK
    cout << "Address of ref: " << &ref << endl;     // ✓ OK
    cout << "Address of ptr: " << &ptr << endl;     // ✓ OK
    
    // ═══════════════════════════════════════════════════════════
    // DEREFERENCED POINTERS - Lvalues
    // ═══════════════════════════════════════════════════════════
    
    *ptr = 100;                      // *ptr is lvalue
    cout << "Address of *ptr: " << &(*ptr) << endl; // ✓ OK
    
    // ═══════════════════════════════════════════════════════════
    // ARRAY SUBSCRIPTS - Lvalues
    // ═══════════════════════════════════════════════════════════
    
    arr[0] = 10;                     // arr[0] is lvalue
    ptr[0] = 20;                     // ptr[0] is lvalue
    cout << "Address of arr[0]: " << &arr[0] << endl; // ✓ OK
    
    // ═══════════════════════════════════════════════════════════
    // FUNCTION RETURNING LVALUE REFERENCE - Lvalue
    // ═══════════════════════════════════════════════════════════
    
    getGlobalRef() = 200;            // getGlobalRef() is lvalue
    cout << "globalVar: " << globalVar << endl;      // 200
    cout << "Address: " << &getGlobalRef() << endl;  // ✓ OK
    
    // ═══════════════════════════════════════════════════════════
    // PRE-INCREMENT/DECREMENT - Lvalues
    // ═══════════════════════════════════════════════════════════
    
    ++x;                             // ++x is lvalue (returns reference)
    --x;                             // --x is lvalue
    ++(++x);                         // Can chain - both are lvalues
    cout << "Address of ++x: " << &(++x) << endl;    // ✓ OK
    
    // ═══════════════════════════════════════════════════════════
    // CLASS MEMBERS - Lvalues
    // ═══════════════════════════════════════════════════════════
    
    MyClass obj;
    obj.member = 10;                 // obj.member is lvalue
    MyClass::staticMember = 60;      // staticMember is lvalue
    obj.getMember() = 30;            // getMember() returns lvalue
    
    // ═══════════════════════════════════════════════════════════
    // STRING LITERALS - Lvalues (special case!)
    // ═══════════════════════════════════════════════════════════
    
    // String literals are lvalues (arrays of const char)
    const char* str = "hello";
    cout << "Address of literal: " << (void*)"hello" << endl; // ✓ OK
    
    // ═══════════════════════════════════════════════════════════
    // COMMA OPERATOR - Result is lvalue if right operand is
    // ═══════════════════════════════════════════════════════════
    
    (x, y);                          // Result is lvalue (y)
    
    return 0;
}
```

**Modifiable vs Non-Modifiable Lvalues**
``` cpp
#include <iostream>
using namespace std;

int main() {
    // ═══════════════════════════════════════════════════════════
    // MODIFIABLE LVALUES - Can appear on left of assignment
    // ═══════════════════════════════════════════════════════════
    
    int x = 10;
    x = 20;              // ✓ OK: x is modifiable lvalue
    
    int arr[5];
    arr[0] = 1;          // ✓ OK: arr[0] is modifiable lvalue
    
    int* ptr = &x;
    *ptr = 30;           // ✓ OK: *ptr is modifiable lvalue
    
    // ═══════════════════════════════════════════════════════════
    // NON-MODIFIABLE LVALUES - Cannot appear on left of assignment
    // ═══════════════════════════════════════════════════════════
    
    const int y = 10;
    // y = 20;           // ✗ ERROR: y is const (non-modifiable lvalue)
    
    const int& ref = x;
    // ref = 30;         // ✗ ERROR: ref is const reference
    
    const int arr2[5] = {1,2,3,4,5};
    // arr2[0] = 10;     // ✗ ERROR: arr2 elements are const
    
    // String literals are const
    // "hello"[0] = 'H'; // ✗ ERROR: string literal is const
    
    // ═══════════════════════════════════════════════════════════
    // KEY POINT: Being an lvalue ≠ Being modifiable
    // ═══════════════════════════════════════════════════════════
    
    // Both are lvalues:
    cout << "Address of x: " << &x << endl;    // Modifiable lvalue
    cout << "Address of y: " << &y << endl;    // Non-modifiable lvalue
    
    return 0;
}
```

### 3. Rvalues
**What is an Rvalue?**
An rvalue is an expression that:
- Is temporary (exists only in expression)
- Does not have a persistent identity
- Cannot have its address taken (usually)
- Can only appear on the right side of the assignment

```
┌─────────────────────────────────────────────────────────────────┐
│                      RVALUE PROPERTIES                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ✓ Temporary value                                              │
│  ✓ No persistent identity (usually no name)                     │
│  ✗ Cannot take address with & (usually)                         │
│  ✗ Cannot appear on left side of =                              │
│  ✓ Can bind to rvalue reference (T&&)                           │
│  ✓ Can bind to const lvalue reference (const T&)                │
│  ✓ CAN BE MOVED FROM (key for move semantics!)                  │
│                                                                 │
│  MEMORY VISUALIZATION:                                          │
│  ─────────────────────                                          │
│                                                                 │
│      x + y    (where x=10, y=20)                                │
│                                                                 │
│      ┌──────────────────────────────────┐                       │
│      │      TEMPORARY REGISTER/STACK    │                       │
│      ├──────────────────────────────────┤                       │
│      │ Value: 30                        │ ◄── RVALUE            │
│      │ Lifetime: this expression only   │     No identity       │
│      │ Address: ??? (not accessible)    │     Temporary         │
│      └──────────────────────────────────┘     Can move from     │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**Rvalue Examples**
``` cpp
#include <iostream>
#include <string>
#include <vector>
using namespace std;

int getValue() { return 42; }
string getString() { return "hello"; }
vector<int> getVector() { return {1, 2, 3}; }

int main() {
    int x = 10;
    int y = 20;
    
    // ═══════════════════════════════════════════════════════════
    // LITERALS (except string literals) - Rvalues
    // ═══════════════════════════════════════════════════════════
    
    42;                      // rvalue: integer literal
    3.14;                    // rvalue: floating literal
    'a';                     // rvalue: character literal
    true;                    // rvalue: boolean literal
    nullptr;                 // rvalue: null pointer literal
    
    // &42;                  // ✗ ERROR: cannot take address of rvalue
    // 42 = x;               // ✗ ERROR: cannot assign to rvalue
    
    // ═══════════════════════════════════════════════════════════
    // ARITHMETIC/LOGICAL EXPRESSIONS - Rvalues
    // ═══════════════════════════════════════════════════════════
    
    x + y;                   // rvalue: result of addition
    x - y;                   // rvalue: result of subtraction
    x * y;                   // rvalue: result of multiplication
    x / y;                   // rvalue: result of division
    x % y;                   // rvalue: result of modulo
    x & y;                   // rvalue: result of bitwise AND
    x | y;                   // rvalue: result of bitwise OR
    x < y;                   // rvalue: result of comparison
    x && y;                  // rvalue: result of logical AND
    !x;                      // rvalue: result of logical NOT
    -x;                      // rvalue: result of unary minus
    +x;                      // rvalue: result of unary plus
    
    // &(x + y);             // ✗ ERROR: cannot take address
    // (x + y) = 30;         // ✗ ERROR: cannot assign to rvalue
    
    // ═══════════════════════════════════════════════════════════
    // FUNCTION CALLS RETURNING BY VALUE - Rvalues
    // ═══════════════════════════════════════════════════════════
    
    getValue();              // rvalue: function returning int
    getString();             // rvalue: function returning string
    getVector();             // rvalue: function returning vector
    
    // &getValue();          // ✗ ERROR: cannot take address
    // getValue() = 10;      // ✗ ERROR: cannot assign
    
    // ═══════════════════════════════════════════════════════════
    // POST-INCREMENT/DECREMENT - Rvalues
    // ═══════════════════════════════════════════════════════════
    
    x++;                     // rvalue: returns COPY of old value
    y--;                     // rvalue: returns COPY of old value
    
    // &(x++);               // ✗ ERROR: cannot take address
    // (x++) = 10;           // ✗ ERROR: cannot assign
    
    // Compare with pre-increment (lvalue):
    // &(++x);               // ✓ OK: ++x is lvalue
    
    // ═══════════════════════════════════════════════════════════
    // TEMPORARY OBJECTS - Rvalues
    // ═══════════════════════════════════════════════════════════
    
    int(42);                 // rvalue: temporary int
    string("hello");         // rvalue: temporary string
    vector<int>{1,2,3};      // rvalue: temporary vector
    MyClass();               // rvalue: temporary object (if MyClass exists)
    
    // ═══════════════════════════════════════════════════════════
    // CASTS TO NON-REFERENCE TYPES - Rvalues
    // ═══════════════════════════════════════════════════════════
    
    static_cast<int>(3.14);  // rvalue
    (int)3.14;               // rvalue: C-style cast
    int(3.14);               // rvalue: functional cast
    
    // ═══════════════════════════════════════════════════════════
    // LAMBDA EXPRESSIONS - Rvalues
    // ═══════════════════════════════════════════════════════════
    
    []{ return 42; };        // rvalue: lambda is temporary
    [](int a){ return a*2; };// rvalue
    
    // ═══════════════════════════════════════════════════════════
    // this POINTER - Rvalue
    // ═══════════════════════════════════════════════════════════
    
    // Inside a member function:
    // this;                 // rvalue (but *this is lvalue!)
    
    // ═══════════════════════════════════════════════════════════
    // ENUMERATOR - Rvalue
    // ═══════════════════════════════════════════════════════════
    
    enum Color { Red, Green, Blue };
    Red;                     // rvalue
    
    return 0;
}
```

**Why Rvalues Matter**
``` CPP
#include <iostream>
#include <string>
#include <utility>
using namespace std;

class HeavyObject {
    int* data;
    size_t size;

public:
    HeavyObject(size_t s) : size(s), data(new int[s]) {
        cout << "Constructor: allocated " << size << " ints" << endl;
    }

    // Copy constructor (expensive)
    HeavyObject(const HeavyObject& other) : size(other.size), data(new int[other.size]) {
        for (size_t i = 0; i < size; i++) {
            data[i] = other.data[i];
        }
        cout << "Copy Constructor: copied " << size << " ints (EXPENSIVE)" << endl;
    }

    // Move constructor (cheap)
    HeavyObject(HeavyObject&& other) noexcept : size(other.size), data(other.data) {
        other.data = nullptr;
        other.size = 0;
        cout << "Move Constructor: stolen pointer (CHEAP)" << endl;
    }

    ~HeavyObject() {
        delete[] data;
    }
};

HeavyObject createObject() {
    return HeavyObject(1000000);  // Returns rvalue
}

int main() {
    cout << "=== Copying from lvalue ===" << endl;
    HeavyObject obj1(1000000);
    HeavyObject obj2 = obj1;      // obj1 is LVALUE → Copy constructor
    
    cout << "\n=== Moving from rvalue ===" << endl;
    HeavyObject obj3 = createObject();  // createObject() returns RVALUE → Move
    
    cout << "\n=== Forcing move with std::move ===" << endl;
    HeavyObject obj4 = std::move(obj1); // std::move makes it RVALUE → Move
    
    return 0;
}
```

**Output:**

```text

=== Copying from lvalue ===
Constructor: allocated 1000000 ints
Copy Constructor: copied 1000000 ints (EXPENSIVE)

=== Moving from rvalue ===
Constructor: allocated 1000000 ints
Move Constructor: stolen pointer (CHEAP)

=== Forcing move with std::move ===
Move Constructor: stolen pointer (CHEAP)

```

### 4. Extended Value Categories (C++11)
**The Complete Picture**
``` 
┌─────────────────────────────────────────────────────────────────┐
│              C++11 EXTENDED VALUE CATEGORIES                    │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│                       expression                                │
│                           │                                     │
│              ┌────────────┴────────────┐                        │
│              │                         │                        │
│           glvalue                   rvalue                      │
│     (generalized lvalue)     (can be moved from)                │
│              │                         │                        │
│        ┌─────┴─────┐             ┌─────┴─────┐                  │
│        │           │             │           │                  │
│     lvalue      xvalue        xvalue      prvalue               │
│                    │             │                              │
│                    └──────┬──────┘                              │
│                           │                                     │
│                    xvalue is BOTH                               │
│                   glvalue AND rvalue                            │
│                                                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  PROPERTIES:                                                    │
│  ───────────                                                    │
│                         │ Has Identity │ Can Move From │        │
│  ───────────────────────┼──────────────┼───────────────│        │
│  lvalue                 │     YES      │      NO       │        │
│  xvalue                 │     YES      │     YES       │        │
│  prvalue                │      NO      │     YES       │        │
│  ───────────────────────┼──────────────┼───────────────│        │
│  glvalue (l + x)        │     YES      │    maybe      │        │
│  rvalue  (x + pr)       │    maybe     │     YES       │        │
│                                                                 │
│  SIMPLE RULE:                                                   │
│  • glvalue = has identity                                       │
│  • rvalue = can be moved from                                   │
│  • xvalue = both (eXpiring value)                               │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**Detailed Breakdown**
``` CPP
#include <iostream>
#include <string>
#include <utility>
using namespace std;

string createString() { return "hello"; }
string& getStringRef(string& s) { return s; }
string&& getStringRvalueRef(string& s) { return std::move(s); }

int main() {
    string s = "world";
    
    // ═══════════════════════════════════════════════════════════
    // LVALUE: Has identity, cannot be moved from implicitly
    // ═══════════════════════════════════════════════════════════
    
    s;                       // lvalue: named variable
    getStringRef(s);         // lvalue: function returning lvalue ref
    
    // Properties:
    // - Has identity: YES (has name 's')
    // - Can move from: NO (unless explicitly with std::move)
    // - Can take address: YES
    
    // ═══════════════════════════════════════════════════════════
    // PRVALUE (Pure Rvalue): No identity, can be moved from
    // ═══════════════════════════════════════════════════════════
    
    42;                      // prvalue: literal
    s + "!";                 // prvalue: temporary from concatenation
    createString();          // prvalue: function returning by value
    string("temp");          // prvalue: temporary object
    
    // Properties:
    // - Has identity: NO (no name, no address)
    // - Can move from: YES
    // - Can take address: NO
    
    // ═══════════════════════════════════════════════════════════
    // XVALUE (eXpiring Value): Has identity AND can be moved from
    // ═══════════════════════════════════════════════════════════
    
    std::move(s);            // xvalue: result of std::move
    getStringRvalueRef(s);   // xvalue: function returning rvalue ref
    static_cast<string&&>(s);// xvalue: cast to rvalue reference
    
    // Properties:
    // - Has identity: YES (refers to existing object)
    // - Can move from: YES (that's the point!)
    // - Can take address: technically yes (of the referred object)
    
    // ═══════════════════════════════════════════════════════════
    // GLVALUE (Generalized Lvalue): lvalue OR xvalue
    // ═══════════════════════════════════════════════════════════
    
    // glvalue = anything with identity
    s;                       // glvalue (lvalue)
    std::move(s);            // glvalue (xvalue)
    
    // ═══════════════════════════════════════════════════════════
    // RVALUE: prvalue OR xvalue
    // ═══════════════════════════════════════════════════════════
    
    // rvalue = anything that can be moved from
    42;                      // rvalue (prvalue)
    std::move(s);            // rvalue (xvalue)
    
    return 0;
}
```
**Visual: Value Category Examples**

``` 
═══════════════════════════════════════════════════════════════════
                    VALUE CATEGORY EXAMPLES
═══════════════════════════════════════════════════════════════════

    EXPRESSION                      CATEGORY    IDENTITY  MOVEABLE
    ──────────                      ────────    ────────  ────────
    
    int x = 10;
    x                               lvalue       YES       NO*
    
    x + 1                           prvalue      NO        YES
    
    std::move(x)                    xvalue       YES       YES
    
    42                              prvalue      NO        YES
    
    "hello"                         lvalue       YES       NO
    
    int& r = x;
    r                               lvalue       YES       NO*
    
    int&& rr = 42;
    rr                              lvalue!      YES       NO*
    (The NAME rr is an lvalue, even though it's an rvalue reference)
    
    std::move(rr)                   xvalue       YES       YES
    
    
    * Can be moved with explicit std::move()

═══════════════════════════════════════════════════════════════════

    FUNCTION RETURN TYPES:
    ──────────────────────
    
    int getValue();                 → prvalue
    int& getRef();                  → lvalue
    int&& getRvalueRef();           → xvalue
    const int& getConstRef();       → lvalue

═══════════════════════════════════════════════════════════════════
```
**Value Category Test**
``` CPP
#include <iostream>
#include <type_traits>
using namespace std;

// Helper to determine value category
template<typename T>
struct value_category {
    static constexpr const char* value = "prvalue";
};

template<typename T>
struct value_category<T&> {
    static constexpr const char* value = "lvalue";
};

template<typename T>
struct value_category<T&&> {
    static constexpr const char* value = "xvalue";
};

// Macro to test and print value category
#define VALUE_CATEGORY(expr) \
    value_category<decltype((expr))>::value

int getInt() { return 42; }
int& getIntRef() { static int x = 10; return x; }
int&& getIntRvalueRef() { static int x = 20; return std::move(x); }

int main() {
    int x = 10;
    int& ref = x;
    int&& rref = 42;
    
    cout << "Value Categories:" << endl;
    cout << "─────────────────" << endl;
    
    cout << "x:                " << VALUE_CATEGORY(x) << endl;
    cout << "42:               " << VALUE_CATEGORY(42) << endl;
    cout << "x + 1:            " << VALUE_CATEGORY(x + 1) << endl;
    cout << "std::move(x):     " << VALUE_CATEGORY(std::move(x)) << endl;
    cout << "ref:              " << VALUE_CATEGORY(ref) << endl;
    cout << "rref:             " << VALUE_CATEGORY(rref) << endl;
    cout << "std::move(rref):  " << VALUE_CATEGORY(std::move(rref)) << endl;
    cout << "getInt():         " << VALUE_CATEGORY(getInt()) << endl;
    cout << "getIntRef():      " << VALUE_CATEGORY(getIntRef()) << endl;
    cout << "getIntRvalueRef():" << VALUE_CATEGORY(getIntRvalueRef()) << endl;
    cout << "++x:              " << VALUE_CATEGORY(++x) << endl;
    cout << "x++:              " << VALUE_CATEGORY(x++) << endl;
    
    return 0;
}
```

**Output:**

```text

Value Categories:
─────────────────
x:                lvalue
42:               prvalue
x + 1:            prvalue
std::move(x):     xvalue
ref:              lvalue
rref:             lvalue
std::move(rref):  xvalue
getInt():         prvalue
getIntRef():      lvalue
getIntRvalueRef():xvalue
++x:              lvalue
x++:              prvalue
```

### 5. Lvalue References
**What is an Lvalue Reference?**
An lvalue reference (T&) is an alias for an existing object. It must be initialized and cannot be reseated.

``` 
┌─────────────────────────────────────────────────────────────────┐
│                    LVALUE REFERENCE                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  SYNTAX: T& ref = lvalue;                                       │
│                                                                 │
│  BINDING RULES:                                                 │
│  ──────────────                                                 │
│  T&        → binds to: modifiable lvalue of type T              │
│  const T&  → binds to: any lvalue or rvalue of type T           │
│                                                                 │
│  PROPERTIES:                                                    │
│  ───────────                                                    │
│  • Must be initialized at declaration                           │
│  • Cannot be null (unlike pointers)                             │
│  • Cannot be reseated (always refers to same object)            │
│  • Reference is the object (not a separate entity)              │
│                                                                 │
│  MEMORY MODEL:                                                  │
│  ─────────────                                                  │
│                                                                 │
│      int x = 42;                                                │
│      int& ref = x;                                              │
│                                                                 │
│      ┌─────────────────────────────────────┐                    │
│      │            MEMORY                   │                    │
│      ├─────────────────────────────────────┤                    │
│      │ Address: 0x1000                     │                    │
│      │ Names: x, ref (SAME location)       │                    │
│      │ Value: 42                           │                    │
│      └─────────────────────────────────────┘                    │
│                                                                 │
│      ref IS x, just another name for the same memory            │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```
**Lvalue Reference Examples**

``` CPP
#include <iostream>
#include <string>
using namespace std;

void modifyByRef(int& x) {
    x *= 2;
}

void printByConstRef(const string& s) {
    cout << s << endl;
}

int main() {
    // ═══════════════════════════════════════════════════════════
    // BASIC LVALUE REFERENCE
    // ═══════════════════════════════════════════════════════════
    
    int x = 10;
    int& ref = x;           // ref is alias for x
    
    cout << "x = " << x << ", ref = " << ref << endl;
    
    ref = 20;               // Modifies x through ref
    cout << "After ref = 20: x = " << x << endl;
    
    x = 30;                 // Modifies x directly
    cout << "After x = 30: ref = " << ref << endl;
    
    cout << "Address of x:   " << &x << endl;
    cout << "Address of ref: " << &ref << endl;  // Same address!
    
    // ═══════════════════════════════════════════════════════════
    // LVALUE REFERENCE BINDING RULES
    // ═══════════════════════════════════════════════════════════
    
    int a = 10;
    
    // T& binds to modifiable lvalue
    int& ref1 = a;          // ✓ OK: a is modifiable lvalue
    
    // int& ref2 = 42;      // ✗ ERROR: 42 is rvalue
    // int& ref3 = a + 1;   // ✗ ERROR: a + 1 is rvalue
    
    // const T& binds to anything!
    const int& cref1 = a;       // ✓ OK: lvalue
    const int& cref2 = 42;      // ✓ OK: rvalue (lifetime extended!)
    const int& cref3 = a + 1;   // ✓ OK: rvalue (lifetime extended!)
    
    cout << "\ncref2 = " << cref2 << endl;  // 42
    cout << "cref3 = " << cref3 << endl;    // 11
    
    // ═══════════════════════════════════════════════════════════
    // REFERENCES IN FUNCTION PARAMETERS
    // ═══════════════════════════════════════════════════════════
    
    int value = 5;
    cout << "\nBefore modifyByRef: " << value << endl;
    modifyByRef(value);
    cout << "After modifyByRef: " << value << endl;
    
    // modifyByRef(10);     // ✗ ERROR: cannot bind non-const ref to rvalue
    
    printByConstRef("Hello");   // ✓ OK: const ref can bind to rvalue
    printByConstRef(string("World")); // ✓ OK
    
    // ═══════════════════════════════════════════════════════════
    // REFERENCES CANNOT BE RESEATED
    // ═══════════════════════════════════════════════════════════
    
    int y = 100;
    int& refX = x;
    
    refX = y;               // This COPIES y's value to x!
                            // refX still refers to x, not y
    
    cout << "\nAfter refX = y:" << endl;
    cout << "x = " << x << ", y = " << y << ", refX = " << refX << endl;
    cout << "&x = " << &x << ", &refX = " << &refX << endl;  // Still same!
    
    // ═══════════════════════════════════════════════════════════
    // REFERENCE TO REFERENCE (not possible directly)
    // ═══════════════════════════════════════════════════════════
    
    int& ref2 = ref1;       // ref2 refers to 'a', not to ref1
                            // There's no "reference to reference"
    
    return 0;
}
```

**const Lvalue Reference - Special Case**

``` CPP
#include <iostream>
using namespace std;

class Heavy {
public:
    Heavy() { cout << "Heavy constructed" << endl; }
    ~Heavy() { cout << "Heavy destroyed" << endl; }
    Heavy(const Heavy&) { cout << "Heavy copied" << endl; }
};

Heavy createHeavy() {
    return Heavy();
}

int main() {
    cout << "=== Const reference extends lifetime ===" << endl;
    
    {
        // const reference can bind to rvalue and EXTENDS its lifetime!
        const Heavy& ref = createHeavy();
        cout << "Using ref..." << endl;
        // Heavy object lives until ref goes out of scope
    }
    cout << "After block" << endl;
    
    cout << "\n=== Without const reference ===" << endl;
    
    {
        // Heavy& ref = createHeavy();  // ERROR: can't bind to rvalue
        
        Heavy obj = createHeavy();  // Creates and possibly copies
        cout << "Using obj..." << endl;
    }
    cout << "After block" << endl;
    
    return 0;
}
```

**Output:**

```text

=== Const reference extends lifetime ===
Heavy constructed
Using ref...
Heavy destroyed
After block

=== Without const reference ===
Heavy constructed
Using obj...
Heavy destroyed
After block
```
### 6. Rvalue References
**What is an Rvalue Reference?**
An rvalue reference (T&&) is a reference that binds to rvalues. It enables move semantics and perfect forwarding.

```
┌─────────────────────────────────────────────────────────────────┐
│                    RVALUE REFERENCE                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  SYNTAX: T&& ref = rvalue;                                      │
│                                                                 │
│  BINDING RULES:                                                 │
│  ──────────────                                                 │
│  T&&        → binds to: rvalues of type T                       │
│  const T&&  → binds to: rvalues (rarely used)                   │
│                                                                 │
│  PURPOSE:                                                       │
│  ────────                                                       │
│  1. Enable MOVE SEMANTICS (steal resources from temporaries)    │
│  2. Enable PERFECT FORWARDING (preserve value category)         │
│  3. Distinguish between "can copy" and "can steal"              │
│                                                                 │
│  KEY INSIGHT:                                                   │
│  ────────────                                                   │
│  An rvalue reference VARIABLE is itself an LVALUE!              │
│  The variable has a name, so it has identity.                   │
│                                                                 │
│      int&& rref = 42;     // rref binds to rvalue 42            │
│      rref;                // But 'rref' itself is an LVALUE!    │
│      std::move(rref);     // Need this to treat as rvalue again │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**Rvalue Reference Basics:**

``` cpp
#include <iostream>
#include <string>
#include <utility>
using namespace std;

int main() {
    // ═══════════════════════════════════════════════════════════
    // BASIC RVALUE REFERENCE
    // ═══════════════════════════════════════════════════════════
    
    int&& rref = 42;            // Binds to rvalue literal
    cout << "rref = " << rref << endl;
    
    rref = 100;                 // Can modify through rvalue reference!
    cout << "After rref = 100: " << rref << endl;
    
    // ═══════════════════════════════════════════════════════════
    // RVALUE REFERENCE BINDING RULES
    // ═══════════════════════════════════════════════════════════
    
    int x = 10;
    
    // int&& rref1 = x;         // ✗ ERROR: x is lvalue
    int&& rref2 = 42;           // ✓ OK: 42 is rvalue
    int&& rref3 = x + 1;        // ✓ OK: x + 1 is rvalue
    int&& rref4 = std::move(x); // ✓ OK: std::move makes it rvalue
    
    // ═══════════════════════════════════════════════════════════
    // IMPORTANT: RVALUE REFERENCE VARIABLE IS AN LVALUE!
    // ═══════════════════════════════════════════════════════════
    
    int&& rr = 42;
    
    // rr is a NAMED variable, so it's an LVALUE
    int& ref = rr;              // ✓ OK: rr is lvalue!
    // int&& rr2 = rr;          // ✗ ERROR: rr is lvalue!
    int&& rr2 = std::move(rr);  // ✓ OK: std::move makes it rvalue
    
    cout << "\n&rr = " << &rr << endl;  // Can take address (it's lvalue)
    
    // ═══════════════════════════════════════════════════════════
    // RVALUE REFERENCE TO STRING
    // ═══════════════════════════════════════════════════════════
    
    string&& strRef = string("Hello");
    cout << "\nstrRef = " << strRef << endl;
    
    strRef += " World";         // Can modify
    cout << "After modification: " << strRef << endl;
    
    return 0;
}
```

**Move Semantics with Rvalue References:**
``` cpp
#include <iostream>
#include <cstring>
#include <utility>
using namespace std;

class String {
    char* data;
    size_t length;

public:
    // Constructor
    String(const char* str = "") {
        length = strlen(str);
        data = new char[length + 1];
        strcpy(data, str);
        cout << "Constructor: \"" << data << "\"" << endl;
    }

    // Copy Constructor (lvalue reference parameter)
    String(const String& other) {
        length = other.length;
        data = new char[length + 1];
        strcpy(data, other.data);
        cout << "Copy Constructor: \"" << data << "\" (DEEP COPY)" << endl;
    }

    // Move Constructor (rvalue reference parameter)
    String(String&& other) noexcept {
        length = other.length;
        data = other.data;          // Steal the pointer!
        other.data = nullptr;       // Leave source in valid state
        other.length = 0;
        cout << "Move Constructor: \"" << data << "\" (POINTER STEAL)" << endl;
    }

    // Copy Assignment
    String& operator=(const String& other) {
        cout << "Copy Assignment" << endl;
        if (this != &other) {
            delete[] data;
            length = other.length;
            data = new char[length + 1];
            strcpy(data, other.data);
        }
        return *this;
    }

    // Move Assignment
    String& operator=(String&& other) noexcept {
        cout << "Move Assignment" << endl;
        if (this != &other) {
            delete[] data;
            data = other.data;
            length = other.length;
            other.data = nullptr;
            other.length = 0;
        }
        return *this;
    }

    ~String() {
        cout << "Destructor: \"" << (data ? data : "null") << "\"" << endl;
        delete[] data;
    }

    const char* c_str() const { return data ? data : ""; }
};

String createString() {
    return String("Created");
}

int main() {
    cout << "=== Copy from lvalue ===" << endl;
    String s1("Hello");
    String s2 = s1;           // s1 is LVALUE → Copy constructor
    
    cout << "\n=== Move from rvalue ===" << endl;
    String s3 = String("World");  // Temporary is RVALUE → Move constructor
    
    cout << "\n=== Move from function return ===" << endl;
    String s4 = createString();   // Return value is RVALUE → Move
    
    cout << "\n=== Explicit move with std::move ===" << endl;
    String s5 = std::move(s1);    // std::move makes RVALUE → Move
    cout << "s1 after move: \"" << s1.c_str() << "\"" << endl;
    
    cout << "\n=== Assignment ===" << endl;
    s2 = s3;                      // Copy assignment (s3 is lvalue)
    s2 = String("Temp");          // Move assignment (temporary is rvalue)
    
    cout << "\n=== Cleanup ===" << endl;
    return 0;
}
```

**Function Overloading with References:**
``` cpp
#include <iostream>
#include <string>
using namespace std;

class Processor {
public:
    // Overload 1: Takes lvalue reference
    void process(const string& s) {
        cout << "process(const string&): Copying \"" << s << "\"" << endl;
    }

    // Overload 2: Takes rvalue reference
    void process(string&& s) {
        cout << "process(string&&): Moving \"" << s << "\"" << endl;
        // Can safely modify/move from s
    }
};

int main() {
    Processor proc;
    
    string s = "Hello";
    
    cout << "=== Calling with lvalue ===" << endl;
    proc.process(s);              // Calls const string& version
    
    cout << "\n=== Calling with rvalue ===" << endl;
    proc.process(string("World")); // Calls string&& version
    proc.process("Literal");       // Calls string&& version (converts to temp string)
    
    cout << "\n=== Calling with std::move ===" << endl;
    proc.process(std::move(s));   // Calls string&& version
    
    cout << "\n=== s after move: \"" << s << "\"" << endl;
    
    return 0;
}
```

**Output:**

```text

=== Calling with lvalue ===
process(const string&): Copying "Hello"

=== Calling with rvalue ===
process(string&&): Moving "World"
process(string&&): Moving "Literal"

=== Calling with std::move ===
process(string&&): Moving "Hello"

=== s after move: ""
```

### 7. Reference Collapsing
**What is Reference Collapsing?**
When you have references to references (through templates or typedef), C++ collapses them according to specific rules.

``` 
┌─────────────────────────────────────────────────────────────────┐
│                 REFERENCE COLLAPSING RULES                      │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  T& &   →  T&      (lvalue ref to lvalue ref = lvalue ref)      │
│  T& &&  →  T&      (rvalue ref to lvalue ref = lvalue ref)      │
│  T&& &  →  T&      (lvalue ref to rvalue ref = lvalue ref)      │
│  T&& && →  T&&     (rvalue ref to rvalue ref = rvalue ref)      │
│                                                                 │
│  SIMPLE RULE:                                                   │
│  ────────────                                                   │
│  If EITHER reference is lvalue reference (&), result is &       │
│  Only if BOTH are rvalue references (&&), result is &&          │
│                                                                 │
│  VISUAL:                                                        │
│                                                                 │
│       &  + &  = &                                               │
│       &  + && = &                                               │
│       && + &  = &                                               │
│       && + && = &&                                              │
│                                                                 │
│  Think of & as "sticky" - it always wins!                       │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**Reference Collapsing in Action**

``` cpp
#include <iostream>
#include <type_traits>
using namespace std;

// Helper to print type
template<typename T>
void printType() {
    if constexpr (is_lvalue_reference_v<T>) {
        cout << "lvalue reference (&)" << endl;
    } else if constexpr (is_rvalue_reference_v<T>) {
        cout << "rvalue reference (&&)" << endl;
    } else {
        cout << "not a reference" << endl;
    }
}

template<typename T>
void demonstrateCollapsing() {
    using LRef = T&;
    using RRef = T&&;
    
    cout << "T = ";
    if constexpr (is_lvalue_reference_v<T>) {
        cout << "U&" << endl;
    } else if constexpr (is_rvalue_reference_v<T>) {
        cout << "U&&" << endl;
    } else {
        cout << "U (no reference)" << endl;
    }
    
    cout << "  T&  = "; printType<LRef>();
    cout << "  T&& = "; printType<RRef>();
    cout << endl;
}

int main() {
    cout << "=== Reference Collapsing Rules ===" << endl << endl;
    
    cout << "When T is plain type (int):" << endl;
    demonstrateCollapsing<int>();
    
    cout << "When T is lvalue reference (int&):" << endl;
    demonstrateCollapsing<int&>();
    
    cout << "When T is rvalue reference (int&&):" << endl;
    demonstrateCollapsing<int&&>();
    
    return 0;
}
```

**Output:**

```text

=== Reference Collapsing Rules ===

When T is plain type (int):
T = U (no reference)
  T&  = lvalue reference (&)
  T&& = rvalue reference (&&)

When T is lvalue reference (int&):
T = U&
  T&  = lvalue reference (&)
  T&& = lvalue reference (&)

When T is rvalue reference (int&&):
T = U&&
  T&  = lvalue reference (&)
  T&& = rvalue reference (&&)
```  

**Forwarding References (Universal References)**

``` cpp
#include <iostream>
#include <type_traits>
using namespace std;

// T&& in template context is a FORWARDING REFERENCE (Universal Reference)
// NOT a regular rvalue reference!

template<typename T>
void forwardingRef(T&& arg) {
    cout << "T = ";
    if constexpr (is_lvalue_reference_v<T>) {
        cout << "deduced as lvalue reference" << endl;
    } else {
        cout << "deduced as non-reference" << endl;
    }
    
    cout << "arg is ";
    if constexpr (is_lvalue_reference_v<decltype(arg)>) {
        cout << "lvalue reference" << endl;
    } else {
        cout << "rvalue reference" << endl;
    }
}

// This is a REGULAR rvalue reference (not forwarding)
void regularRvalueRef(int&& arg) {
    cout << "regularRvalueRef called" << endl;
}

int main() {
    int x = 10;
    
    cout << "=== Forwarding Reference ===" << endl;
    
    cout << "\nCalling with lvalue (x):" << endl;
    forwardingRef(x);        // T deduced as int&, arg is int& (T& && = T&)
    
    cout << "\nCalling with rvalue (42):" << endl;
    forwardingRef(42);       // T deduced as int, arg is int&& (T&&)
    
    cout << "\nCalling with std::move(x):" << endl;
    forwardingRef(std::move(x)); // T deduced as int, arg is int&&
    
    cout << "\n=== Regular Rvalue Reference ===" << endl;
    
    // regularRvalueRef(x);  // ERROR: cannot bind lvalue to rvalue ref
    regularRvalueRef(42);    // OK: 42 is rvalue
    regularRvalueRef(std::move(x)); // OK: std::move makes it rvalue
    
    return 0;
}
```

**Output:**

```text

=== Forwarding Reference ===

Calling with lvalue (x):
T = deduced as lvalue reference
arg is lvalue reference

Calling with rvalue (42):
T = deduced as non-reference
arg is rvalue reference

Calling with std::move(x):
T = deduced as non-reference
arg is rvalue reference

=== Regular Rvalue Reference ===
regularRvalueRef called
regularRvalueRef called
```
**Visual: Forwarding Reference Deduction**

```
═══════════════════════════════════════════════════════════════════
              FORWARDING REFERENCE DEDUCTION
═══════════════════════════════════════════════════════════════════

    template<typename T>
    void func(T&& arg);

    ═══════════════════════════════════════════════════════════════
    
    CALLED WITH LVALUE:
    ───────────────────
    
    int x = 10;
    func(x);
    
    Step 1: x is lvalue
    Step 2: T deduced as int& (lvalue reference)
    Step 3: T&& = int& && = int& (reference collapsing)
    
    Result: func(int& arg)  ← arg is lvalue reference
    
    ═══════════════════════════════════════════════════════════════
    
    CALLED WITH RVALUE:
    ───────────────────
    
    func(42);
    
    Step 1: 42 is rvalue
    Step 2: T deduced as int (no reference)
    Step 3: T&& = int&& (no collapsing needed)
    
    Result: func(int&& arg)  ← arg is rvalue reference
    
    ═══════════════════════════════════════════════════════════════
    
    CALLED WITH std::move(x):
    ─────────────────────────
    
    func(std::move(x));
    
    Step 1: std::move(x) is xvalue (rvalue)
    Step 2: T deduced as int (no reference)
    Step 3: T&& = int&&
    
    Result: func(int&& arg)  ← arg is rvalue reference

═══════════════════════════════════════════════════════════════════
```

### 8. std::move and std::forward
**std::move - Cast to Rvalue**

``` cpp
#include <iostream>
#include <utility>
#include <type_traits>
using namespace std;

// Simplified implementation of std::move
template<typename T>
constexpr remove_reference_t<T>&& my_move(T&& t) noexcept {
    return static_cast<remove_reference_t<T>&&>(t);
}

int main() {
    cout << "=== std::move Explained ===" << endl;
    
    int x = 42;
    
    // std::move doesn't actually MOVE anything!
    // It just CASTS to rvalue reference
    
    cout << "\nBefore move:" << endl;
    cout << "x = " << x << endl;
    cout << "x is lvalue: " << is_lvalue_reference_v<decltype((x))> << endl;
    
    // This is what std::move does:
    auto&& moved = std::move(x);
    
    cout << "\nAfter std::move(x):" << endl;
    cout << "x = " << x << endl;  // x is UNCHANGED!
    cout << "moved = " << moved << endl;
    cout << "std::move(x) is rvalue: " << is_rvalue_reference_v<decltype(std::move(x))> << endl;
    
    // The actual move happens when you USE the result
    string s1 = "Hello";
    cout << "\ns1 before: \"" << s1 << "\"" << endl;
    
    string s2 = std::move(s1);  // Move constructor called
    cout << "s1 after: \"" << s1 << "\" (moved-from state)" << endl;
    cout << "s2 after: \"" << s2 << "\"" << endl;
    
    return 0;
}
```
**std::forward - Perfect Forwarding**

``` cpp
#include <iostream>
#include <utility>
#include <string>
using namespace std;

// Target functions
void process(const string& s) {
    cout << "  process(const string&): lvalue \"" << s << "\"" << endl;
}

void process(string&& s) {
    cout << "  process(string&&): rvalue \"" << s << "\"" << endl;
}

// WITHOUT std::forward - Always calls lvalue version!
template<typename T>
void wrapperBad(T&& arg) {
    cout << "wrapperBad: ";
    process(arg);  // arg is always lvalue (it has a name!)
}

// WITH std::forward - Preserves value category!
template<typename T>
void wrapperGood(T&& arg) {
    cout << "wrapperGood: ";
    process(std::forward<T>(arg));  // Forwards as lvalue or rvalue
}

int main() {
    string s = "Hello";
    
    cout << "=== Without std::forward (BAD) ===" << endl;
    wrapperBad(s);              // Should call lvalue version ✓
    wrapperBad(string("World")); // Should call rvalue version ✗ (calls lvalue!)
    
    cout << "\n=== With std::forward (GOOD) ===" << endl;
    wrapperGood(s);              // Calls lvalue version ✓
    wrapperGood(string("World")); // Calls rvalue version ✓
    
    cout << "\n=== With std::move ===" << endl;
    wrapperGood(std::move(s));   // Calls rvalue version ✓
    
    return 0;
}
```

**Output:**

```text

=== Without std::forward (BAD) ===
wrapperBad:   process(const string&): lvalue "Hello"
wrapperBad:   process(const string&): lvalue "World"

=== With std::forward (GOOD) ===
wrapperGood:   process(const string&): lvalue "Hello"
wrapperGood:   process(string&&): rvalue "World"

=== With std::move ===
wrapperGood:   process(string&&): rvalue "Hello"
```

**How std::forward Works**

``` cpp
#include <iostream>
#include <type_traits>
using namespace std;

// Simplified std::forward implementation
template<typename T>
constexpr T&& my_forward(remove_reference_t<T>& t) noexcept {
    return static_cast<T&&>(t);
}

template<typename T>
constexpr T&& my_forward(remove_reference_t<T>&& t) noexcept {
    static_assert(!is_lvalue_reference_v<T>, "Cannot forward rvalue as lvalue");
    return static_cast<T&&>(t);
}

/*
═══════════════════════════════════════════════════════════════════
                   HOW std::forward WORKS
═══════════════════════════════════════════════════════════════════

When called with LVALUE:
────────────────────────
    template<typename T>  // T = int&
    void wrapper(T&& arg) {
        target(std::forward<T>(arg));  // std::forward<int&>(arg)
    }
    
    std::forward<int&>(arg) returns:
        static_cast<int& &&>(arg) = static_cast<int&>(arg)
        → lvalue reference (passed to lvalue overload)

When called with RVALUE:
────────────────────────
    template<typename T>  // T = int
    void wrapper(T&& arg) {
        target(std::forward<T>(arg));  // std::forward<int>(arg)
    }
    
    std::forward<int>(arg) returns:
        static_cast<int&&>(arg)
        → rvalue reference (passed to rvalue overload)

═══════════════════════════════════════════════════════════════════
*/

void targetFunc(int& x) { cout << "lvalue: " << x << endl; }
void targetFunc(int&& x) { cout << "rvalue: " << x << endl; }

template<typename T>
void forwardDemo(T&& arg) {
    cout << "  Without forward: "; targetFunc(arg);
    cout << "  With forward:    "; targetFunc(std::forward<T>(arg));
}

int main() {
    int x = 42;
    
    cout << "Passing lvalue:" << endl;
    forwardDemo(x);
    
    cout << "\nPassing rvalue:" << endl;
    forwardDemo(100);
    
    return 0;
}
```

**Visual: std::move vs std::forward**
```
═══════════════════════════════════════════════════════════════════
                std::move vs std::forward
═══════════════════════════════════════════════════════════════════

    std::move(x)                    std::forward<T>(x)
    ────────────                    ──────────────────
    
    ALWAYS casts to rvalue          CONDITIONALLY casts based on T
    
    ┌──────────┐                    ┌──────────┐
    │  lvalue  │                    │  lvalue  │
    │    x     │                    │    x     │
    └────┬─────┘                    └────┬─────┘
         │                               │
         ▼                        T=U&   │   T=U
    ┌──────────┐               ┌────────┴────────┐
    │  rvalue  │               │                 │
    │   (x)    │               ▼                 ▼
    └──────────┘          ┌──────────┐     ┌──────────┐
                          │  lvalue  │     │  rvalue  │
    USE: When you KNOW    │   (x)    │     │   (x)    │
    you want to move      └──────────┘     └──────────┘
    
                          USE: In templates to preserve
                          original value category

═══════════════════════════════════════════════════════════════════

    RULE OF THUMB:
    ──────────────
    • std::move: Use when you OWN the object and want to transfer
    • std::forward: Use in templates to forward arguments
    
    DON'T:
    ──────
    • Don't use std::move on return values (prevents RVO)
    • Don't use std::move on const objects (will copy anyway)
    • Don't use std::forward outside template forwarding context

═══════════════════════════════════════════════════════════════════
```

### 9. Practical Applications
**Perfect Forwarding Factory**

``` cpp
#include <iostream>
#include <memory>
#include <utility>
using namespace std;

class Widget {
    int id;
    string name;
    double value;

public:
    // Multiple constructors
    Widget() : id(0), name("default"), value(0.0) {
        cout << "Default constructor" << endl;
    }

    Widget(int i) : id(i), name("id-only"), value(0.0) {
        cout << "Int constructor: " << id << endl;
    }

    Widget(int i, string n) : id(i), name(std::move(n)), value(0.0) {
        cout << "Int+String constructor: " << id << ", " << name << endl;
    }

    Widget(int i, string n, double v) : id(i), name(std::move(n)), value(v) {
        cout << "Full constructor: " << id << ", " << name << ", " << value << endl;
    }

    void print() const {
        cout << "Widget(" << id << ", " << name << ", " << value << ")" << endl;
    }
};

// Perfect forwarding factory function
template<typename T, typename... Args>
unique_ptr<T> makeObject(Args&&... args) {
    return make_unique<T>(std::forward<Args>(args)...);
}

// Emplacement wrapper
template<typename Container, typename... Args>
void emplaceBack(Container& c, Args&&... args) {
    c.emplace_back(std::forward<Args>(args)...);
}

int main() {
    cout << "=== Using makeObject factory ===" << endl;
    
    auto w1 = makeObject<Widget>();
    auto w2 = makeObject<Widget>(42);
    auto w3 = makeObject<Widget>(100, "test");
    auto w4 = makeObject<Widget>(200, string("named"), 3.14);
    
    cout << "\n=== Widgets created ===" << endl;
    w1->print();
    w2->print();
    w3->print();
    w4->print();
    
    cout << "\n=== Using emplaceBack ===" << endl;
    vector<Widget> widgets;
    widgets.reserve(3);
    
    emplaceBack(widgets, 1, "first", 1.1);
    emplaceBack(widgets, 2, "second", 2.2);
    emplaceBack(widgets, 3, "third", 3.3);
    
    return 0;
}
```

**Efficient String Builder**

``` cpp
#include <iostream>
#include <string>
#include <vector>
#include <utility>
using namespace std;

class StringBuilder {
    vector<string> parts;

public:
    // Accept both lvalues and rvalues efficiently
    template<typename T>
    StringBuilder& append(T&& str) {
        parts.push_back(std::forward<T>(str));
        return *this;
    }

    // Multiple arguments
    template<typename T, typename... Args>
    StringBuilder& append(T&& first, Args&&... rest) {
        append(std::forward<T>(first));
        return append(std::forward<Args>(rest)...);
    }

    string build() const {
        size_t totalSize = 0;
        for (const auto& s : parts) {
            totalSize += s.size();
        }

        string result;
        result.reserve(totalSize);

        for (const auto& s : parts) {
            result += s;
        }

        return result;
    }
};

int main() {
    StringBuilder builder;
    
    string name = "World";
    
    // Mixing lvalues and rvalues
    builder.append("Hello, ")           // rvalue
           .append(name)                // lvalue (copied)
           .append("! ")                // rvalue
           .append(string("How "))      // rvalue (moved)
           .append("are you?");         // rvalue
    
    cout << builder.build() << endl;
    
    // Using variadic append
    StringBuilder builder2;
    builder2.append("One", " Two", " Three");
    cout << builder2.build() << endl;
    
    return 0;
}
```

**Move-Only Type**

``` cpp
#include <iostream>
#include <memory>
#include <vector>
#include <utility>
using namespace std;

// Resource that can only be moved, not copied
class UniqueResource {
    int* data;
    string name;

public:
    UniqueResource(const string& n, int value)
        : data(new int(value)), name(n) {
        cout << "Created: " << name << " = " << *data << endl;
    }

    // Delete copy operations
    UniqueResource(const UniqueResource&) = delete;
    UniqueResource& operator=(const UniqueResource&) = delete;

    // Move constructor
    UniqueResource(UniqueResource&& other) noexcept
        : data(other.data), name(std::move(other.name)) {
        other.data = nullptr;
        cout << "Moved: " << name << endl;
    }

    // Move assignment
    UniqueResource& operator=(UniqueResource&& other) noexcept {
        if (this != &other) {
            delete data;
            data = other.data;
            name = std::move(other.name);
            other.data = nullptr;
        }
        cout << "Move assigned: " << name << endl;
        return *this;
    }

    ~UniqueResource() {
        if (data) {
            cout << "Destroyed: " << name << endl;
        }
        delete data;
    }

    void print() const {
        cout << name << " = " << (data ? to_string(*data) : "null") << endl;
    }
};

UniqueResource createResource(const string& name, int value) {
    return UniqueResource(name, value);
}

int main() {
    cout << "=== Creating resources ===" << endl;
    UniqueResource r1("Resource1", 100);
    
    // UniqueResource r2 = r1;  // ERROR: Copy deleted
    
    cout << "\n=== Moving resource ===" << endl;
    UniqueResource r2 = std::move(r1);  // Must use std::move
    
    cout << "\n=== After move ===" << endl;
    r1.print();  // null
    r2.print();  // Resource1 = 100
    
    cout << "\n=== Vector of move-only types ===" << endl;
    vector<UniqueResource> resources;
    resources.reserve(3);
    
    // Must move into vector
    resources.push_back(UniqueResource("R1", 1));
    resources.push_back(createResource("R2", 2));
    resources.emplace_back("R3", 3);  // In-place construction
    
    cout << "\n=== Cleanup ===" << endl;
    return 0;
}
```

### 10. Best Practices
**Summary Table**

``` 
┌─────────────────────────────────────────────────────────────────┐
│                    VALUE CATEGORIES SUMMARY                     │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  EXPRESSION TYPE              VALUE CATEGORY                    │
│  ───────────────              ──────────────                    │
│  Variable name (x)            lvalue                            │
│  Dereferenced ptr (*p)        lvalue                            │
│  Array subscript (a[i])       lvalue                            │
│  Prefix ++/-- (++x)           lvalue                            │
│  Lvalue ref return (f())      lvalue                            │
│  String literal ("hi")        lvalue                            │
│  ───────────────              ──────────────                    │
│  Literal (42)                 prvalue                           │
│  Arithmetic (x + y)           prvalue                           │
│  Postfix ++/-- (x++)          prvalue                           │
│  Value return (f())           prvalue                           │
│  Temporary (Type())           prvalue                           │
│  Lambda ([](){})              prvalue                           │
│  ───────────────              ──────────────                    │
│  std::move(x)                 xvalue                            │
│  Rvalue ref return (f())      xvalue                            │
│  Cast to rvalue ref           xvalue                            │
│                                                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  REFERENCE TYPE               BINDS TO                          │
│  ──────────────               ────────                          │
│  T&                           lvalue of T only                  │
│  const T&                     lvalue or rvalue of T             │
│  T&&                          rvalue of T only                  │
│  const T&&                    rvalue of T (rare)                │
│                                                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  REFERENCE COLLAPSING:                                          │
│  T& &   = T&                                                    │
│  T& &&  = T&                                                    │
│  T&& &  = T&                                                    │
│  T&& && = T&&                                                   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**Best Practices Checklist**

``` cpp
#include <iostream>
#include <string>
#include <utility>
using namespace std;

// ═══════════════════════════════════════════════════════════════
// ✓ GOOD PRACTICES
// ═══════════════════════════════════════════════════════════════

class Good {
    string data;

public:
    // ✓ Take by value and move for sink parameters
    Good(string s) : data(std::move(s)) {}

    // ✓ Use const& for read-only access
    void display(const string& s) const {
        cout << s << endl;
    }

    // ✓ Overload for lvalue and rvalue if different handling needed
    void process(const string& s) {
        data = s;  // Copy
    }

    void process(string&& s) {
        data = std::move(s);  // Move
    }

    // ✓ Perfect forwarding in templates
    template<typename T>
    void emplace(T&& value) {
        data = std::forward<T>(value);
    }

    // ✓ noexcept for move operations
    Good(Good&& other) noexcept : data(std::move(other.data)) {}
    Good& operator=(Good&& other) noexcept {
        data = std::move(other.data);
        return *this;
    }
};

// ═══════════════════════════════════════════════════════════════
// ✗ BAD PRACTICES
// ═══════════════════════════════════════════════════════════════

class Bad {
    string data;

public:
    // ✗ Don't use std::move on return (prevents RVO)
    string getData() {
        return std::move(data);  // BAD!
        // Should be: return data;
    }

    // ✗ Don't std::move const objects (will copy anyway)
    void processConst(const string& s) {
        data = std::move(s);  // BAD! Still copies
    }

    // ✗ Don't use object after moving from it (except assign/destroy)
    void badMove() {
        string s = "hello";
        string t = std::move(s);
        cout << s.size();  // BAD! s is in unspecified state
    }
};

// ═══════════════════════════════════════════════════════════════
// WHEN TO USE WHAT
// ═══════════════════════════════════════════════════════════════

/*
┌─────────────────────────────────────────────────────────────────┐
│                    DECISION GUIDE                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  FOR FUNCTION PARAMETERS:                                       │
│  ─────────────────────────                                      │
│                                                                 │
│  Read-only access?                                              │
│    → Use const T&                                               │
│                                                                 │
│  Will store/own the value?                                      │
│    → Use T (by value) and std::move internally                  │
│    → OR overload with const T& and T&&                          │
│                                                                 │
│  Perfect forwarding in template?                                │
│    → Use T&& with std::forward<T>                               │
│                                                                 │
│  FOR RETURN VALUES:                                             │
│  ──────────────────                                             │
│                                                                 │
│  Returning local variable?                                      │
│    → Return by value (RVO will optimize)                        │
│    → DON'T use std::move                                        │
│                                                                 │
│  Returning member?                                              │
│    → Use const T& for read access                               │
│    → Use T for copy/move                                        │
│                                                                 │
│  FOR MOVE OPERATIONS:                                           │
│  ────────────────────                                           │
│                                                                 │
│  Want to transfer ownership?                                    │
│    → Use std::move(obj)                                         │
│                                                                 │
│  In template, preserve category?                                │
│    → Use std::forward<T>(arg)                                   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
*/
```
**Quick Reference Card**
```
┌─────────────────────────────────────────────────────────────────┐
│              VALUE CATEGORIES QUICK REFERENCE                   │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  LVALUE:                                                        │
│  • Has identity (name/address)                                  │
│  • Persists beyond expression                                   │
│  • Examples: x, *ptr, arr[i], ++x, "string literal"             │
│                                                                 │
│  RVALUE:                                                        │
│  • Temporary/expiring value                                     │
│  • Can be moved from                                            │
│  • Examples: 42, x+y, x++, function(), Type()                   │
│                                                                 │
│  XVALUE (eXpiring):                                             │
│  • Has identity AND can be moved                                │
│  • Examples: std::move(x), static_cast<T&&>(x)                  │
│                                                                 │
│  ─────────────────────────────────────────────────────────────  │
│                                                                 │
│  T&    →  Binds to lvalue only                                  │
│  const T& →  Binds to lvalue OR rvalue                          │
│  T&&   →  Binds to rvalue only                                  │
│                                                                 │
│  ─────────────────────────────────────────────────────────────  │
│                                                                 │
│  std::move(x)       →  Cast x to rvalue (enable moving)         │
│  std::forward<T>(x) →  Preserve x's value category              │
│                                                                 │
│  ─────────────────────────────────────────────────────────────  │
│                                                                 │
│  REMEMBER:                                                      │
│  • An rvalue reference VARIABLE is an lvalue!                   │
│  • std::move doesn't move, it just casts                        │
│  • const objects can't be moved (will copy)                     │
│  • Don't std::move return values                                │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```


---

## Lambda Functions in C++
A comprehensive guide covering lambda syntax, captures, parameters, return types, and advanced usage.

### Table of Contents
* Introduction to Lambdas
* Lambda Syntax
* Capture Clause
* Parameters
* Return Types
* Mutable Lambdas
* Generic Lambdas
* Lambda Captures in Depth
* Lambdas with STL
* Advanced Lambda Techniques
* Best Practices

### 1. Introduction to Lambdas
**What is a Lambda?**
A lambda (or lambda expression) is an anonymous function object that can be defined inline where it's needed.

``` 
┌─────────────────────────────────────────────────────────────────┐
│                    LAMBDA EXPRESSION                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  A lambda is:                                                   │
│  • An ANONYMOUS (unnamed) function                              │
│  • Defined INLINE at the point of use                           │
│  • Can CAPTURE variables from surrounding scope                 │
│  • Creates a CLOSURE (function + captured state)                │
│  • Implemented as a FUNCTOR (function object) by compiler       │
│                                                                 │
│  SYNTAX OVERVIEW:                                               │
│  ─────────────────                                              │
│                                                                 │
│  [ captures ] ( parameters ) -> return_type { body }            │
│  ─────┬─────   ─────┬─────    ──────┬─────   ──┬──              │
│       │             │               │          │                │
│       │             │               │          └─ Function body │
│       │             │               │                           │
│       │             │               └─ Optional return type     │
│       │             │                                           │
│       │             └─ Optional parameters                      │
│       │                                                         │
│       └─ Variables from enclosing scope                         │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```
**Why Use Lambdas?**

``` cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

// WITHOUT Lambda: Need separate function
bool isEven(int n) {
    return n % 2 == 0;
}

// WITHOUT Lambda: Need functor class
class IsGreaterThan {
    int threshold;
public:
    IsGreaterThan(int t) : threshold(t) {}
    bool operator()(int n) const {
        return n > threshold;
    }
};

int main() {
    vector<int> nums = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

    // ═══════════════════════════════════════════════════════════
    // WITHOUT LAMBDA: Using function pointer
    // ═══════════════════════════════════════════════════════════
    cout << "Even numbers (function): ";
    for_each(nums.begin(), nums.end(), [](int n) {
        if (isEven(n)) cout << n << " ";
    });
    cout << endl;

    // ═══════════════════════════════════════════════════════════
    // WITHOUT LAMBDA: Using functor
    // ═══════════════════════════════════════════════════════════
    int threshold = 5;
    cout << "Numbers > 5 (functor): ";
    auto count1 = count_if(nums.begin(), nums.end(), IsGreaterThan(threshold));
    cout << count1 << " numbers" << endl;

    // ═══════════════════════════════════════════════════════════
    // WITH LAMBDA: Inline, concise, captures context
    // ═══════════════════════════════════════════════════════════
    cout << "Even numbers (lambda): ";
    for_each(nums.begin(), nums.end(), [](int n) {
        if (n % 2 == 0) cout << n << " ";
    });
    cout << endl;

    cout << "Numbers > 5 (lambda): ";
    auto count2 = count_if(nums.begin(), nums.end(), [threshold](int n) {
        return n > threshold;  // Can use 'threshold' from enclosing scope!
    });
    cout << count2 << " numbers" << endl;

    return 0;
}
```

**Output:**

``` text

Even numbers (function): 2 4 6 8 10 
Numbers > 5 (functor): 5 numbers
Even numbers (lambda): 2 4 6 8 10 
Numbers > 5 (lambda): 5 numbers
```

### 2. Lambda Syntax
**Complete Syntax Breakdown**

```
┌─────────────────────────────────────────────────────────────────┐
│                  LAMBDA SYNTAX COMPONENTS                       │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  FULL SYNTAX:                                                   │
│                                                                 │
│  [capture](params) mutable constexpr noexcept -> ret { body }   │
│                                                                 │
│  COMPONENT         REQUIRED?    DESCRIPTION                     │
│  ─────────         ─────────    ───────────                     │
│  [capture]         YES          Variables from outer scope      │
│  (params)          NO*          Function parameters             │
│  mutable           NO           Allow modifying captured vars   │
│  constexpr         NO           Compile-time evaluation (C++17) │
│  noexcept          NO           No exceptions thrown            │
│  -> ret            NO           Explicit return type            │
│  { body }          YES          Function implementation         │
│                                                                 │
│  * Required if using mutable, constexpr, noexcept, or -> ret   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```
**Syntax Examples**

``` cpp
#include <iostream>
#include <functional>
using namespace std;

int main() {
    // ═══════════════════════════════════════════════════════════
    // MINIMAL LAMBDA: Just capture and body
    // ═══════════════════════════════════════════════════════════
    
    auto minimal = []{ cout << "Hello!" << endl; };
    minimal();
    
    // ═══════════════════════════════════════════════════════════
    // WITH PARAMETERS
    // ═══════════════════════════════════════════════════════════
    
    auto add = [](int a, int b) { return a + b; };
    cout << "3 + 4 = " << add(3, 4) << endl;
    
    // ═══════════════════════════════════════════════════════════
    // WITH EXPLICIT RETURN TYPE
    // ═══════════════════════════════════════════════════════════
    
    auto divide = [](double a, double b) -> double {
        if (b == 0) return 0;
        return a / b;
    };
    cout << "10 / 3 = " << divide(10, 3) << endl;
    
    // ═══════════════════════════════════════════════════════════
    // WITH CAPTURE
    // ═══════════════════════════════════════════════════════════
    
    int multiplier = 5;
    auto multiply = [multiplier](int x) { return x * multiplier; };
    cout << "7 * 5 = " << multiply(7) << endl;
    
    // ═══════════════════════════════════════════════════════════
    // MUTABLE LAMBDA
    // ═══════════════════════════════════════════════════════════
    
    int counter = 0;
    auto increment = [counter]() mutable { return ++counter; };
    cout << "Counter: " << increment() << ", " << increment() << endl;
    cout << "Original counter: " << counter << endl;  // Still 0!
    
    // ═══════════════════════════════════════════════════════════
    // NOEXCEPT LAMBDA
    // ═══════════════════════════════════════════════════════════
    
    auto safeOp = [](int x) noexcept { return x * 2; };
    cout << "Safe: " << safeOp(21) << endl;
    
    // ═══════════════════════════════════════════════════════════
    // GENERIC LAMBDA (C++14)
    // ═══════════════════════════════════════════════════════════
    
    auto print = [](auto value) { cout << value << endl; };
    print(42);
    print("Hello");
    print(3.14);
    
    // ═══════════════════════════════════════════════════════════
    // IMMEDIATELY INVOKED LAMBDA (IIFE)
    // ═══════════════════════════════════════════════════════════
    
    int result = [](int x, int y) { return x * y; }(6, 7);
    cout << "6 * 7 = " << result << endl;
    
    // Complex initialization
    const auto config = []() {
        // Complex initialization logic
        return "initialized";
    }();
    cout << "Config: " << config << endl;
    
    return 0;
}
```

**Output:**

```text

Hello!
3 + 4 = 7
10 / 3 = 3.33333
7 * 5 = 35
Counter: 1, 2
Original counter: 0
Safe: 42
42
Hello
3.14
6 * 7 = 42
Config: initialized
```
**Lambda Type**

``` cpp
#include <iostream>
#include <functional>
#include <typeinfo>
using namespace std;

int main() {
    // Each lambda has a UNIQUE, UNNAMED type
    auto lambda1 = [](int x) { return x * 2; };
    auto lambda2 = [](int x) { return x * 2; };  // Different type!
    
    // lambda1 and lambda2 have DIFFERENT types even though identical!
    cout << "Same type? " << boolalpha 
         << is_same_v<decltype(lambda1), decltype(lambda2)> << endl;  // false
    
    // ═══════════════════════════════════════════════════════════
    // STORING LAMBDAS
    // ═══════════════════════════════════════════════════════════
    
    // Using auto (preferred)
    auto autoLambda = [](int x) { return x + 1; };
    
    // Using std::function (type-erased, has overhead)
    function<int(int)> funcLambda = [](int x) { return x + 1; };
    
    // Using function pointer (only for non-capturing lambdas!)
    int (*ptrLambda)(int) = [](int x) { return x + 1; };
    
    cout << "autoLambda(5) = " << autoLambda(5) << endl;
    cout << "funcLambda(5) = " << funcLambda(5) << endl;
    cout << "ptrLambda(5) = " << ptrLambda(5) << endl;
    
    // Capturing lambda CANNOT convert to a function pointer
    int y = 10;
    auto capturing = [y](int x) { return x + y; };
    // int (*ptr)(int) = capturing;  // ERROR!
    function<int(int)> funcCapturing = capturing;  // OK
    
    return 0;
}
```

### 3. Capture Clause
**Capture Modes Overview**

``` 
┌─────────────────────────────────────────────────────────────────┐
│                    CAPTURE CLAUSE OPTIONS                       │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  SYNTAX              MEANING                                    │
│  ──────              ───────                                    │
│  []                  No captures                                │
│  [=]                 Capture all by VALUE (copy)                │
│  [&]                 Capture all by REFERENCE                   │
│  [x]                 Capture x by value                         │
│  [&x]                Capture x by reference                     │
│  [=, &x]             All by value, x by reference               │
│  [&, x]              All by reference, x by value               │
│  [this]              Capture 'this' pointer                     │
│  [*this]             Capture 'this' by value (C++17)            │
│  [x = expr]          Init capture (C++14)                       │
│  [&x = expr]         Init capture by reference (C++14)          │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```
**Basic Captures**
``` cpp
#include <iostream>
using namespace std;

int main() {
    int a = 10;
    int b = 20;
    int c = 30;
    
    // ═══════════════════════════════════════════════════════════
    // NO CAPTURE: []
    // ═══════════════════════════════════════════════════════════
    
    auto noCapture = []() {
        // cout << a;  // ERROR: 'a' not captured
        return 42;
    };
    cout << "No capture: " << noCapture() << endl;
    
    // ═══════════════════════════════════════════════════════════
    // CAPTURE BY VALUE: [x] or [=]
    // ═══════════════════════════════════════════════════════════
    
    // Specific variables by value
    auto captureByValue = [a, b]() {
        return a + b;  // Uses COPIES of a and b
        // a = 100;    // ERROR: cannot modify (unless mutable)
    };
    cout << "Capture by value: " << captureByValue() << endl;
    
    // All variables by value
    auto captureAllByValue = [=]() {
        return a + b + c;  // Copies of a, b, c
    };
    cout << "Capture all by value: " << captureAllByValue() << endl;
    
    // ═══════════════════════════════════════════════════════════
    // CAPTURE BY REFERENCE: [&x] or [&]
    // ═══════════════════════════════════════════════════════════
    
    // Specific variables by reference
    auto captureByRef = [&a, &b]() {
        a += 5;  // Modifies original a
        b += 5;  // Modifies original b
        return a + b;
    };
    cout << "Before ref capture: a=" << a << ", b=" << b << endl;
    cout << "Capture by ref result: " << captureByRef() << endl;
    cout << "After ref capture: a=" << a << ", b=" << b << endl;
    
    // All variables by reference
    auto captureAllByRef = [&]() {
        a *= 2;
        b *= 2;
        c *= 2;
    };
    captureAllByRef();
    cout << "After all by ref: a=" << a << ", b=" << b << ", c=" << c << endl;
    
    // ═══════════════════════════════════════════════════════════
    // MIXED CAPTURE: [=, &x] or [&, x]
    // ═══════════════════════════════════════════════════════════
    
    a = 10; b = 20; c = 30;  // Reset
    
    // All by value, but 'a' by reference
    auto mixed1 = [=, &a]() {
        a = 100;  // Modifies original
        return a + b + c;  // b, c are copies
    };
    cout << "Mixed [=, &a]: " << mixed1() << ", a=" << a << endl;
    
    // All by reference, but 'b' by value
    auto mixed2 = [&, b]() mutable {
        a = 1;
        b = 2;  // Modifies copy only (mutable needed)
        c = 3;
        return a + b + c;
    };
    cout << "Mixed [&, b]: " << mixed2() << endl;
    cout << "After: a=" << a << ", b=" << b << ", c=" << c << endl;
    
    return 0;
}
```

**Output:**

```text

No capture: 42
Capture by value: 30
Capture all by value: 60
Before ref capture: a=10, b=20
Capture by ref result: 40
After ref capture: a=15, b=25
After all by ref: a=30, b=50, c=60
Mixed [=, &a]: 180, a=100
Mixed [&, b]: 6
After: a=1, b=50, c=3
```
**Visual: Capture Modes**

```
═══════════════════════════════════════════════════════════════════
                    CAPTURE BY VALUE vs REFERENCE
═══════════════════════════════════════════════════════════════════

    int x = 10;
    int y = 20;

    ═══════════════════════════════════════════════════════════════
    CAPTURE BY VALUE [x, y] or [=]
    ═══════════════════════════════════════════════════════════════
    
    OUTER SCOPE                    LAMBDA (Closure Object)
    ┌─────────────┐               ┌─────────────────────────┐
    │ x: 10       │    COPY       │  captured_x: 10         │
    │             │ ──────────►   │  captured_y: 20         │
    │ y: 20       │               │                         │
    └─────────────┘               │  operator()() {         │
                                  │    // uses copies       │
                                  │  }                      │
                                  └─────────────────────────┘
    
    • Lambda has its OWN copies
    • Changes in lambda don't affect original
    • Changes in original don't affect lambda's copies
    • Safe even if original goes out of scope
    
    ═══════════════════════════════════════════════════════════════
    CAPTURE BY REFERENCE [&x, &y] or [&]
    ═══════════════════════════════════════════════════════════════
    
    OUTER SCOPE                    LAMBDA (Closure Object)
    ┌─────────────┐               ┌─────────────────────────┐
    │ x: 10 ◄─────┼───────────────┼── &x (reference)        │
    │             │               │                         │
    │ y: 20 ◄─────┼───────────────┼── &y (reference)        │
    └─────────────┘               │                         │
                                  │  operator()() {         │
                                  │    // uses references   │
                                  │  }                      │
                                  └─────────────────────────┘
    
    • Lambda has REFERENCES to originals
    • Changes in lambda AFFECT original
    • Changes in original AFFECT lambda's view
    • DANGER: If original goes out of scope → dangling reference!

═══════════════════════════════════════════════════════════════════
```

**Capturing 'this'**

``` cpp
#include <iostream>
#include <functional>
using namespace std;

class Counter {
    int value = 0;
    string name;

public:
    Counter(const string& n) : name(n) {}

    void incrementAsync() {
        // [this] captures 'this' pointer
        auto lambda = [this]() {
            value++;  // Accesses member through 'this'
            cout << name << ": " << value << endl;
        };
        lambda();
    }

    void incrementWithCopy() {
        // [*this] captures a COPY of the object (C++17)
        auto lambda = [*this]() mutable {
            value++;  // Modifies the COPY
            cout << name << " (copy): " << value << endl;
        };
        lambda();
        cout << name << " (original): " << value << endl;
    }

    void incorrectCapture() {
        // [=] in member function captures 'this' by value (the pointer!)
        // NOT a copy of the object
        auto lambda = [=]() {
            value++;  // Same as this->value++
        };
        lambda();
    }

    // Returns lambda - careful with lifetime!
    function<void()> getIncrementer() {
        // DANGER: [this] - if Counter is destroyed, lambda has dangling pointer
        // SAFE: [*this] - lambda has its own copy
        return [*this]() mutable {
            value++;
            cout << "Captured copy: " << value << endl;
        };
    }

    int getValue() const { return value; }
};

int main() {
    Counter c("MyCounter");

    cout << "=== [this] capture ===" << endl;
    c.incrementAsync();
    c.incrementAsync();

    cout << "\n=== [*this] capture (C++17) ===" << endl;
    c.incrementWithCopy();

    cout << "\n=== Returned lambda with [*this] ===" << endl;
    auto incrementer = c.getIncrementer();
    incrementer();
    incrementer();
    cout << "Original value: " << c.getValue() << endl;

    return 0;
}
```

**Output:**

```text

=== [this] capture ===
MyCounter: 1
MyCounter: 2

=== [*this] capture (C++17) ===
MyCounter (copy): 3
MyCounter (original): 2

=== Returned lambda with [*this] ===
Captured copy: 3
Captured copy: 4
Original value: 2
```

### 4. Parameters
**Parameter Types**

``` cpp
#include <iostream>
#include <string>
#include <vector>
using namespace std;

int main() {
    // ═══════════════════════════════════════════════════════════
    // NO PARAMETERS
    // ═══════════════════════════════════════════════════════════
    
    auto noParams = []{ return 42; };  // Parentheses optional
    auto noParams2 = []() { return 42; };  // Explicit empty parens
    cout << "No params: " << noParams() << endl;
    
    // ═══════════════════════════════════════════════════════════
    // BASIC PARAMETERS
    // ═══════════════════════════════════════════════════════════
    
    auto add = [](int a, int b) { return a + b; };
    cout << "Add: " << add(3, 4) << endl;
    
    // ═══════════════════════════════════════════════════════════
    // REFERENCE PARAMETERS
    // ═══════════════════════════════════════════════════════════
    
    auto doubleValue = [](int& x) { x *= 2; };
    int num = 5;
    doubleValue(num);
    cout << "After doubleValue: " << num << endl;
    
    // ═══════════════════════════════════════════════════════════
    // CONST REFERENCE PARAMETERS (efficient for large objects)
    // ═══════════════════════════════════════════════════════════
    
    auto printVector = [](const vector<int>& v) {
        for (int x : v) cout << x << " ";
        cout << endl;
    };
    printVector({1, 2, 3, 4, 5});
    
    // ═══════════════════════════════════════════════════════════
    // MOVE PARAMETERS
    // ═══════════════════════════════════════════════════════════
    
    auto consumeString = [](string&& s) {
        cout << "Consumed: " << s << endl;
        // s is now owned by the lambda
    };
    consumeString(string("Temporary"));
    // consumeString(str);  // ERROR: str is lvalue
    
    // ═══════════════════════════════════════════════════════════
    // DEFAULT PARAMETERS (C++14)
    // ═══════════════════════════════════════════════════════════
    
    auto greet = [](const string& name = "World") {
        cout << "Hello, " << name << "!" << endl;
    };
    greet();
    greet("Alice");
    
    // ═══════════════════════════════════════════════════════════
    // VARIADIC PARAMETERS (C++14 with generic lambda)
    // ═══════════════════════════════════════════════════════════
    
    auto printAll = [](auto... args) {
        ((cout << args << " "), ...);  // Fold expression (C++17)
        cout << endl;
    };
    printAll(1, 2.5, "hello", 'c');
    
    return 0;
}
```
**Generic Lambda Parameters (C++14)**

``` cpp
#include <iostream>
#include <string>
#include <vector>
#include <type_traits>
using namespace std;

int main() {
    // ═══════════════════════════════════════════════════════════
    // GENERIC LAMBDA: auto parameters
    // ═══════════════════════════════════════════════════════════
    
    // Single auto parameter
    auto print = [](auto x) {
        cout << x << endl;
    };
    print(42);
    print("Hello");
    print(3.14);
    
    // Multiple auto parameters
    auto add = [](auto a, auto b) {
        return a + b;
    };
    cout << "int + int: " << add(3, 4) << endl;
    cout << "double + int: " << add(3.5, 4) << endl;
    cout << "string + string: " << add(string("Hello "), string("World")) << endl;
    
    // ═══════════════════════════════════════════════════════════
    // GENERIC LAMBDA WITH CONSTRAINTS (C++20)
    // ═══════════════════════════════════════════════════════════
    
    // Using concepts
    auto addNumbers = []<typename T>(T a, T b) requires is_arithmetic_v<T> {
        return a + b;
    };
    cout << "Constrained add: " << addNumbers(10, 20) << endl;
    // addNumbers("a", "b");  // ERROR: string is not arithmetic
    
    // ═══════════════════════════════════════════════════════════
    // DECLTYPE(AUTO) RETURN WITH GENERIC PARAMS
    // ═══════════════════════════════════════════════════════════
    
    auto getFirst = [](auto& container) -> decltype(auto) {
        return container[0];  // Returns reference if container[0] is reference
    };
    
    vector<int> v = {10, 20, 30};
    getFirst(v) = 100;  // Modifies v[0]
    cout << "v[0] after modification: " << v[0] << endl;
    
    // ═══════════════════════════════════════════════════════════
    // PERFECT FORWARDING IN GENERIC LAMBDA
    // ═══════════════════════════════════════════════════════════
    
    auto wrapper = [](auto&& arg) {
        // Forward preserves lvalue/rvalue nature
        process(std::forward<decltype(arg)>(arg));
    };
    
    return 0;
}

void process(int& x) { cout << "lvalue: " << x << endl; }
void process(int&& x) { cout << "rvalue: " << x << endl; }
```

**C++20 Template Lambdas**

``` cpp
#include <iostream>
#include <concepts>
#include <type_traits>
using namespace std;

int main() {
    // ═══════════════════════════════════════════════════════════
    // EXPLICIT TEMPLATE PARAMETERS (C++20)
    // ═══════════════════════════════════════════════════════════
    
    // Explicitly specify template parameter
    auto compare = []<typename T>(T a, T b) {
        return a < b;
    };
    cout << "compare(3, 5): " << boolalpha << compare(3, 5) << endl;
    
    // With concepts
    auto addIntegral = []<integral T>(T a, T b) {
        return a + b;
    };
    cout << "addIntegral: " << addIntegral(10, 20) << endl;
    // addIntegral(1.5, 2.5);  // ERROR: double is not integral
    
    // Multiple template parameters
    auto convert = []<typename To, typename From>(From value) {
        return static_cast<To>(value);
    };
    cout << "convert<int>(3.7): " << convert.operator()<int>(3.7) << endl;
    
    // Template parameter with constraints
    auto multiply = []<typename T>
        requires is_arithmetic_v<T>
    (T a, T b) {
        return a * b;
    };
    cout << "multiply(3.5, 2): " << multiply(3.5, 2.0) << endl;
    
    // Variadic template lambda
    auto printTypes = []<typename... Ts>(Ts... args) {
        ((cout << typeid(args).name() << ": " << args << endl), ...);
    };
    printTypes(1, 2.5, "hello");
    
    return 0;
}
```
### 5. Return Types
**Return Type Deduction**

``` cpp
#include <iostream>
#include <string>
#include <vector>
#include <optional>
using namespace std;

int main() {
    // ═══════════════════════════════════════════════════════════
    // AUTOMATIC DEDUCTION: Single return statement
    // ═══════════════════════════════════════════════════════════
    
    auto add = [](int a, int b) { return a + b; };  // Deduced as int
    
    auto getMessage = []{ return "Hello"; };  // Deduced as const char*
    
    auto createVector = [] { 
        return vector<int>{1, 2, 3}; 
    };  // Deduced as vector<int>
    
    // ═══════════════════════════════════════════════════════════
    // AUTOMATIC DEDUCTION: Multiple return statements
    // ═══════════════════════════════════════════════════════════
    
    // All returns must have same type (or convertible)
    auto absolute = [](int x) {
        if (x < 0) return -x;
        return x;  // Both return int - OK
    };
    
    // This is OK: all returns convertible to double
    auto getValue = [](bool flag) {
        if (flag) return 1;    // int
        return 2.5;            // double - int converts to double
    };  // Deduced as double
    
    // ═══════════════════════════════════════════════════════════
    // EXPLICIT RETURN TYPE: -> Type
    // ═══════════════════════════════════════════════════════════
    
    // When deduction is ambiguous or you want specific type
    auto divide = [](int a, int b) -> double {
        return static_cast<double>(a) / b;
    };
    cout << "10 / 3 = " << divide(10, 3) << endl;
    
    // Returning reference
    auto getFirst = [](vector<int>& v) -> int& {
        return v[0];
    };
    vector<int> v = {10, 20, 30};
    getFirst(v) = 100;
    cout << "v[0] = " << v[0] << endl;
    
    // Returning optional
    auto safeDivide = [](double a, double b) -> optional<double> {
        if (b == 0) return nullopt;
        return a / b;
    };
    auto result = safeDivide(10, 3);
    if (result) cout << "Result: " << *result << endl;
    
    // ═══════════════════════════════════════════════════════════
    // VOID RETURN
    // ═══════════════════════════════════════════════════════════
    
    auto printHello = []() -> void {
        cout << "Hello!" << endl;
        // No return statement needed
    };
    printHello();
    
    // ═══════════════════════════════════════════════════════════
    // DECLTYPE(AUTO) (C++14)
    // ═══════════════════════════════════════════════════════════
    
    // Preserves references and cv-qualifiers
    int x = 42;
    auto getRef = [&x]() -> decltype(auto) {
        return (x);  // Parentheses make it a reference!
    };
    getRef() = 100;
    cout << "x after modification: " << x << endl;
    
    return 0;
}
```

**Return Type Issues**
``` cpp
#include <iostream>
#include <string>
using namespace std;

int main() {
    // ═══════════════════════════════════════════════════════════
    // ISSUE 1: Different return types
    // ═══════════════════════════════════════════════════════════
    
    // ERROR: Different return types
    /*
    auto bad = [](bool flag) {
        if (flag) return 1;      // int
        return "error";          // const char* - incompatible!
    };
    */
    
    // SOLUTION: Use common type or variant
    auto good = [](bool flag) -> string {
        if (flag) return "1";
        return "error";
    };
    
    // ═══════════════════════════════════════════════════════════
    // ISSUE 2: Returning reference to local
    // ═══════════════════════════════════════════════════════════
    
    // DANGER: Returns dangling reference!
    /*
    auto dangerous = []() -> int& {
        int local = 42;
        return local;  // local is destroyed after return!
    };
    */
    
    // SAFE: Return by value
    auto safe = []() -> int {
        int local = 42;
        return local;
    };
    
    // ═══════════════════════════════════════════════════════════
    // ISSUE 3: Recursive lambda needs explicit return type
    // ═══════════════════════════════════════════════════════════
    
    // Cannot deduce return type for recursive lambda
    /*
    auto factorial = [](int n) {
        if (n <= 1) return 1;
        return n * factorial(n - 1);  // ERROR: can't use 'factorial' here
    };
    */
    
    // SOLUTION 1: Use std::function
    function<int(int)> factorial = [&factorial](int n) -> int {
        if (n <= 1) return 1;
        return n * factorial(n - 1);
    };
    cout << "5! = " << factorial(5) << endl;
    
    // SOLUTION 2: Pass lambda to itself (Y-combinator pattern)
    auto factorialY = [](auto self, int n) -> int {
        if (n <= 1) return 1;
        return n * self(self, n - 1);
    };
    cout << "5! = " << factorialY(factorialY, 5) << endl;
    
    return 0;
}
```

### 6. Mutable Lambdas
**Understanding mutable**

``` cpp
#include <iostream>
using namespace std;

int main() {
    int counter = 0;
    
    // ═══════════════════════════════════════════════════════════
    // WITHOUT MUTABLE: Cannot modify captured values
    // ═══════════════════════════════════════════════════════════
    
    auto immutableLambda = [counter]() {
        // counter++;  // ERROR: cannot modify captured variable
        return counter;
    };
    
    // ═══════════════════════════════════════════════════════════
    // WITH MUTABLE: Can modify captured copies
    // ═══════════════════════════════════════════════════════════
    
    auto mutableLambda = [counter]() mutable {
        counter++;  // OK: modifying the lambda's copy
        return counter;
    };
    
    cout << "Call 1: " << mutableLambda() << endl;  // 1
    cout << "Call 2: " << mutableLambda() << endl;  // 2
    cout << "Call 3: " << mutableLambda() << endl;  // 3
    cout << "Original counter: " << counter << endl;  // Still 0!
    
    // ═══════════════════════════════════════════════════════════
    // MUTABLE WITH MULTIPLE CAPTURES
    // ═══════════════════════════════════════════════════════════
    
    int a = 1, b = 2, c = 3;
    
    auto multiMutable = [a, b, c]() mutable {
        a *= 2;
        b *= 2;
        c *= 2;
        cout << "Inside lambda: a=" << a << ", b=" << b << ", c=" << c << endl;
    };
    
    multiMutable();  // a=2, b=4, c=6
    multiMutable();  // a=4, b=8, c=12
    cout << "Original: a=" << a << ", b=" << b << ", c=" << c << endl;  // 1, 2, 3
    
    return 0;
}
```

**Why mutable is Needed?**

``` cpp
#include <iostream>
using namespace std;

/*
═══════════════════════════════════════════════════════════════════
                    WHY MUTABLE?
═══════════════════════════════════════════════════════════════════

Lambda's operator() is CONST by default!

    [x](){ x++; }

Is roughly equivalent to:

    class __Lambda {
        int x;  // Captured by value
    public:
        __Lambda(int x) : x(x) {}
        
        auto operator()() const {  // <-- CONST!
            x++;  // ERROR: can't modify in const method
        }
    };

With 'mutable':

    [x]() mutable { x++; }

Becomes:

    class __Lambda {
        int x;
    public:
        __Lambda(int x) : x(x) {}
        
        auto operator()() {  // <-- NOT const!
            x++;  // OK!
        }
    };

═══════════════════════════════════════════════════════════════════
*/

int main() {
    // Demonstrating the equivalence
    int value = 10;
    
    // Lambda version
    auto lambda = [value]() mutable {
        return ++value;
    };
    
    // Functor equivalent
    class Functor {
        int value;
    public:
        Functor(int v) : value(v) {}
        int operator()() {  // NOT const due to mutable
            return ++value;
        }
    };
    
    Functor functor(10);
    
    cout << "Lambda: " << lambda() << ", " << lambda() << endl;
    cout << "Functor: " << functor() << ", " << functor() << endl;
    
    return 0;
}
```

**Mutable vs Reference Capture**

``` cpp
#include <iostream>
using namespace std;

int main() {
    int x = 10;
    
    // ═══════════════════════════════════════════════════════════
    // MUTABLE: Modifies copy, original unchanged
    // ═══════════════════════════════════════════════════════════
    
    auto byValueMutable = [x]() mutable {
        x += 100;
        cout << "Inside (mutable): " << x << endl;
    };
    
    byValueMutable();  // 110
    byValueMutable();  // 210
    cout << "Original after mutable: " << x << endl;  // Still 10
    
    // ═══════════════════════════════════════════════════════════
    // REFERENCE: Modifies original directly
    // ═══════════════════════════════════════════════════════════
    
    auto byRef = [&x]() {
        x += 100;  // No mutable needed - modifies through reference
        cout << "Inside (ref): " << x << endl;
    };
    
    byRef();  // 110
    byRef();  // 210
    cout << "Original after ref: " << x << endl;  // 210
    
    // ═══════════════════════════════════════════════════════════
    // COMPARISON
    // ═══════════════════════════════════════════════════════════
    
    /*
    ┌─────────────────────────────────────────────────────────────┐
    │  CAPTURE     │ MUTABLE? │ MODIFIES ORIGINAL? │ USE CASE    │
    ├─────────────────────────────────────────────────────────────┤
    │  [x]         │ No       │ No (const copy)    │ Read-only   │
    │  [x] mutable │ Yes      │ No (modify copy)   │ Stateful λ  │
    │  [&x]        │ No       │ Yes (reference)    │ Modify orig │
    └─────────────────────────────────────────────────────────────┘
    */
    
    return 0;
}
```

### 7. Generic Lambdas
**Auto Parameters (C++14)**

``` cpp
#include <iostream>
#include <string>
#include <vector>
#include <type_traits>
using namespace std;

int main() {
    // ═══════════════════════════════════════════════════════════
    // SINGLE AUTO PARAMETER
    // ═══════════════════════════════════════════════════════════
    
    auto print = [](auto x) {
        cout << x << endl;
    };
    
    print(42);           // int
    print(3.14);         // double
    print("Hello");      // const char*
    print(string("Hi")); // string
    
    // ═══════════════════════════════════════════════════════════
    // MULTIPLE AUTO PARAMETERS
    // ═══════════════════════════════════════════════════════════
    
    auto add = [](auto a, auto b) {
        return a + b;
    };
    
    cout << add(1, 2) << endl;           // int + int
    cout << add(1.5, 2.5) << endl;       // double + double
    cout << add(1, 2.5) << endl;         // int + double = double
    cout << add(string("Hi "), string("there")) << endl;
    
    // ═══════════════════════════════════════════════════════════
    // AUTO WITH REFERENCE/CONST
    // ═══════════════════════════════════════════════════════════
    
    auto doubleIt = [](auto& x) {
        x *= 2;
    };
    
    int i = 5;
    double d = 2.5;
    
    doubleIt(i);
    doubleIt(d);
    
    cout << "i = " << i << ", d = " << d << endl;
    
    // Const auto reference
    auto printConst = [](const auto& x) {
        cout << x << endl;
        // x = ...;  // ERROR: const
    };
    
    // ═══════════════════════════════════════════════════════════
    // TYPE DEDUCTION IN GENERIC LAMBDAS
    // ═══════════════════════════════════════════════════════════
    
    auto showType = [](auto x) {
        if constexpr (is_integral_v<decltype(x)>) {
            cout << x << " is integral" << endl;
        } else if constexpr (is_floating_point_v<decltype(x)>) {
            cout << x << " is floating point" << endl;
        } else {
            cout << x << " is other type" << endl;
        }
    };
    
    showType(42);
    showType(3.14);
    showType("hello");
    
    return 0;
}
```
**Generic Lambdas are Templates**

``` cpp
#include <iostream>
using namespace std;

/*
═══════════════════════════════════════════════════════════════════
                GENERIC LAMBDA = TEMPLATE
═══════════════════════════════════════════════════════════════════

    auto lambda = [](auto x) { return x * 2; };

Is roughly equivalent to:

    class __Lambda {
    public:
        template<typename T>
        auto operator()(T x) const {
            return x * 2;
        }
    };
    
    __Lambda lambda;

═══════════════════════════════════════════════════════════════════
*/

int main() {
    auto multiply = [](auto x, auto y) {
        return x * y;
    };
    
    // Each call instantiates a different operator()
    cout << multiply(3, 4) << endl;      // operator()<int, int>
    cout << multiply(3.0, 4.0) << endl;  // operator()<double, double>
    cout << multiply(3, 4.0) << endl;    // operator()<int, double>
    
    // You can explicitly specify template arguments (rarely needed)
    // multiply.operator()<int, int>(3, 4);
    
    return 0;
}
```
**Variadic Generic Lambdas**

``` cpp
#include <iostream>
#include <string>
using namespace std;

int main() {
    // ═══════════════════════════════════════════════════════════
    // VARIADIC LAMBDA (C++14 + C++17 fold expressions)
    // ═══════════════════════════════════════════════════════════
    
    // Print all arguments
    auto printAll = [](auto... args) {
        ((cout << args << " "), ...);
        cout << endl;
    };
    printAll(1, 2.5, "hello", 'c');
    
    // Sum all arguments
    auto sum = [](auto... args) {
        return (args + ...);  // Fold expression
    };
    cout << "Sum: " << sum(1, 2, 3, 4, 5) << endl;
    
    // Count arguments
    auto count = [](auto... args) {
        return sizeof...(args);
    };
    cout << "Count: " << count(1, 2, 3, "a", "b") << endl;
    
    // Apply function to each argument
    auto forEach = [](auto func, auto... args) {
        (func(args), ...);
    };
    
    forEach([](auto x) { cout << x << " "; }, 1, 2, 3, 4, 5);
    cout << endl;
    
    // ═══════════════════════════════════════════════════════════
    // PERFECT FORWARDING VARIADIC LAMBDA
    // ═══════════════════════════════════════════════════════════
    
    auto forwardAll = [](auto&&... args) {
        return make_tuple(forward<decltype(args)>(args)...);
    };
    
    int x = 10;
    auto t = forwardAll(x, 20, string("hello"));
    cout << "Tuple: " << get<0>(t) << ", " << get<1>(t) << ", " << get<2>(t) << endl;
    
    return 0;
}
```

### 8. Lambda Captures in Depth
**Init Captures (C++14)**

``` cpp
#include <iostream>
#include <string>
#include <memory>
#include <utility>
using namespace std;

int main() {
    // ═══════════════════════════════════════════════════════════
    // BASIC INIT CAPTURE
    // ═══════════════════════════════════════════════════════════
    
    int x = 10;
    
    // Capture with different name
    auto lambda1 = [y = x]() {
        return y * 2;
    };
    cout << "y = x: " << lambda1() << endl;
    
    // Capture with expression
    auto lambda2 = [z = x * 2]() {
        return z + 10;
    };
    cout << "z = x * 2: " << lambda2() << endl;
    
    // ═══════════════════════════════════════════════════════════
    // MOVE CAPTURE
    // ═══════════════════════════════════════════════════════════
    
    unique_ptr<int> ptr = make_unique<int>(42);
    
    // Cannot capture unique_ptr by value normally
    // auto bad = [ptr]() { ... };  // ERROR: unique_ptr is not copyable
    
    // Move capture!
    auto lambda3 = [p = move(ptr)]() {
        cout << "Moved unique_ptr: " << *p << endl;
    };
    lambda3();
    // ptr is now nullptr
    
    // ═══════════════════════════════════════════════════════════
    // COPY WITH MODIFICATION
    // ═══════════════════════════════════════════════════════════
    
    string name = "Alice";
    
    auto lambda4 = [greeting = "Hello, " + name]() {
        cout << greeting << "!" << endl;
    };
    lambda4();
    
    // ═══════════════════════════════════════════════════════════
    // REFERENCE INIT CAPTURE
    // ═══════════════════════════════════════════════════════════
    
    int value = 100;
    auto lambda5 = [&ref = value]() {
        ref *= 2;
    };
    lambda5();
    cout << "value after lambda5: " << value << endl;
    
    // ═══════════════════════════════════════════════════════════
    // CAPTURE const EXPRESSION
    // ═══════════════════════════════════════════════════════════
    
    const int constant = 50;
    // Cannot capture const by reference and modify
    auto lambda6 = [c = constant]() mutable {
        c += 10;  // Modifying copy of constant
        return c;
    };
    cout << "Modified const copy: " << lambda6() << endl;
    
    return 0;
}
```

**Moving Objects into Lambdas**

``` cpp
#include <iostream>
#include <vector>
#include <memory>
#include <utility>
using namespace std;

class Resource {
    string name;
public:
    Resource(const string& n) : name(n) {
        cout << "Resource(" << name << ") created" << endl;
    }
    Resource(const Resource& other) : name(other.name + "_copy") {
        cout << "Resource(" << name << ") copied" << endl;
    }
    Resource(Resource&& other) noexcept : name(move(other.name)) {
        cout << "Resource(" << name << ") moved" << endl;
    }
    ~Resource() {
        cout << "Resource(" << name << ") destroyed" << endl;
    }
    void use() const { cout << "Using " << name << endl; }
};

int main() {
    cout << "=== Creating resource ===" << endl;
    Resource res("Original");
    
    cout << "\n=== Capture by value (copies) ===" << endl;
    auto lambda1 = [res]() {
        res.use();
    };
    lambda1();
    
    cout << "\n=== Move capture (moves) ===" << endl;
    auto lambda2 = [r = move(res)]() {
        r.use();
    };
    lambda2();
    // res is now in moved-from state
    
    cout << "\n=== Move unique_ptr ===" << endl;
    auto ptr = make_unique<Resource>("Unique");
    auto lambda3 = [p = move(ptr)]() {
        p->use();
    };
    lambda3();
    // ptr is now nullptr
    
    cout << "\n=== Move vector ===" << endl;
    vector<int> data = {1, 2, 3, 4, 5};
    auto lambda4 = [v = move(data)]() {
        cout << "Vector size: " << v.size() << endl;
    };
    lambda4();
    cout << "Original vector size: " << data.size() << endl;  // 0
    
    cout << "\n=== Cleanup ===" << endl;
    return 0;
}
```

**Capture Pitfalls**

``` cpp
#include <iostream>
#include <functional>
#include <vector>
using namespace std;

function<int()> createCounter() {
    int count = 0;
    
    // DANGER: Capturing local by reference!
    // When function returns, 'count' is destroyed
    // return [&count]() { return ++count; };  // DANGLING REFERENCE!
    
    // SAFE: Capture by value with mutable
    return [count]() mutable { return ++count; };
}

function<void()> createPrinter(const string& msg) {
    // DANGER: 'msg' is a reference parameter!
    // return [&msg]() { cout << msg; };  // May dangle!
    
    // SAFE: Capture by value
    return [msg]() { cout << msg << endl; };
}

class Handler {
    vector<function<void()>> callbacks;
    int id = 42;

public:
    void addCallback() {
        // DANGER: If Handler is destroyed before callback is called
        // 'this' becomes dangling!
        // callbacks.push_back([this]() { cout << id; });
        
        // SAFER: Capture by value (C++17)
        callbacks.push_back([*this]() { cout << id << endl; });
        
        // Or capture specific member
        callbacks.push_back([id = this->id]() { cout << id << endl; });
    }

    void runCallbacks() {
        for (auto& cb : callbacks) cb();
    }
};

int main() {
    cout << "=== Safe counter ===" << endl;
    auto counter = createCounter();
    cout << counter() << endl;  // 1
    cout << counter() << endl;  // 2
    cout << counter() << endl;  // 3
    
    cout << "\n=== Safe printer ===" << endl;
    auto printer = createPrinter("Hello, World!");
    printer();
    
    cout << "\n=== Handler with [*this] ===" << endl;
    Handler h;
    h.addCallback();
    h.runCallbacks();
    
    // ═══════════════════════════════════════════════════════════
    // LOOP CAPTURE PITFALL
    // ═══════════════════════════════════════════════════════════
    
    cout << "\n=== Loop capture issue ===" << endl;
    
    vector<function<void()>> funcs;
    
    // WRONG: All lambdas capture reference to same 'i'
    /*
    for (int i = 0; i < 5; i++) {
        funcs.push_back([&i]() { cout << i << " "; });
    }
    // All print "5" because i = 5 after loop!
    */
    
    // CORRECT: Capture by value
    for (int i = 0; i < 5; i++) {
        funcs.push_back([i]() { cout << i << " "; });
    }
    for (auto& f : funcs) f();
    cout << endl;
    
    // CORRECT: Init capture
    for (int i = 0; i < 5; i++) {
        funcs.push_back([j = i]() { cout << j << " "; });
    }
    
    return 0;
}
```

**Visual: Capture Pitfalls**

``` cpp
═══════════════════════════════════════════════════════════════════
                    CAPTURE PITFALLS
═══════════════════════════════════════════════════════════════════

PITFALL 1: Capturing local by reference
─────────────────────────────────────────

    function<int()> bad() {
        int x = 10;
        return [&x]() { return x; };  // ❌ DANGLING!
    }
    
    TIMELINE:
    ┌────────────────────────────────────────────────────────────┐
    │ bad() called                                               │
    │   ├── x created on stack                                   │
    │   ├── lambda created, captures &x                          │
    │   ├── lambda returned                                      │
    │   └── x DESTROYED (stack unwound)                          │
    │                                                            │
    │ lambda called                                              │
    │   └── accesses &x → UNDEFINED BEHAVIOR (x doesn't exist!)  │
    └────────────────────────────────────────────────────────────┘

PITFALL 2: [&] in loops
─────────────────────────

    vector<function<void()>> funcs;
    for (int i = 0; i < 3; i++) {
        funcs.push_back([&i]() { cout << i; });  // ❌ All same i!
    }
    
    ITERATION 0: lambda[0] captures &i (i = 0)
    ITERATION 1: lambda[1] captures &i (i = 1)
    ITERATION 2: lambda[2] captures &i (i = 2)
    LOOP ENDS:   i = 3
    
    CALL funcs[0](): i = 3 → prints 3
    CALL funcs[1](): i = 3 → prints 3
    CALL funcs[2](): i = 3 → prints 3
    
    All print "3"!

PITFALL 3: [this] with object lifetime
────────────────────────────────────────

    class Widget {
        function<void()> callback;
        int value = 42;
        
        void setup() {
            callback = [this]() { cout << value; };  // ❌ If Widget dies
        }
    };
    
    auto cb = widget.callback;
    delete widget;  // or widget goes out of scope
    cb();           // ❌ CRASH: this is dangling!

═══════════════════════════════════════════════════════════════════

SOLUTIONS:
──────────

    [&x]      →  [x]           Capture by value
    [&]       →  [=]           All by value
    [this]    →  [*this]       Copy the object (C++17)
    [&i] loop →  [i] or [j=i]  Capture loop variable by value

═══════════════════════════════════════════════════════════════════
```

### 9. Lambdas with STL
**Common Algorithm Examples**

``` cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>
#include <string>
#include <map>
using namespace std;

int main() {
    vector<int> nums = {5, 2, 8, 1, 9, 3, 7, 4, 6};
    
    // ═══════════════════════════════════════════════════════════
    // FOR_EACH
    // ═══════════════════════════════════════════════════════════
    
    cout << "for_each: ";
    for_each(nums.begin(), nums.end(), [](int n) {
        cout << n << " ";
    });
    cout << endl;
    
    // ═══════════════════════════════════════════════════════════
    // TRANSFORM
    // ═══════════════════════════════════════════════════════════
    
    vector<int> doubled(nums.size());
    transform(nums.begin(), nums.end(), doubled.begin(), [](int n) {
        return n * 2;
    });
    
    cout << "transform (doubled): ";
    for (int n : doubled) cout << n << " ";
    cout << endl;
    
    // ═══════════════════════════════════════════════════════════
    // SORT
    // ═══════════════════════════════════════════════════════════
    
    vector<int> sorted = nums;
    
    // Ascending
    sort(sorted.begin(), sorted.end(), [](int a, int b) {
        return a < b;
    });
    cout << "sort ascending: ";
    for (int n : sorted) cout << n << " ";
    cout << endl;
    
    // Descending
    sort(sorted.begin(), sorted.end(), [](int a, int b) {
        return a > b;
    });
    cout << "sort descending: ";
    for (int n : sorted) cout << n << " ";
    cout << endl;
    
    // ═══════════════════════════════════════════════════════════
    // FIND_IF
    // ═══════════════════════════════════════════════════════════
    
    auto it = find_if(nums.begin(), nums.end(), [](int n) {
        return n > 5;
    });
    if (it != nums.end()) {
        cout << "First > 5: " << *it << endl;
    }
    
    // ═══════════════════════════════════════════════════════════
    // COUNT_IF
    // ═══════════════════════════════════════════════════════════
    
    int threshold = 4;
    int count = count_if(nums.begin(), nums.end(), [threshold](int n) {
        return n > threshold;
    });
    cout << "Count > " << threshold << ": " << count << endl;
    
    // ═══════════════════════════════════════════════════════════
    // REMOVE_IF + ERASE (Erase-Remove Idiom)
    // ═══════════════════════════════════════════════════════════
    
    vector<int> filtered = nums;
    filtered.erase(
        remove_if(filtered.begin(), filtered.end(), [](int n) {
            return n % 2 == 0;  // Remove even numbers
        }),
        filtered.end()
    );
    cout << "After removing evens: ";
    for (int n : filtered) cout << n << " ";
    cout << endl;
    
    // ═══════════════════════════════════════════════════════════
    // ACCUMULATE
    // ═══════════════════════════════════════════════════════════
    
    int sum = accumulate(nums.begin(), nums.end(), 0, [](int acc, int n) {
        return acc + n;
    });
    cout << "Sum: " << sum << endl;
    
    int product = accumulate(nums.begin(), nums.end(), 1, [](int acc, int n) {
        return acc * n;
    });
    cout << "Product: " << product << endl;
    
    // ═══════════════════════════════════════════════════════════
    // ALL_OF, ANY_OF, NONE_OF
    // ═══════════════════════════════════════════════════════════
    
    cout << boolalpha;
    cout << "All positive: " << all_of(nums.begin(), nums.end(), 
        [](int n) { return n > 0; }) << endl;
    
    cout << "Any even: " << any_of(nums.begin(), nums.end(), 
        [](int n) { return n % 2 == 0; }) << endl;
    
    cout << "None negative: " << none_of(nums.begin(), nums.end(), 
        [](int n) { return n < 0; }) << endl;
    
    return 0;
}
```

**Complex Sorting Examples**
``` cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <string>
using namespace std;

struct Person {
    string name;
    int age;
    double salary;
};

int main() {
    vector<Person> people = {
        {"Alice", 30, 50000},
        {"Bob", 25, 60000},
        {"Charlie", 35, 55000},
        {"Diana", 28, 70000},
        {"Eve", 30, 65000}
    };
    
    // ═══════════════════════════════════════════════════════════
    // SORT BY SINGLE FIELD
    // ═══════════════════════════════════════════════════════════
    
    // Sort by age
    sort(people.begin(), people.end(), [](const Person& a, const Person& b) {
        return a.age < b.age;
    });
    
    cout << "Sorted by age:" << endl;
    for (const auto& p : people) {
        cout << "  " << p.name << ", " << p.age << ", $" << p.salary << endl;
    }
    
    // ═══════════════════════════════════════════════════════════
    // SORT BY MULTIPLE FIELDS
    // ═══════════════════════════════════════════════════════════
    
    // Sort by age, then by salary (descending)
    sort(people.begin(), people.end(), [](const Person& a, const Person& b) {
        if (a.age != b.age) return a.age < b.age;
        return a.salary > b.salary;  // Higher salary first for same age
    });
    
    cout << "\nSorted by age, then salary (desc):" << endl;
    for (const auto& p : people) {
        cout << "  " << p.name << ", " << p.age << ", $" << p.salary << endl;
    }
    
    // ═══════════════════════════════════════════════════════════
    // SORT WITH EXTERNAL PARAMETER
    // ═══════════════════════════════════════════════════════════
    
    string sortField = "salary";
    
    sort(people.begin(), people.end(), [&sortField](const Person& a, const Person& b) {
        if (sortField == "name") return a.name < b.name;
        if (sortField == "age") return a.age < b.age;
        if (sortField == "salary") return a.salary < b.salary;
        return false;
    });
    
    cout << "\nSorted by " << sortField << ":" << endl;
    for (const auto& p : people) {
        cout << "  " << p.name << ", " << p.age << ", $" << p.salary << endl;
    }
    
    // ═══════════════════════════════════════════════════════════
    // STABLE_SORT (preserves relative order of equal elements)
    // ═══════════════════════════════════════════════════════════
    
    stable_sort(people.begin(), people.end(), [](const Person& a, const Person& b) {
        return a.age < b.age;
    });
    
    // ═══════════════════════════════════════════════════════════
    // PARTIAL_SORT (top N elements)
    // ═══════════════════════════════════════════════════════════
    
    // Get top 3 by salary
    partial_sort(people.begin(), people.begin() + 3, people.end(),
        [](const Person& a, const Person& b) {
            return a.salary > b.salary;  // Descending
        });
    
    cout << "\nTop 3 by salary:" << endl;
    for (int i = 0; i < 3; i++) {
        cout << "  " << people[i].name << ", $" << people[i].salary << endl;
    }
    
    return 0;
}
```

**Callback Patterns**
``` cpp
#include <iostream>
#include <vector>
#include <functional>
#include <string>
using namespace std;

class EventEmitter {
    vector<function<void(const string&)>> listeners;

public:
    void on(function<void(const string&)> callback) {
        listeners.push_back(callback);
    }

    void emit(const string& event) {
        for (auto& listener : listeners) {
            listener(event);
        }
    }
};

class Button {
    vector<function<void()>> clickHandlers;
    string label;

public:
    Button(const string& l) : label(l) {}

    void onClick(function<void()> handler) {
        clickHandlers.push_back(handler);
    }

    void click() {
        cout << "Button '" << label << "' clicked!" << endl;
        for (auto& handler : clickHandlers) {
            handler();
        }
    }
};

int main() {
    // ═══════════════════════════════════════════════════════════
    // EVENT EMITTER WITH LAMBDAS
    // ═══════════════════════════════════════════════════════════
    
    EventEmitter emitter;
    
    int eventCount = 0;
    
    emitter.on([](const string& event) {
        cout << "Logger: Received event - " << event << endl;
    });
    
    emitter.on([&eventCount](const string& event) {
        eventCount++;
        cout << "Counter: Event #" << eventCount << endl;
    });
    
    emitter.on([](const string& event) {
        if (event == "error") {
            cout << "Alert: Error detected!" << endl;
        }
    });
    
    cout << "=== Emitting events ===" << endl;
    emitter.emit("start");
    emitter.emit("process");
    emitter.emit("error");
    
    // ═══════════════════════════════════════════════════════════
    // BUTTON WITH CLICK HANDLERS
    // ═══════════════════════════════════════════════════════════
    
    cout << "\n=== Button clicks ===" << endl;
    
    Button submitBtn("Submit");
    
    string formData = "user input";
    
    submitBtn.onClick([&formData]() {
        cout << "Validating: " << formData << endl;
    });
    
    submitBtn.onClick([]() {
        cout << "Sending to server..." << endl;
    });
    
    submitBtn.onClick([]() {
        cout << "Showing success message" << endl;
    });
    
    submitBtn.click();
    
    return 0;
}
```

### 10. Advanced Lambda Techniques
**Recursive Lambdas**

``` cpp
#include <iostream>
#include <functional>
using namespace std;

int main() {
    // ═══════════════════════════════════════════════════════════
    // METHOD 1: Using std::function
    // ═══════════════════════════════════════════════════════════
    
    function<int(int)> factorial = [&factorial](int n) -> int {
        if (n <= 1) return 1;
        return n * factorial(n - 1);
    };
    
    cout << "factorial(5) = " << factorial(5) << endl;
    
    // ═══════════════════════════════════════════════════════════
    // METHOD 2: Y-Combinator (pass lambda to itself)
    // ═══════════════════════════════════════════════════════════
    
    auto factorialY = [](auto self, int n) -> int {
        if (n <= 1) return 1;
        return n * self(self, n - 1);
    };
    
    cout << "factorialY(5) = " << factorialY(factorialY, 5) << endl;
    
    // ═══════════════════════════════════════════════════════════
    // METHOD 3: Generic Y-Combinator Helper
    // ═══════════════════════════════════════════════════════════
    
    // Y-combinator that makes recursion easier
    auto Y = [](auto f) {
        return [f](auto... args) {
            return f(f, args...);
        };
    };
    
    auto fib = Y([](auto self, int n) -> int {
        if (n <= 1) return n;
        return self(self, n - 1) + self(self, n - 2);
    });
    
    cout << "fib(10) = " << fib(10) << endl;
    
    // ═══════════════════════════════════════════════════════════
    // RECURSIVE LAMBDA FOR TREE TRAVERSAL
    // ═══════════════════════════════════════════════════════════
    
    struct Node {
        int value;
        Node* left = nullptr;
        Node* right = nullptr;
    };
    
    // Build a simple tree
    Node root{1}, left{2}, right{3}, ll{4}, lr{5};
    root.left = &left;
    root.right = &right;
    left.left = &ll;
    left.right = &lr;
    
    // Recursive traversal
    function<void(Node*)> inorder = [&inorder](Node* node) {
        if (!node) return;
        inorder(node->left);
        cout << node->value << " ";
        inorder(node->right);
    };
    
    cout << "Inorder traversal: ";
    inorder(&root);
    cout << endl;
    
    return 0;
}
```

**Stateful Lambdas**

``` cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main() {
    // ═══════════════════════════════════════════════════════════
    // COUNTER
    // ═══════════════════════════════════════════════════════════
    
    auto makeCounter = [](int start = 0) {
        return [count = start]() mutable {
            return count++;
        };
    };
    
    auto counter1 = makeCounter(0);
    auto counter2 = makeCounter(100);
    
    cout << "Counter1: " << counter1() << ", " << counter1() << ", " << counter1() << endl;
    cout << "Counter2: " << counter2() << ", " << counter2() << ", " << counter2() << endl;
    
    // ═══════════════════════════════════════════════════════════
    // ACCUMULATOR
    // ═══════════════════════════════════════════════════════════
    
    auto makeAccumulator = [](int initial = 0) {
        return [sum = initial](int value) mutable {
            sum += value;
            return sum;
        };
    };
    
    auto acc = makeAccumulator(0);
    cout << "Accumulator: " << acc(10) << ", " << acc(20) << ", " << acc(30) << endl;
    
    // ═══════════════════════════════════════════════════════════
    // MEMOIZATION
    // ═══════════════════════════════════════════════════════════
    
    auto memoizedFib = [cache = vector<long long>(100, -1)](int n) mutable -> long long {
        if (n <= 1) return n;
        if (cache[n] != -1) return cache[n];
        
        // Need recursive call - use local lambda
        function<long long(int)> fib = [&](int n) -> long long {
            if (n <= 1) return n;
            if (cache[n] != -1) return cache[n];
            return cache[n] = fib(n - 1) + fib(n - 2);
        };
        
        return cache[n] = fib(n);
    };
    
    cout << "Memoized fib(40) = " << memoizedFib(40) << endl;
    
    // ═══════════════════════════════════════════════════════════
    // GENERATOR
    // ═══════════════════════════════════════════════════════════
    
    auto rangeGenerator = [](int start, int end) {
        return [current = start, end]() mutable -> pair<bool, int> {
            if (current >= end) return {false, 0};
            return {true, current++};
        };
    };
    
    auto gen = rangeGenerator(1, 5);
    cout << "Generator: ";
    while (true) {
        auto [valid, value] = gen();
        if (!valid) break;
        cout << value << " ";
    }
    cout << endl;
    
    return 0;
}
```

**Lambda in Constexpr Context (C++17)**

``` cpp
#include <iostream>
#include <array>
using namespace std;

int main() {
    // ═══════════════════════════════════════════════════════════
    // CONSTEXPR LAMBDA (C++17)
    // ═══════════════════════════════════════════════════════════
    
    // Lambdas are implicitly constexpr if possible
    constexpr auto square = [](int x) { return x * x; };
    constexpr int result = square(5);  // Computed at compile time!
    
    cout << "Compile-time square(5) = " << result << endl;
    
    // ═══════════════════════════════════════════════════════════
    // CONSTEXPR LAMBDA FOR ARRAY INITIALIZATION
    // ═══════════════════════════════════════════════════════════
    
    constexpr auto generateSquares = []() {
        array<int, 10> arr{};
        for (int i = 0; i < 10; i++) {
            arr[i] = i * i;
        }
        return arr;
    };
    
    constexpr auto squares = generateSquares();
    
    cout << "Compile-time generated squares: ";
    for (int x : squares) cout << x << " ";
    cout << endl;
    
    // ═══════════════════════════════════════════════════════════
    // CONSTEXPR FIBONACCI
    // ═══════════════════════════════════════════════════════════
    
    constexpr auto fib = [](auto self, int n) -> int {
        if (n <= 1) return n;
        return self(self, n - 1) + self(self, n - 2);
    };
    
    constexpr int fib10 = fib(fib, 10);
    cout << "Compile-time fib(10) = " << fib10 << endl;
    
    // ═══════════════════════════════════════════════════════════
    // CONSTEXPR LAMBDA WITH STATIC_ASSERT
    // ═══════════════════════════════════════════════════════════
    
    constexpr auto isEven = [](int x) { return x % 2 == 0; };
    
    static_assert(isEven(4), "4 should be even");
    static_assert(!isEven(5), "5 should be odd");
    
    cout << "Static assertions passed!" << endl;
    
    return 0;
}
```
**Immediately Invoked Lambda Expressions (IIFE)**

``` cpp
#include <iostream>
#include <mutex>
#include <vector>
using namespace std;

int main() {
    // ═══════════════════════════════════════════════════════════
    // COMPLEX CONST INITIALIZATION
    // ═══════════════════════════════════════════════════════════
    
    const int MAX_VALUE = []() {
        int result = 0;
        for (int i = 1; i <= 10; i++) {
            result += i * i;
        }
        return result;
    }();  // Immediately invoked
    
    cout << "MAX_VALUE: " << MAX_VALUE << endl;
    
    // ═══════════════════════════════════════════════════════════
    // CONDITIONAL INITIALIZATION
    // ═══════════════════════════════════════════════════════════
    
    bool useAdvanced = true;
    
    const string config = [useAdvanced]() {
        if (useAdvanced) {
            // Complex setup
            return "Advanced configuration";
        } else {
            return "Basic configuration";
        }
    }();
    
    cout << "Config: " << config << endl;
    
    // ═══════════════════════════════════════════════════════════
    // SCOPE-LIMITED MUTEX LOCK
    // ═══════════════════════════════════════════════════════════
    
    mutex mtx;
    vector<int> sharedData;
    
    // Use IIFE to limit scope of lock
    [&mtx, &sharedData]() {
        lock_guard<mutex> lock(mtx);
        sharedData.push_back(42);
        // Lock released at end of lambda
    }();
    
    // ═══════════════════════════════════════════════════════════
    // INITIALIZE WITH TRY-CATCH
    // ═══════════════════════════════════════════════════════════
    
    const int value = []() {
        try {
            // Might throw
            return stoi("42");
        } catch (...) {
            return 0;  // Default value
        }
    }();
    
    cout << "Value: " << value << endl;
    
    // ═══════════════════════════════════════════════════════════
    // DEBUG OUTPUT
    // ═══════════════════════════════════════════════════════════
    
    int x = 10, y = 20;
    
    // Debug print without extra variables
    [&]() {
        cout << "Debug: x=" << x << ", y=" << y << ", sum=" << (x + y) << endl;
    }();
    
    return 0;
}
```

### 11. Best Practices
**Summary Table**

``` 
┌─────────────────────────────────────────────────────────────────┐
│                  LAMBDA BEST PRACTICES                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  CAPTURE GUIDELINES:                                            │
│  ───────────────────                                            │
│                                                                 │
│  USE           WHEN                                             │
│  ───           ────                                             │
│  []            No external variables needed                     │
│  [x]           Need read-only copy of x                         │
│  [&x]          Need to modify x, x outlives lambda              │
│  [=]           Need multiple vars by value, keep short          │
│  [&]           Need multiple vars by ref, very short scope      │
│  [x = expr]    Move-only types, computed captures               │
│  [*this]       Lambda may outlive object (C++17)                │
│                                                                 │
│  AVOID:                                                         │
│  ──────                                                         │
│  [=] or [&]    for long-lived or returned lambdas               │
│  [&] in loops  captures reference to changing variable          │
│  [this]        if lambda may outlive object                     │
│                                                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  PARAMETER GUIDELINES:                                          │
│  ─────────────────────                                          │
│                                                                 │
│  TYPE              USE FOR                                      │
│  ────              ───────                                      │
│  (int x)           Small, copyable types                        │
│  (const T& x)      Large objects, read-only                     │
│  (T& x)            Need to modify argument                      │
│  (T&& x)           Accept rvalues, move semantics               │
│  (auto x)          Generic lambdas                              │
│  (auto&& x)        Perfect forwarding                           │
│                                                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  GENERAL GUIDELINES:                                            │
│  ───────────────────                                            │
│                                                                 │
│  ✓ Keep lambdas short and focused                              │
│  ✓ Use auto for lambda type (not std::function if possible)    │
│  ✓ Add noexcept if lambda doesn't throw                        │
│  ✓ Use trailing return type if deduction fails                 │
│  ✓ Prefer explicit captures over [=] or [&]                    │
│  ✓ Use IIFE for complex const initialization                   │
│  ✓ Add mutable only when needed                                │
│                                                                 │
│  ✗ Don't capture everything ([=] or [&]) unnecessarily         │
│  ✗ Don't return lambdas capturing references to locals         │
│  ✗ Don't use std::function when auto suffices                  │
│  ✗ Don't make lambdas too long (extract named function)        │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**Code Examples**
``` cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <functional>
using namespace std;

// ═══════════════════════════════════════════════════════════════
// ✓ GOOD PRACTICES
// ═══════════════════════════════════════════════════════════════

void goodPractices() {
    // ✓ Use auto for lambda type
    auto add = [](int a, int b) { return a + b; };
    
    // ✓ Explicit captures are clearer
    int threshold = 10;
    auto isAbove = [threshold](int x) { return x > threshold; };
    
    // ✓ Use const ref for large objects
    auto processVector = [](const vector<int>& v) {
        return accumulate(v.begin(), v.end(), 0);
    };
    
    // ✓ Use init capture for move-only types
    auto ptr = make_unique<int>(42);
    auto usePtr = [p = move(ptr)]() { return *p; };
    
    // ✓ Add noexcept when appropriate
    auto safeLambda = [](int x) noexcept { return x * 2; };
    
    // ✓ Use IIFE for complex initialization
    const auto config = []() {
        // Complex logic here
        return "configured";
    }();
    
    // ✓ Short, focused lambdas
    vector<int> nums = {1, 2, 3, 4, 5};
    auto evens = count_if(nums.begin(), nums.end(), 
        [](int n) { return n % 2 == 0; });
}

// ═══════════════════════════════════════════════════════════════
// ✗ BAD PRACTICES
// ═══════════════════════════════════════════════════════════════

void badPractices() {
    // ✗ Unnecessary use of std::function
    // function<int(int, int)> add = [](int a, int b) { return a + b; };
    // Better: auto add = [](int a, int b) { return a + b; };
    
    // ✗ Capturing everything when not needed
    int x = 1, y = 2, z = 3;
    // auto lambda = [=]() { return x; };  // Captures y, z unnecessarily
    // Better: auto lambda = [x]() { return x; };
    
    // ✗ Returning lambda with dangling reference
    /*
    auto bad = []() {
        int local = 42;
        return [&local]() { return local; };  // DANGLING!
    };
    */
    
    // ✗ Lambda too long (should be a named function)
    /*
    auto veryLongLambda = [](/*...*/) {
        // 50+ lines of code
        // Hard to read, test, reuse
    };
    */
}

// ═══════════════════════════════════════════════════════════════
// WHEN TO USE NAMED FUNCTION VS LAMBDA
// ═══════════════════════════════════════════════════════════════

// Use named function when:
// - Logic is reused in multiple places
// - Function is long/complex
// - Recursive without std::function
// - Needs to be a friend/virtual
bool isValid(int value) {
    return value > 0 && value < 100;
}

// Use lambda when:
// - Short, one-off use
// - Needs to capture context
// - Used inline with algorithms
// - Callback for local operation
void useLambda() {
    int offset = 10;
    vector<int> nums = {1, 2, 3};
    transform(nums.begin(), nums.end(), nums.begin(),
        [offset](int n) { return n + offset; });
}
```

**Quick Reference Card**
``` 
┌─────────────────────────────────────────────────────────────────┐
│                  LAMBDA QUICK REFERENCE                         │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  SYNTAX:                                                        │
│  [captures](params) mutable noexcept -> ret { body }            │
│                                                                 │
│  CAPTURES:                                                      │
│  []        - Nothing                                            │
│  [=]       - All by value                                       │
│  [&]       - All by reference                                   │
│  [x]       - x by value                                         │
│  [&x]      - x by reference                                     │
│  [=, &x]   - All by value, x by reference                       │
│  [&, x]    - All by reference, x by value                       │
│  [this]    - this pointer                                       │
│  [*this]   - Copy of *this (C++17)                              │
│  [x = e]   - Init capture (C++14)                               │
│                                                                 │
│  PARAMETERS:                                                    │
│  (int x)        - By value                                      │
│  (int& x)       - By reference                                  │
│  (const T& x)   - Const reference                               │
│  (auto x)       - Generic (C++14)                               │
│  (auto&& x)     - Forwarding reference                          │
│  <typename T>   - Template lambda (C++20)                       │
│                                                                 │
│  RETURN:                                                        │
│  -> int         - Explicit return type                          │
│  -> auto        - Deduced                                       │
│  -> decltype(auto) - Preserve references                        │
│                                                                 │
│  SPECIFIERS:                                                    │
│  mutable        - Allow modifying captures                      │
│  constexpr      - Compile-time evaluation (C++17)               │
│  noexcept       - No exceptions                                 │
│                                                                 │
│  STORAGE:                                                       │
│  auto           - Best (unique type)                            │
│  function<>     - Type-erased (overhead)                        │
│  fn_ptr         - Only non-capturing                            │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```















